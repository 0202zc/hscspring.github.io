<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  
  <meta name="description" content="Yam | AI | NLP | 人工智能 | 哲学 | 自然语言处理 | 机器学习" />
  

  
  
  
  
  
  <title>Yam</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Yam | AI | NLP | 人工智能 | 哲学 | 自然语言处理 | 机器学习">
<meta property="og:type" content="website">
<meta property="og:title" content="Yam">
<meta property="og:url" content="https://www.yam.gift/page/6/index.html">
<meta property="og:site_name" content="Yam">
<meta property="og:description" content="Yam | AI | NLP | 人工智能 | 哲学 | 自然语言处理 | 机器学习">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yam">
<meta name="twitter:description" content="Yam | AI | NLP | 人工智能 | 哲学 | 自然语言处理 | 机器学习">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
<link rel="alternate" href="/atom.xml" title="Yam" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Yam" rel="home">Yam</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">Feeling, Coding, Thinking</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/series/">Series</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives/">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/about/">About</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://github.com/hscspring">Projects</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-DSA/2019-12-15-Coding-Review2-Ch2" class="post-DSA/2019-12-15-Coding-Review2-Ch2 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch2/">剑指 Offer2（Python 版）解析（Ch2）</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch2/" data-id="ckggncis5005mmtbzkrb7ln8z" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <div class="toc"><ul class="toc-item"><li><span><a href="#第一章：面试的流程" data-toc-modified-id="第一章：面试的流程-1">第一章：面试的流程 </a></span></li><li><span><a href="#第二章：面试需要的基础知识" data-toc-modified-id="第二章：面试需要的基础知识-2">第二章：面试需要的基础知识 </a></span><ul class="toc-item"><li><span><a href="#面试题-2：实现-Singleton-模式" data-toc-modified-id="面试题-2：实现-Singleton-模式-2.1">面试题 2：实现 Singleton 模式 </a></span></li><li><span><a href="#面试题-3（一）：找出数组中重复的数字" data-toc-modified-id="面试题-3（一）：找出数组中重复的数字-2.2">面试题 3（一）：找出数组中重复的数字 </a></span></li><li><span><a href="#面试题-3（二）：不修改数组找出重复的数字" data-toc-modified-id="面试题-3（二）：不修改数组找出重复的数字-2.3">面试题 3（二）：不修改数组找出重复的数字 </a></span></li><li><span><a href="#面试题-4：二维数组中的查找" data-toc-modified-id="面试题-4：二维数组中的查找-2.4">面试题 4：二维数组中的查找 </a></span></li><li><span><a href="#面试题-5：替换空格" data-toc-modified-id="面试题-5：替换空格-2.5">面试题 5：替换空格 </a></span></li><li><span><a href="#面试题-6：从尾到头打印链表" data-toc-modified-id="面试题-6：从尾到头打印链表-2.6">面试题 6：从尾到头打印链表 </a></span></li><li><span><a href="#面试题-7：重建二叉树" data-toc-modified-id="面试题-7：重建二叉树-2.7">面试题 7：重建二叉树 </a></span></li><li><span><a href="#面试题-8：二叉树的下一个节点" data-toc-modified-id="面试题-8：二叉树的下一个节点-2.8">面试题 8：二叉树的下一个节点 </a></span></li><li><span><a href="#面试题-9：用两个栈实现队列" data-toc-modified-id="面试题-9：用两个栈实现队列-2.9">面试题 9：用两个栈实现队列 </a></span></li><li><span><a href="#面试题-10：斐波那契数列" data-toc-modified-id="面试题-10：斐波那契数列-2.10">面试题 10：斐波那契数列 </a></span></li><li><span><a href="#面试题-11：旋转数组的最小数字" data-toc-modified-id="面试题-11：旋转数组的最小数字-2.11">面试题 11：旋转数组的最小数字 </a></span></li><li><span><a href="#面试题-12：矩阵中的路径" data-toc-modified-id="面试题-12：矩阵中的路径-2.12">面试题 12：矩阵中的路径 </a></span></li><li><span><a href="#面试题-13：机器人的运动范围" data-toc-modified-id="面试题-13：机器人的运动范围-2.13">面试题 13：机器人的运动范围 </a></span></li><li><span><a href="#面试题-14：剪绳子" data-toc-modified-id="面试题-14：剪绳子-2.14">面试题 14：剪绳子 </a></span></li><li><span><a href="#面试题-15：二进制中-1-的个数" data-toc-modified-id="面试题-15：二进制中-1-的个数-2.15">面试题 15：二进制中 1 的个数 </a></span></li></ul></li></ul></div>

<p><strong>具体实现和测试代码</strong>：</p>
<ul>
<li><a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python" target="_blank" rel="noopener">The-DataStructure-and-Algorithms/CodingInterview2-Python</a></li>
</ul>
<p><strong>系列解析</strong>（TBD）：</p>
<ul>
<li>Python 单例模式</li>
<li>好玩儿的 DP</li>
<li>递归还是递归</li>
<li>双指针的威力</li>
<li>双列表的威力</li>
<li>有趣的排列组合</li>
</ul>
<blockquote>
<p><strong>特别说明</strong>：下文中的实例代码一般仅包括核心算法（不一定能直接运行），完整代码可以参考对应的链接。</p>
</blockquote>
        
          <p class="article-more-link">
            <a href="/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch2/#more" class="more-link">More <span class="meta-nav">→</span></a>
          </p>
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch2/">
    <time datetime="2019-12-15T15:00:00.000Z" class="entry-date">
        2019-12-15
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
</article>





  
    <article id="post-DSA/2019-12-15-Coding-Review2-Ch5" class="post-DSA/2019-12-15-Coding-Review2-Ch5 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch5/">剑指 Offer2（Python 版）解析（Ch5）</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch5/" data-id="ckggncisc005umtbz8mg9zzyk" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <div class="toc"><ul class="toc-item"><li><span><a href="#第五章：优化时间和空间效率" data-toc-modified-id="第五章：优化时间和空间效率-1">第五章：优化时间和空间效率</a></span><ul class="toc-item"><li><span><a href="#面试题-39：数组中出现次数超过一半的数字" data-toc-modified-id="面试题-39：数组中出现次数超过一半的数字-1.1">面试题 39：数组中出现次数超过一半的数字</a></span></li><li><span><a href="#面试题-40：最小的-k-个数" data-toc-modified-id="面试题-40：最小的-k-个数-1.2">面试题 40：最小的 k 个数</a></span></li><li><span><a href="#面试题-41：数据流中的中位数" data-toc-modified-id="面试题-41：数据流中的中位数-1.3">面试题 41：数据流中的中位数</a></span></li><li><span><a href="#面试题-42：连续子数组的最大和" data-toc-modified-id="面试题-42：连续子数组的最大和-1.4">面试题 42：连续子数组的最大和</a></span></li><li><span><a href="#面试题-43：从-1-到-n-整数中-1-出现的次数" data-toc-modified-id="面试题-43：从-1-到-n-整数中-1-出现的次数-1.5">面试题 43：从 1 到 n 整数中 1 出现的次数</a></span></li><li><span><a href="#面试题-44：数字序列中某一位的数字" data-toc-modified-id="面试题-44：数字序列中某一位的数字-1.6">面试题 44：数字序列中某一位的数字</a></span></li><li><span><a href="#面试题-45：把数组排成最小的数" data-toc-modified-id="面试题-45：把数组排成最小的数-1.7">面试题 45：把数组排成最小的数</a></span></li><li><span><a href="#面试题-46：把数字翻译成字符串" data-toc-modified-id="面试题-46：把数字翻译成字符串-1.8">面试题 46：把数字翻译成字符串</a></span></li><li><span><a href="#面试题-47：礼物的最大价值" data-toc-modified-id="面试题-47：礼物的最大价值-1.9">面试题 47：礼物的最大价值</a></span></li><li><span><a href="#面试题-48：最长不含重复字符的子字符串" data-toc-modified-id="面试题-48：最长不含重复字符的子字符串-1.10">面试题 48：最长不含重复字符的子字符串</a></span></li><li><span><a href="#面试题-49：丑数" data-toc-modified-id="面试题-49：丑数-1.11">面试题 49：丑数</a></span></li><li><span><a href="#面试题-50（一）：字符串中第一个只出现一次的字符" data-toc-modified-id="面试题-50（一）：字符串中第一个只出现一次的字符-1.12">面试题 50（一）：字符串中第一个只出现一次的字符</a></span></li><li><span><a href="#面试题-50（二）：字符流中第一个只出现一次的字符" data-toc-modified-id="面试题-50（二）：字符流中第一个只出现一次的字符-1.13">面试题 50（二）：字符流中第一个只出现一次的字符</a></span></li><li><span><a href="#面试题-51：数组中的逆序对" data-toc-modified-id="面试题-51：数组中的逆序对-1.14">面试题 51：数组中的逆序对</a></span></li><li><span><a href="#面试题-52：两个链表的第一个公共节点" data-toc-modified-id="面试题-52：两个链表的第一个公共节点-1.15">面试题 52：两个链表的第一个公共节点</a></span></li></ul></li></ul></div>


<p><strong>具体实现和测试代码</strong>：</p>
<ul>
<li><a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python" target="_blank" rel="noopener">The-DataStructure-and-Algorithms/CodingInterview2-Python</a></li>
</ul>
<p><strong>系列解析</strong>（TBD）：</p>
<ul>
<li>Python 单例模式</li>
<li>好玩儿的 DP</li>
<li>递归还是递归</li>
<li>双指针的威力</li>
<li>双列表的威力</li>
<li>有趣的排列组合</li>
</ul>
<blockquote>
<p><strong>特别说明</strong>：下文中的实例代码一般仅包括核心算法（不一定能直接运行），完整代码可以参考对应的链接。</p>
</blockquote>
        
          <p class="article-more-link">
            <a href="/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch5/#more" class="more-link">More <span class="meta-nav">→</span></a>
          </p>
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/15/DSA/2019-12-15-Coding-Review2-Ch5/">
    <time datetime="2019-12-15T15:00:00.000Z" class="entry-date">
        2019-12-15
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
</article>





  
    <article id="post-Paper/2019-12-15-Label-Attributes-Representation-Paper" class="post-Paper/2019-12-15-Label-Attributes-Representation-Paper post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/15/Paper/2019-12-15-Label-Attributes-Representation-Paper/">Few-Shot Charge Prediction with Discriminative Legal Attributes 论文笔记</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/15/Paper/2019-12-15-Label-Attributes-Representation-Paper/" data-id="ckggnciuk00aemtbzkiuucazn" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>Paper: <a href="http://nlp.csai.tsinghua.edu.cn/~tcc/publications/coling2018_attribute.pdf" target="_blank" rel="noopener">coling2018_attribute.pdf</a></p>
<p>code: <a href="https://github.com/thunlp/attribute_charge" target="_blank" rel="noopener">thunlp/attribute_charge</a></p>
<p>核心思想：基于类别属性的注意力机制共同学习属性感知和无属性的文本表示。</p>
<p>这是 COLING2018 上的一篇老论文了，最近因为一些事情正好遇上，当时大概看了一下就发现这篇文章正好解决了我之前在做多分类<a href="https://github.com/hscspring/Multi-Label-Text-Classification-for-Chinese#others" target="_blank" rel="noopener">任务</a>时没有解决的问题。所以拿来记录一下，顺便研究下代码。</p>
        
          <p class="article-more-link">
            <a href="/2019/12/15/Paper/2019-12-15-Label-Attributes-Representation-Paper/#more" class="more-link">More <span class="meta-nav">→</span></a>
          </p>
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/15/Paper/2019-12-15-Label-Attributes-Representation-Paper/">
    <time datetime="2019-12-15T11:00:00.000Z" class="entry-date">
        2019-12-15
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Feeling/">Feeling</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Confusing-Labels/">Confusing Labels</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Few-Shot/">Few-Shot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Imbalance-Data/">Imbalance Data</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NLP/">NLP</a></li></ul>

    </footer>
</article>





  
    <article id="post-KG/2019-12-11-Relationship-Extraction" class="post-KG/2019-12-11-Relationship-Extraction post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/11/KG/2019-12-11-Relationship-Extraction/">关系提取简述</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/11/KG/2019-12-11-Relationship-Extraction/" data-id="ckggncisq006wmtbza2pfve13" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>之前整理过一篇关于信息提取的笔记，也是基于大名鼎鼎的 <a href="https://web.stanford.edu/~jurafsky/slp3/" target="_blank" rel="noopener">SLP</a> 第 18 章的内容，最近在做一个 chatbot 的 <a href="https://yam.gift/2019/12/02/2019-12-02-NLM/" target="_blank" rel="noopener">NLMLayer</a> 时涉及到了不少知识图谱有关的技术，由于 NLMLayer 默认的输入是 NLU 的 output，所以实体识别（包括实体和类别）已经自动完成了。接下来最重要的就是实体属性和关系提取了，所以这里就针对这块内容做一个整理。</p>
<p>属性一般的形式是（实体，属性，属性值），关系的一般形式是（实体，关系，实体）。简单来区分的话，关系涉及到两个实体，而属性只有一个实体。属性提取的文章比较少，关系提取方面倒是比较成熟，不过这两者之间其实可以借鉴的。具体的一些方法其实<a href="https://yam.gift/2019/04/09/SLP/2019-04-09-Information-Extraction/" target="_blank" rel="noopener">这里</a>已经提到不少了，这里单独提出来再梳理一遍。</p>
        
          <p class="article-more-link">
            <a href="/2019/12/11/KG/2019-12-11-Relationship-Extraction/#more" class="more-link">More <span class="meta-nav">→</span></a>
          </p>
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/11/KG/2019-12-11-Relationship-Extraction/">
    <time datetime="2019-12-11T15:00:00.000Z" class="entry-date">
        2019-12-11
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Knowledge-Graph/">Knowledge Graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NLP/">NLP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Relationship-Extraction/">Relationship Extraction</a></li></ul>

    </footer>
</article>





  
    <article id="post-2019-12-09-AINLP-GPU-Guide" class="post-2019-12-09-AINLP-GPU-Guide post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/09/2019-12-09-AINLP-GPU-Guide/">AINLP GPU 使用体验指南</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/09/2019-12-09-AINLP-GPU-Guide/" data-id="ckggncipf001emtbz9a3g4jxa" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><a href="https://gpu.ainlp.cn/home" target="_blank" rel="noopener">AINLP-DBC GPU</a> 是一个 GPU 算力服务平台，采用 DBC TOKEN 进行结算。在这里可以租用 GPU，也可以将自己的 GPU 出租出去。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>第一步：<a href="https://gpu.ainlp.cn/gpu/myWallet" target="_blank" rel="noopener">创建钱包</a></p>
<p>这里需要输入密码，之后会产生一个加密后的私钥文件，下载继续后会产生你真正的私钥。一定要记住你的密码并在物理介质上保存好加密后的私钥文件以及你的私钥。只有通过密码+加密的私钥文件，或者私钥才能打开你的钱包，如果都丢了，就等于你的钱包没了。</p>
<p>第二步：充值 DBC</p>
<p>点击 “如何购买 DBC” 链接，选择自己喜欢的方式充值即可，推荐使用支付宝，点击 “继续” 后，充值一定金额（比如 1块或者 0.1 块）就好了。这步其实就是给你的钱包地址充值一定数额的 DBC。大概等个几十秒就能在 “我的钱包” 里看到你购买金额对应的 DBC 数量了。</p>
<p>第三步：<a href="https://gpu.ainlp.cn/gpu/myMachineUnlock" target="_blank" rel="noopener">绑定邮箱</a></p>
<p>点击 “绑定邮箱” 后，输入邮箱地址，会给你发送一个类似 <code>请输入如下数量dbc:0.7311,验证有效期为30分钟</code> 内容的邮件，将对应的额度（比如这里的 0.7311）输入 “验证的 DBC 数量” 框即可完成绑定。</p>
<p>第四步：<a href="https://gpu.ainlp.cn/gpu/list" target="_blank" rel="noopener">选择机器</a></p>
<p>在列表中选择一台符合自己要求的机器，点击 “租用” 后，填写租用时长（最短 1 小时），等待大约 1 分钟左右（验证机器环境），确认支付后就可以正式使用了。</p>
        
          <p class="article-more-link">
            <a href="/2019/12/09/2019-12-09-AINLP-GPU-Guide/#more" class="more-link">More <span class="meta-nav">→</span></a>
          </p>
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/09/2019-12-09-AINLP-GPU-Guide/">
    <time datetime="2019-12-09T13:00:00.000Z" class="entry-date">
        2019-12-09
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Feeling/">Feeling</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer/">Computer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GPU/">GPU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ssh/">ssh</a></li></ul>

    </footer>
</article>





  
    <article id="post-Paper/2019-12-08-ELECTRA-Paper" class="post-Paper/2019-12-08-ELECTRA-Paper post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/08/Paper/2019-12-08-ELECTRA-Paper/">ELECTRA 论文笔记</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/08/Paper/2019-12-08-ELECTRA-Paper/" data-id="ckggnciuj00abmtbz8hdq0mi7" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>Paper: <a href="https://openreview.net/pdf?id=r1xMH1BtvB" target="_blank" rel="noopener">ELECTRA: PRE-TRAINING TEXT ENCODERS AS DISCRIMINATORS RATHER THAN GENERATORS</a></p>
<p>本来代码还没出来不想看的，不过前段时间确实太火了，先偷偷瞄一眼，看看到底是什么个情况。</p>
<p>核心思想：Replaced token detection Task + Transformer。</p>
        
          <p class="article-more-link">
            <a href="/2019/12/08/Paper/2019-12-08-ELECTRA-Paper/#more" class="more-link">More <span class="meta-nav">→</span></a>
          </p>
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/08/Paper/2019-12-08-ELECTRA-Paper/">
    <time datetime="2019-12-08T14:00:00.000Z" class="entry-date">
        2019-12-08
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Feeling/">Feeling</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Electra/">Electra</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NLP/">NLP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pre-training/">Pre-training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transformer/">Transformer</a></li></ul>

    </footer>
</article>





  
    <article id="post-Rust/RPL/2020-01-21-RPL-Brief-Note-Vol3-Style" class="post-Rust/RPL/2020-01-21-RPL-Brief-Note-Vol3-Style post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/03/Rust/RPL/2020-01-21-RPL-Brief-Note-Vol3-Style/">The Rust Programming Language Brief Note (Vol4-Style)</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/03/Rust/RPL/2020-01-21-RPL-Brief-Note-Vol3-Style/" data-id="ckplazpe8000ez2bzsgtg33hi" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
            <!-- Table of Contents -->
              
        <div class="toc"><ul class="toc-item"><li><span><a href="#13-Functional-Language-Features-Iterators-and-Closures" data-toc-modified-id="13-Functional-Language-Features-Iterators-and-Closures-1">13 Functional Language Features Iterators and Closures</a></span><ul class="toc-item"><li><span><a href="#13-1-Closures-Anonymous-Functions" data-toc-modified-id="13-1-Closures-Anonymous-Functions-1.1">13-1 Closures Anonymous Functions</a></span><ul class="toc-item"><li><span><a href="#13-1-1-Creating-an-Abstraction-of-Behavior-with-Closures" data-toc-modified-id="13-1-1-Creating-an-Abstraction-of-Behavior-with-Closures-1.1.1">13-1-1 Creating an Abstraction of Behavior with Closures</a></span></li><li><span><a href="#13-1-2-Closure-Type-Inference-and-Annotation" data-toc-modified-id="13-1-2-Closure-Type-Inference-and-Annotation-1.1.2">13-1-2 Closure Type Inference and Annotation</a></span></li><li><span><a href="#13-1-3-Storing-Closures-Using-Generic-Parameters-and-the-Fn-Traits" data-toc-modified-id="13-1-3-Storing-Closures-Using-Generic-Parameters-and-the-Fn-Traits-1.1.3">13-1-3 Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</a></span></li><li><span><a href="#13-1-4-Limitations-of-the-Cacher-Implementation" data-toc-modified-id="13-1-4-Limitations-of-the-Cacher-Implementation-1.1.4">13-1-4 Limitations of the <code>Cacher</code> Implementation</a></span></li><li><span><a href="#13-1-5-Capturing-the-Environment-with-Closures" data-toc-modified-id="13-1-5-Capturing-the-Environment-with-Closures-1.1.5">13-1-5 Capturing the Environment with Closures</a></span></li></ul></li><li><span><a href="#13-2-Processing-a-Series-of-Items-with-Iterators" data-toc-modified-id="13-2-Processing-a-Series-of-Items-with-Iterators-1.2">13-2 Processing a Series of Items with Iterators</a></span><ul class="toc-item"><li><span><a href="#13-2-1-The-Iterator-Trait-and-the-Next-Method" data-toc-modified-id="13-2-1-The-Iterator-Trait-and-the-Next-Method-1.2.1">13-2-1 The <code>Iterator</code> Trait and the <code>Next</code> Method</a></span></li><li><span><a href="#13-2-2-Methods-that-Consume-the-Iterator" data-toc-modified-id="13-2-2-Methods-that-Consume-the-Iterator-1.2.2">13-2-2 Methods that Consume the Iterator</a></span></li><li><span><a href="#13-2-3-Methods-that-Produce-Other-Iterators" data-toc-modified-id="13-2-3-Methods-that-Produce-Other-Iterators-1.2.3">13-2-3 Methods that Produce Other Iterators</a></span></li><li><span><a href="#13-2-4-Using-Closures-that-Capture-Their-Environment" data-toc-modified-id="13-2-4-Using-Closures-that-Capture-Their-Environment-1.2.4">13-2-4 Using Closures that Capture Their Environment</a></span></li><li><span><a href="#13-2-5-Creating-Our-Own-Iterators-with-the-Iterator-Trait" data-toc-modified-id="13-2-5-Creating-Our-Own-Iterators-with-the-Iterator-Trait-1.2.5">13-2-5 Creating Our Own Iterators with the <code>Iterator</code> Trait</a></span><ul class="toc-item"><li><span><a href="#13-2-5-1-Using-Our-Counter-Iterator's-next-method" data-toc-modified-id="13-2-5-1-Using-Our-Counter-Iterator's-next-method-1.2.5.1">13-2-5-1 Using Our <code>Counter</code> Iterator's <code>next</code> method</a></span></li><li><span><a href="#13-2-5-2-Using-Other-Iterator-Trait-Methods" data-toc-modified-id="13-2-5-2-Using-Other-Iterator-Trait-Methods-1.2.5.2">13-2-5-2 Using Other <code>Iterator</code> Trait Methods</a></span></li></ul></li></ul></li><li><span><a href="#13-3-Improving-Our-IO-Project" data-toc-modified-id="13-3-Improving-Our-IO-Project-1.3">13-3 Improving Our IO Project</a></span><ul class="toc-item"><li><span><a href="#13-3-1-Removing-a-clone-Using-an-Iterator" data-toc-modified-id="13-3-1-Removing-a-clone-Using-an-Iterator-1.3.1">13-3-1 Removing a <code>clone</code> Using an Iterator</a></span><ul class="toc-item"><li><span><a href="#13-3-1-1-Using-the-Returned-Iterator-Directly" data-toc-modified-id="13-3-1-1-Using-the-Returned-Iterator-Directly-1.3.1.1">13-3-1-1 Using the Returned Iterator Directly</a></span></li><li><span><a href="#13-3-1-2-Using-Iterator-Trait-Methods-Instead-of-Indexing" data-toc-modified-id="13-3-1-2-Using-Iterator-Trait-Methods-Instead-of-Indexing-1.3.1.2">13-3-1-2 Using <code>Iterator</code> Trait Methods Instead of Indexing</a></span></li></ul></li><li><span><a href="#13-3-2-Making-Code-Clearer-with-Iterator-Adaptors" data-toc-modified-id="13-3-2-Making-Code-Clearer-with-Iterator-Adaptors-1.3.2">13-3-2 Making Code Clearer with Iterator Adaptors</a></span></li></ul></li><li><span><a href="#13.4-Comparing-Performance:-Loop-vs.-Iterators" data-toc-modified-id="13.4-Comparing-Performance:-Loop-vs.-Iterators-1.4">13.4 Comparing Performance: Loop vs. Iterators</a></span></li></ul></li><li><span><a href="#17-Object-Oriented-Programming-Features-of-Rust" data-toc-modified-id="17-Object-Oriented-Programming-Features-of-Rust-2">17 Object Oriented Programming Features of Rust</a></span><ul class="toc-item"><li><span><a href="#17-1-Characteristics-of-Object-Oriented-Languages" data-toc-modified-id="17-1-Characteristics-of-Object-Oriented-Languages-2.1">17-1 Characteristics of Object-Oriented Languages</a></span><ul class="toc-item"><li><span><a href="#17-1-1-Objects-Contain-Data-and-Behavior" data-toc-modified-id="17-1-1-Objects-Contain-Data-and-Behavior-2.1.1">17-1-1 Objects Contain Data and Behavior</a></span></li><li><span><a href="#17-1-2-Encapsulation-that-Hides-Implementation-Details" data-toc-modified-id="17-1-2-Encapsulation-that-Hides-Implementation-Details-2.1.2">17-1-2 Encapsulation that Hides Implementation Details</a></span></li><li><span><a href="#17-1-3-Inheritance-as-a-Type-System-and-as-Code-Sharing" data-toc-modified-id="17-1-3-Inheritance-as-a-Type-System-and-as-Code-Sharing-2.1.3">17-1-3 Inheritance as a Type System and as Code Sharing</a></span></li></ul></li><li><span><a href="#17-2-Using-Trait-Objects-That-Allows-for-Values-of-Different-Types" data-toc-modified-id="17-2-Using-Trait-Objects-That-Allows-for-Values-of-Different-Types-2.2">17-2 Using Trait Objects That Allows for Values of Different Types</a></span><ul class="toc-item"><li><span><a href="#17-2-1-Defining-a-Trait-for-Common-Behavior" data-toc-modified-id="17-2-1-Defining-a-Trait-for-Common-Behavior-2.2.1">17-2-1 Defining a Trait for Common Behavior</a></span></li><li><span><a href="#17-2-2-Implementing-the-Trait" data-toc-modified-id="17-2-2-Implementing-the-Trait-2.2.2">17-2-2 Implementing the Trait</a></span></li><li><span><a href="#17-2-3-Trait-Objects-Perform-Dynamic-Dispatch" data-toc-modified-id="17-2-3-Trait-Objects-Perform-Dynamic-Dispatch-2.2.3">17-2-3 Trait Objects Perform Dynamic Dispatch</a></span></li><li><span><a href="#17-2-4-Object-Safety-Is-Required-for-Trait-Objects" data-toc-modified-id="17-2-4-Object-Safety-Is-Required-for-Trait-Objects-2.2.4">17-2-4 Object Safety Is Required for Trait Objects</a></span></li></ul></li><li><span><a href="#17-3-Implementing-an-Object-Oriented-Design-Pattern" data-toc-modified-id="17-3-Implementing-an-Object-Oriented-Design-Pattern-2.3">17-3 Implementing an Object-Oriented Design Pattern</a></span><ul class="toc-item"><li><span><a href="#17-3-1-Defining-Post-and-Creating-a-New-Instance-in-the-Draft-State" data-toc-modified-id="17-3-1-Defining-Post-and-Creating-a-New-Instance-in-the-Draft-State-2.3.1">17-3-1 Defining <code>Post</code> and Creating a New Instance in the Draft State</a></span></li><li><span><a href="#17-3-2-Storing-the-Text-of-the-Post-Content" data-toc-modified-id="17-3-2-Storing-the-Text-of-the-Post-Content-2.3.2">17-3-2 Storing the Text of the Post Content</a></span></li><li><span><a href="#17-3-3-Ensuring-the-Content-of-a-Draft-Post-Is-Empty" data-toc-modified-id="17-3-3-Ensuring-the-Content-of-a-Draft-Post-Is-Empty-2.3.3">17-3-3 Ensuring the Content of a Draft Post Is Empty</a></span></li><li><span><a href="#17-3-4-Requesting-a-Review-of-the-Post-Changes-Its-State" data-toc-modified-id="17-3-4-Requesting-a-Review-of-the-Post-Changes-Its-State-2.3.4">17-3-4 Requesting a Review of the Post Changes Its State</a></span></li><li><span><a href="#17-3-5-Adding-the-approve-Method-that-Changes-the-Behavior-of-content" data-toc-modified-id="17-3-5-Adding-the-approve-Method-that-Changes-the-Behavior-of-content-2.3.5">17-3-5 Adding the <code>approve</code> Method that Changes the Behavior of <code>content</code></a></span></li><li><span><a href="#17-3-6-Trade-offs-of-the-State-Pattern" data-toc-modified-id="17-3-6-Trade-offs-of-the-State-Pattern-2.3.6">17-3-6 Trade-offs of the State Pattern</a></span><ul class="toc-item"><li><span><a href="#17-3-6-1-Encoding-States-and-Behavior-as-Types" data-toc-modified-id="17-3-6-1-Encoding-States-and-Behavior-as-Types-2.3.6.1">17-3-6-1 Encoding States and Behavior as Types</a></span></li><li><span><a href="#17-3-6-2-Implementing-Transitions-as-Transformations-into-Different-Types" data-toc-modified-id="17-3-6-2-Implementing-Transitions-as-Transformations-into-Different-Types-2.3.6.2">17-3-6-2 Implementing Transitions as Transformations into Different Types</a></span></li></ul></li></ul></li></ul></li></ul></div>

<h2 id="13-Functional-Language-Features-Iterators-and-Closures"><a href="#13-Functional-Language-Features-Iterators-and-Closures" class="headerlink" title="13 Functional Language Features Iterators and Closures"></a>13 Functional Language Features Iterators and Closures</h2><h3 id="13-1-Closures-Anonymous-Functions"><a href="#13-1-Closures-Anonymous-Functions" class="headerlink" title="13-1 Closures Anonymous Functions"></a>13-1 Closures Anonymous Functions</h3><p>Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. We want to define code in one place in our program, but only <em>execute</em> that code where we actually need the result. This is a use case for closures!</p>
<h4 id="13-1-1-Creating-an-Abstraction-of-Behavior-with-Closures"><a href="#13-1-1-Creating-an-Abstraction-of-Behavior-with-Closures" class="headerlink" title="13-1-1 Creating an Abstraction of Behavior with Closures"></a>13-1-1 Creating an Abstraction of Behavior with Closures</h4><p>We can define a closure and store the <em>closure</em> in a variable rather than storing the result of the function call:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_workout</span></span>(intensity: <span class="keyword">u32</span>, random_number: <span class="keyword">u32</span>) &#123;</span><br><span class="line">    <span class="comment">// do not excute here</span></span><br><span class="line">    <span class="keyword">let</span> expensive_closure = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Today, do &#123;&#125; pushups!"</span>,</span><br><span class="line">            expensive_closure(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Next, do &#123;&#125; situps!"</span>,</span><br><span class="line">            expensive_closure(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Take a break today! Remember to stay hydrated!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">"Today, run for &#123;&#125; minutes!"</span>,</span><br><span class="line">                expensive_closure(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this <code>let</code> statement means <code>expensive_closure</code> contains the <em>definition</em> of an anonymous function, not the <em>resulting value</em> of calling the anonymous function. </p>
<p>Now the expensive calculation is called in only one place, and we’re only executing that code where we need the results. </p>
<p>However, we’re still calling the closure twice in the first <code>if</code> block, which will call the expensive code twice and make the user wait twice as long as they need to.</p>
<h4 id="13-1-2-Closure-Type-Inference-and-Annotation"><a href="#13-1-2-Closure-Type-Inference-and-Annotation" class="headerlink" title="13-1-2 Closure Type Inference and Annotation"></a>13-1-2 Closure Type Inference and Annotation</h4><p>Closures don’t require you to annotate the types of the parameters or the return value like <code>fn</code> functions do. Type annotations are required on functions because they’re part of an explicit interface exposed to your users.  Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. But closures aren’t used in an exposed interface like this: they’re stored in variables and used without naming them and exposing them to users of our library.</p>
<h4 id="13-1-3-Storing-Closures-Using-Generic-Parameters-and-the-Fn-Traits"><a href="#13-1-3-Storing-Closures-Using-Generic-Parameters-and-the-Fn-Traits" class="headerlink" title="13-1-3 Storing Closures Using Generic Parameters and the Fn Traits"></a>13-1-3 Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</h4><p>For the problem (still calling the closure twice in the first <code>if</code> block) before, we can create a struct that will hold the closure and the resulting value of calling the closure. The struct will execute the closure only if we need the resulting value, and it will cache the resulting value so the rest of our code doesn’t have to be responsible for saving and reusing the result. You may know this pattern as <em>memoization</em> or <em>lazy evaluation</em>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="keyword">u32</span>) -&gt; <span class="keyword">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="keyword">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code>. The trait bounds on <code>T</code> specify that it’s a closure by using the <code>Fn</code> trait. Any closure we want to store in the <code>calculation</code> field must have one <code>u32</code> parameter (specified within the parentheses after <code>Fn</code>) and must return a <code>u32</code>(specified after the <code>-&gt;</code>).</p>
<p>The <code>value</code> field is of type <code>Option&lt;u32&gt;</code>. Before we execute the closure, <code>value</code> will be <code>None</code>. When code using a <code>Cacher</code> asks for the <em>result</em> of the closure, the <code>Cacher</code> will execute the closure at that time and store the result within a <code>Some</code> variant in the <code>value</code> field. Then if the code asks for the result of the closure again, instead of executing the closure again, the <code>Cacher</code> will return the result held in the <code>Some</code> variant.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="keyword">u32</span>) -&gt; <span class="keyword">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(calculation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="keyword">u32</span>) -&gt; <span class="keyword">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="literal">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> v = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="literal">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_workout</span></span>(intensity: <span class="keyword">u32</span>, random_number: <span class="keyword">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> expensive_result = Cacher::new(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Today, do &#123;&#125; pushups!"</span>,</span><br><span class="line">            expensive_result.value(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Next, do &#123;&#125; situps!"</span>,</span><br><span class="line">            expensive_result.value(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Take a break today! Remember to stay hydrated!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">"Today, run for &#123;&#125; minutes!"</span>,</span><br><span class="line">                expensive_result.value(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead of saving the closure in a variable directly, we save a new instance of <code>Cacher</code> that holds the closure. Then, in each place we want the result, we call the <code>value</code> method on the <code>Cacher</code> instance. We can call the <code>value</code> method as many times as we want, or not call it at all, and the expensive calculation will be run a maximum of once.</p>
<h4 id="13-1-4-Limitations-of-the-Cacher-Implementation"><a href="#13-1-4-Limitations-of-the-Cacher-Implementation" class="headerlink" title="13-1-4 Limitations of the Cacher Implementation"></a>13-1-4 Limitations of the <code>Cacher</code> Implementation</h4><p>The first problem is that a <code>Cacher</code> instance assumes it will always get the same value for the parameter <code>arg</code> to the <code>value</code> method. Try modifying <code>Cacher</code> to hold a hash map rather than a single value. The keys of the hash map will be the <code>arg</code> values that are passed in, and the values of the hash map will be the result of calling the closure on that key. Instead of looking at whether <code>self.value</code> directly has a <code>Some</code> or a <code>None</code> value, the <code>value</code> function will look up the <code>arg</code> in the hash map and return the value if it’s present. If it’s not present, the <code>Cacher</code> will call the closure and save the resulting value in the hash map associated with its <code>arg</code> value.</p>
<p>The second problem with the current <code>Cacher</code> implementation is that it only accepts closures that take one parameter of type <code>u32</code> and return a <code>u32</code>. We might want to cache the results of closures that take a string slice and return <code>usize</code> values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the <code>Cacher</code> functionality.</p>
<h4 id="13-1-5-Capturing-the-Environment-with-Closures"><a href="#13-1-5-Capturing-the-Environment-with-Closures" class="headerlink" title="13-1-5 Capturing the Environment with Closures"></a>13-1-5 Capturing the Environment with Closures</h4><p>Closures have an additional capability that functions don’t have: <strong>they can capture their environment and access variables from the scope in which they’re defined.</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// function</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">equal_to_x</span></span>(z: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123; z == x &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// can't capture dynamic environment in a fn item; use the || &#123; ...&#125; closure form instead</span></span><br></pre></td></tr></table></figure>
<p>Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: taking ownership, borrowing mutably, and borrowing immutably. These are encoded in the three <code>Fn</code> traits as follows:</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known as the closure’s <em>environment</em>. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The <code>Once</code> part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>. </p>
<p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it’s owned by the new thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> equal_to_x = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"can't use x here: &#123;:?&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>x</code> value is moved into the closure when the closure is defined, because we added the <code>move</code> keyword. The closure then has ownership of <code>x</code>, and <code>main</code> isn’t allowed to use <code>x</code> anymore in the <code>println!</code> statement. Removing <code>println!</code> will fix this example.</p>
<p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based on what happens in the closure body.</p>
<h3 id="13-2-Processing-a-Series-of-Items-with-Iterators"><a href="#13-2-Processing-a-Series-of-Items-with-Iterators" class="headerlink" title="13-2 Processing a Series of Items with Iterators"></a>13-2 Processing a Series of Items with Iterators</h3><p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call methods that consume the iterator to use it up. </p>
<h4 id="13-2-1-The-Iterator-Trait-and-the-Next-Method"><a href="#13-2-1-The-Iterator-Trait-and-the-Next-Method" class="headerlink" title="13-2-1 The Iterator Trait and the Next Method"></a>13-2-1 The <code>Iterator</code> Trait and the <code>Next</code> Method</h4><p>All iterators implement a trait named <code>Iterator</code> that is defined in the standard library.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_demonstration</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code <em>consumes</em>, or uses up, the iterator. Each call to <code>next</code> eats up an item from the iterator. We didn’t need to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took ownership of <code>v1_iter</code> and made it mutable behind the scenes.</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable references to the values in the vector. The <code>iter</code> method produces an iterator over immutable references. </p>
<ul>
<li>If we want to create an iterator that takes ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code>. </li>
<li>Similarly, if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code>.</li>
</ul>
<h4 id="13-2-2-Methods-that-Consume-the-Iterator"><a href="#13-2-2-Methods-that-Consume-the-Iterator" class="headerlink" title="13-2-2 Methods that Consume the Iterator"></a>13-2-2 Methods that Consume the Iterator</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> total: <span class="keyword">i32</span> = v1_iter.sum();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We aren’t allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes ownership of the iterator we call it on.</p>
<h4 id="13-2-3-Methods-that-Produce-Other-Iterators"><a href="#13-2-3-Methods-that-Produce-Other-Iterators" class="headerlink" title="13-2-3 Methods that Produce Other Iterators"></a>13-2-3 Methods that Produce Other Iterators</h4><p>Other methods defined on the <code>Iterator</code> trait, known as <em>iterator adaptors</em>, allow you to change iterators into different kinds of iterators. You can chain multiple calls to iterator adaptors to perform complex actions in a readable way. But because all iterators are lazy, you have to call one of the consuming adaptor methods to get results from calls to iterator adaptors.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">v1.iter().map(|x| x + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy and do nothing unless consumed</span></span><br></pre></td></tr></table></figure>
<p>This code doesn’t do anything; the closure we’ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x + <span class="number">1</span>).collect();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// collect consumes the iterator and collects the resulting values into a collection data type.</span></span><br></pre></td></tr></table></figure>
<p>Because <code>map</code> takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the <code>Iterator</code> trait provides.</p>
<h4 id="13-2-4-Using-Closures-that-Capture-Their-Environment"><a href="#13-2-4-Using-Closures-that-Capture-Their-Environment" class="headerlink" title="13-2-4 Using Closures that Capture Their Environment"></a>13-2-4 Using Closures that Capture Their Environment</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shoe</span></span> &#123;</span><br><span class="line">    size: <span class="keyword">u32</span>,</span><br><span class="line">    style: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">shoes_in_my_size</span></span>(shoes: <span class="built_in">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="keyword">u32</span>) -&gt; <span class="built_in">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    <span class="comment">// filter to adapt that iterator </span></span><br><span class="line">    shoes.into_iter()</span><br><span class="line">        .filter(|s| s.size == shoe_size)</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">filters_by_size</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> shoes = <span class="built_in">vec!</span>[</span><br><span class="line">        Shoe &#123; size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">"sneaker"</span>) &#125;,</span><br><span class="line">        Shoe &#123; size: <span class="number">13</span>, style: <span class="built_in">String</span>::from(<span class="string">"sandal"</span>) &#125;,</span><br><span class="line">        Shoe &#123; size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">"boot"</span>) &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> in_my_size = shoes_in_my_size(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        in_my_size,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            Shoe &#123; size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">"sneaker"</span>) &#125;,</span><br><span class="line">            Shoe &#123; size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">"boot"</span>) &#125;,</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The closure captures the <code>shoe_size</code> parameter from the environment and compares the value with each shoe’s size, keeping only shoes of the size specified. </p>
<h4 id="13-2-5-Creating-Our-Own-Iterators-with-the-Iterator-Trait"><a href="#13-2-5-Creating-Our-Own-Iterators-with-the-Iterator-Trait" class="headerlink" title="13-2-5 Creating Our Own Iterators with the Iterator Trait"></a>13-2-5 Creating Our Own Iterators with the <code>Iterator</code> Trait</h4><p>You can create iterators that do anything you want by implementing the <code>Iterator</code> trait on your own types. As previously mentioned, the only method you’re required to provide a definition for is the <code>next</code> method. Once you’ve done that, you can use all other methods that have default implementations provided by the <code>Iterator</code> trait!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="keyword">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Counter &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="keyword">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="13-2-5-1-Using-Our-Counter-Iterator’s-next-method"><a href="#13-2-5-1-Using-Our-Counter-Iterator’s-next-method" class="headerlink" title="13-2-5-1 Using Our Counter Iterator’s next method"></a>13-2-5-1 Using Our <code>Counter</code> Iterator’s <code>next</code> method</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calling_next_directly</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = Counter::new();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.next(), <span class="literal">Some</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.next(), <span class="literal">Some</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.next(), <span class="literal">Some</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.next(), <span class="literal">Some</span>(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.next(), <span class="literal">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.next(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="13-2-5-2-Using-Other-Iterator-Trait-Methods"><a href="#13-2-5-2-Using-Other-Iterator-Trait-Methods" class="headerlink" title="13-2-5-2 Using Other Iterator Trait Methods"></a>13-2-5-2 Using Other <code>Iterator</code> Trait Methods</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">using_other_iterator_trait_methods</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum: <span class="keyword">u32</span> = Counter::new().zip(Counter::new().skip(<span class="number">1</span>))</span><br><span class="line">                                 .map(|(a, b)| a * b)</span><br><span class="line">                                 .filter(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                                 .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that <code>zip</code> produces only four pairs; the theoretical fifth pair <code>(5, None)</code> is never produced because <code>zip</code> returns <code>None</code> when either of its input iterators return <code>None</code>.</p>
<h3 id="13-3-Improving-Our-IO-Project"><a href="#13-3-Improving-Our-IO-Project" class="headerlink" title="13-3 Improving Our IO Project"></a>13-3 Improving Our IO Project</h3><h4 id="13-3-1-Removing-a-clone-Using-an-Iterator"><a href="#13-3-1-Removing-a-clone-Using-an-Iterator" class="headerlink" title="13-3-1 Removing a clone Using an Iterator"></a>13-3-1 Removing a <code>clone</code> Using an Iterator</h4><p>The IO project can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/minigrep" target="_blank" rel="noopener">here</a>, <code>clone</code> is used to make the <code>Config</code> own the values.</p>
<p>Here we change the <code>new</code> function to take ownership of an iterator as its argument instead of borrowing a slice.</p>
<h5 id="13-3-1-1-Using-the-Returned-Iterator-Directly"><a href="#13-3-1-1-Using-the-Returned-Iterator-Directly" class="headerlink" title="13-3-1-1 Using the Returned Iterator Directly"></a>13-3-1-1 Using the Returned Iterator Directly</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modify the src/main.rs</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> config = Config::new(env::args()).unwrap_or_else(|err| &#123;</span><br><span class="line">        eprintln!(<span class="string">"Problem parsing arguments: &#123;&#125;"</span>, err);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>env::args()</code> function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to <code>Config::new</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update src/lib.rs</span></span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(<span class="keyword">mut</span> args: std::env::Args) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="keyword">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<p>The standard library documentation for the <code>env::args</code> function shows that the type of the iterator it returns is <code>std::env::Args</code>. Because we’re taking ownership of <code>args</code> and we’ll be mutating <code>args</code> by iterating over it, we can add the <code>mut</code> keyword into the specification of the <code>args</code> parameter to make it mutable.</p>
<h5 id="13-3-1-2-Using-Iterator-Trait-Methods-Instead-of-Indexing"><a href="#13-3-1-2-Using-Iterator-Trait-Methods-Instead-of-Indexing" class="headerlink" title="13-3-1-2 Using Iterator Trait Methods Instead of Indexing"></a>13-3-1-2 Using <code>Iterator</code> Trait Methods Instead of Indexing</h5><p>The standard library documentation also mentions that <code>std::env::Args</code> implements the <code>Iterator</code> trait, so we know we can call the <code>next</code> method on it!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(<span class="keyword">mut</span> args: std::env::Args) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="keyword">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// the first value in the return value of env::args is the name of the program.</span></span><br><span class="line">    	args.next();</span><br><span class="line">        <span class="keyword">let</span> query = <span class="keyword">match</span> args.next() &#123;</span><br><span class="line">        	<span class="literal">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(<span class="string">"Didn't get a query string"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> filename = <span class="keyword">match</span> args.next() &#123;</span><br><span class="line">        	<span class="literal">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(<span class="string">"Didn't get a file name"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> case_sensitive = env::var(<span class="string">"CASE_INSENSITIVE"</span>).is_err();</span><br><span class="line">        <span class="literal">Ok</span>(Config &#123;query, filename, case_sensitive&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-3-2-Making-Code-Clearer-with-Iterator-Adaptors"><a href="#13-3-2-Making-Code-Clearer-with-Iterator-Adaptors" class="headerlink" title="13-3-2 Making Code Clearer with Iterator Adaptors"></a>13-3-2 Making Code Clearer with Iterator Adaptors</h4><p>We can write the <code>search</code> code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn’t have to manage concurrent access to the <code>results</code> vector. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">search</span></span>&lt;<span class="symbol">'a</span>&gt;(query: &amp;<span class="keyword">str</span>, contents: &amp;<span class="symbol">'a</span> <span class="keyword">str</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'a</span> <span class="keyword">str</span>&gt; &#123;</span><br><span class="line">	contents.lines()</span><br><span class="line">    	.filter(|line| line.contains(query))</span><br><span class="line">    	.collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-4-Comparing-Performance-Loop-vs-Iterators"><a href="#13-4-Comparing-Performance-Loop-vs-Iterators" class="headerlink" title="13.4 Comparing Performance: Loop vs. Iterators"></a>13.4 Comparing Performance: Loop vs. Iterators</h3><p>The iterator version was slightly faster! The point is this: iterators, although a high-level abstraction, get compiled down to roughly the same code as if you’d written the lower-level code yourself. Iterators are one of Rust’s <em>zero-cost abstractions</em>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// another example</span></span><br><span class="line"><span class="keyword">let</span> buffer: &amp;<span class="keyword">mut</span> [<span class="keyword">i32</span>];</span><br><span class="line"><span class="keyword">let</span> coefficients: [<span class="keyword">i64</span>; <span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> qlp_shift: <span class="keyword">i16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">12</span>..buffer.len() &#123;</span><br><span class="line">    <span class="keyword">let</span> prediction = coefficients.iter()</span><br><span class="line">                                 .zip(&amp;buffer[i - <span class="number">12</span>..i])</span><br><span class="line">                                 .map(|(&amp;c, &amp;s)| c * s <span class="keyword">as</span> <span class="keyword">i64</span>)</span><br><span class="line">                                 .sum::&lt;<span class="keyword">i64</span>&gt;() &gt;&gt; qlp_shift;</span><br><span class="line">    <span class="keyword">let</span> delta = buffer[i];</span><br><span class="line">    buffer[i] = prediction <span class="keyword">as</span> <span class="keyword">i32</span> + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There’s no loop at all corresponding to the iteration over the values in <code>coefficients</code>: Rust knows that there are 12 iterations, so it “unrolls” the loop. <em>Unrolling</em> is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.</p>
<p>You can use iterators and closures without fear! They make code seem like it’s higher level but don’t impose a runtime performance penalty for doing so.</p>
<h2 id="17-Object-Oriented-Programming-Features-of-Rust"><a href="#17-Object-Oriented-Programming-Features-of-Rust" class="headerlink" title="17 Object Oriented Programming Features of Rust"></a>17 Object Oriented Programming Features of Rust</h2><h3 id="17-1-Characteristics-of-Object-Oriented-Languages"><a href="#17-1-Characteristics-of-Object-Oriented-Languages" class="headerlink" title="17-1 Characteristics of Object-Oriented Languages"></a>17-1 Characteristics of Object-Oriented Languages</h3><h4 id="17-1-1-Objects-Contain-Data-and-Behavior"><a href="#17-1-1-Objects-Contain-Data-and-Behavior" class="headerlink" title="17-1-1 Objects Contain Data and Behavior"></a>17-1-1 Objects Contain Data and Behavior</h4><p>Rust is object oriented: structs and enums have data, and <code>impl</code> blocks provide methods on structs and enums.</p>
<h4 id="17-1-2-Encapsulation-that-Hides-Implementation-Details"><a href="#17-1-2-Encapsulation-that-Hides-Implementation-Details" class="headerlink" title="17-1-2 Encapsulation that Hides Implementation Details"></a>17-1-2 Encapsulation that Hides Implementation Details</h4><p>Rust uses the <code>pub</code> keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AveragedCollection</span></span> &#123;</span><br><span class="line">    list: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;,</span><br><span class="line">    average: <span class="keyword">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The struct is marked <code>pub</code> so that other code can use it, but the fields within the struct remain private. </p>
<p>This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing <code>add</code>, <code>remove</code>, and <code>average</code> methods on the struct.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">imple AveragedCollection &#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">i32</span>) &#123;</span><br><span class="line">    	<span class="keyword">self</span>.list.push(value);</span><br><span class="line">        <span class="keyword">self</span>.update_average();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="keyword">i32</span>&gt; &#123;</span><br><span class="line">    	<span class="keyword">let</span> result = <span class="keyword">self</span>.list.pop();</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">        	<span class="literal">Some</span>(value) =&gt; &#123;</span><br><span class="line">            	<span class="keyword">self</span>.update_average();</span><br><span class="line">                <span class="literal">Some</span>(value);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">average</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">f64</span> &#123;</span><br><span class="line">    	<span class="keyword">self</span>.average</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">update_average</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    	<span class="keyword">let</span> total: <span class="keyword">i32</span> = <span class="keyword">self</span>.list.iter().sum();</span><br><span class="line">        <span class="keyword">self</span>.average = total <span class="keyword">as</span> <span class="keyword">f64</span> / <span class="keyword">self</span>.list.len() <span class="keyword">as</span> <span class="keyword">f64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The public methods <code>add</code>, <code>remove</code>, and <code>average</code> are the only ways to access or modify data in an instance of <code>AveragedCollection</code>. </p>
<p>We leave the <code>list</code> and <code>average</code> fields private so there is no way for external code to add or remove items to the <code>list</code> field directly; otherwise, the <code>average</code> field might become out of sync when the <code>list</code> changes. The <code>average</code> method returns the value in the <code>average</code> field, allowing external code to read the <code>average</code> but not modify it.</p>
<h4 id="17-1-3-Inheritance-as-a-Type-System-and-as-Code-Sharing"><a href="#17-1-3-Inheritance-as-a-Type-System-and-as-Code-Sharing" class="headerlink" title="17-1-3 Inheritance as a Type System and as Code Sharing"></a>17-1-3 Inheritance as a Type System and as Code Sharing</h4><p>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct’s fields and method implementations. However you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</p>
<p>You choose inheritance for two main reasons. </p>
<ul>
<li>One is for reuse of code: you can implement particular behavior for one type, and inheritance enables you to reuse that implementation for a different type. You can share Rust code using default trait method implementations instead.</li>
<li>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called <em>polymorphism</em>, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics. Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called <em>bounded parametric polymorphism</em>.</li>
</ul>
<h3 id="17-2-Using-Trait-Objects-That-Allows-for-Values-of-Different-Types"><a href="#17-2-Using-Trait-Objects-That-Allows-for-Values-of-Different-Types" class="headerlink" title="17-2 Using Trait Objects That Allows for Values of Different Types"></a>17-2 Using Trait Objects That Allows for Values of Different Types</h3><p>We could define an enum that had variants to hold different types, so a vector could store different types of data in each cell.</p>
<p>The case: In a language with inheritance, we might define a class named <code>Component</code> that has a method named <code>draw</code> on it. The other classes, such as <code>Button</code>, <code>Image</code>, and <code>SelectBox</code>, would inherit from <code>Component</code> and thus inherit the <code>draw</code> method. They could each override the <code>draw</code> method to define their custom behavior, but the framework could treat all of the types as if they were <code>Component</code> instances and call <code>draw</code> on them. </p>
<h4 id="17-2-1-Defining-a-Trait-for-Common-Behavior"><a href="#17-2-1-Defining-a-Trait-for-Common-Behavior" class="headerlink" title="17-2-1 Defining a Trait for Common Behavior"></a>17-2-1 Defining a Trait for Common Behavior</h4><p>Trait objects <em>are</em> more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can’t add data to a trait object. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Draw</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Next, this vector is of type <code>Box</code>, which is a trait object; it’s a stand-in for any type inside a <code>Box</code> that implements the <code>Draw</code> trait.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Screen &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This works differently from defining a struct that uses a generic type parameter with trait bounds. <strong>A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime.</strong> For example, we could have defined the <code>Screen</code> struct using a generic type and a trait bound.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span>&lt;T: Draw&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Draw &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of type <code>Button</code> or all of type <code>TextField</code>. If you’ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</p>
<p>On the other hand, with the method using trait objects, one <code>Screen</code> instance can hold a <code>Vec</code> that contains a <code>Box&lt;Button&gt;</code> as well as a <code>Box&lt;TextField&gt;</code>. </p>
<h4 id="17-2-2-Implementing-the-Trait"><a href="#17-2-2-Implementing-the-Trait" class="headerlink" title="17-2-2 Implementing the Trait"></a>17-2-2 Implementing the Trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Button</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="keyword">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="keyword">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> Button &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a button</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::Draw;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelectBox</span></span> &#123;</span><br><span class="line">    width: <span class="keyword">u32</span>,</span><br><span class="line">    height: <span class="keyword">u32</span>,</span><br><span class="line">    options: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> SelectBox &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a select box</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Our library’s user can now write their <code>main</code> function to create a <code>Screen</code> instance. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::&#123;Screen, Button&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> screen = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">Box</span>::new(SelectBox &#123;</span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Yes"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Maybe"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"No"</span>)</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="built_in">Box</span>::new(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="built_in">String</span>::from(<span class="string">"OK"</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/gui" target="_blank" rel="noopener">here</a>.</p>
<p>When we wrote the library, we didn’t know that someone might add the <code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> trait, which means it implements the <code>draw</code> method.</p>
<p>This concept—of being concerned only with the messages a value responds to rather than the value’s concrete type—is similar to the concept <em>duck typing</em> in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code>, <code>run</code> doesn’t need to know what the concrete type of each component is. It doesn’t check whether a component is an instance of a <code>Button</code> or a <code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By specifying <code>Box</code> as the type of the values in the <code>components</code> vector, we’ve defined <code>Screen</code> to need values that we can call the <code>draw</code> method on.</p>
<p>The advantage of using trait objects and Rust’s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn’t implement a method but we call it anyway. </p>
<h4 id="17-2-3-Trait-Objects-Perform-Dynamic-Dispatch"><a href="#17-2-3-Trait-Objects-Perform-Dynamic-Dispatch" class="headerlink" title="17-2-3 Trait Objects Perform Dynamic Dispatch"></a>17-2-3 Trait Objects Perform Dynamic Dispatch</h4><p>When we use trait objects, Rust must use dynamic dispatch. </p>
<ul>
<li>The compiler doesn’t know all the types that might be used with the code that is using trait objects, so it doesn’t know which method implemented on which type to call. </li>
<li>Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn’t occur with static dispatch. </li>
<li>Dynamic dispatch also prevents the compiler from choosing to inline a method’s code, which in turn prevents some optimizations. </li>
</ul>
<h4 id="17-2-4-Object-Safety-Is-Required-for-Trait-Objects"><a href="#17-2-4-Object-Safety-Is-Required-for-Trait-Objects" class="headerlink" title="17-2-4 Object Safety Is Required for Trait Objects"></a>17-2-4 Object Safety Is Required for Trait Objects</h4><p>You can only make <em>object-safe</em> traits into trait objects. A trait is object safe if all the methods defined in the trait have the following properties:</p>
<ul>
<li>The return type isn’t <code>Self</code></li>
<li>There are no generic type parameters</li>
</ul>
<p>Trait objects must be object safe because once you’ve used a trait object, Rust no longer knows the concrete type that’s implementing that trait. </p>
<ul>
<li>If a trait method returns the concrete <code>Self</code> type, but a trait object forgets the exact type that <code>Self</code> is, there is no way the method can use the original concrete type. </li>
<li>The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;dyn <span class="built_in">Clone</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0038]: the trait `std::clone::Clone` cannot be made into an object</span></span><br></pre></td></tr></table></figure>
<p>This error means you can’t use this trait as a trait object in this way. </p>
<h3 id="17-3-Implementing-an-Object-Oriented-Design-Pattern"><a href="#17-3-Implementing-an-Object-Oriented-Design-Pattern" class="headerlink" title="17-3 Implementing an Object-Oriented Design Pattern"></a>17-3 Implementing an Object-Oriented Design Pattern</h3><p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of <em>state objects</em>, and the value’s behavior changes based on the internal state. </p>
<p>We’ll implement a blog post workflow in an incremental way. The blog’s final functionality will look like this:</p>
<ol>
<li>A blog post starts as an empty draft.</li>
<li>When the draft is done, a review of the post is requested.</li>
<li>When the post is approved, it gets published.</li>
<li>Only published blog posts return content to print, so unapproved posts can’t accidentally be published.</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog::Post;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> post = Post::new();</span><br><span class="line"></span><br><span class="line">    post.add_text(<span class="string">"I ate a salad for lunch today"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">""</span>, post.content());</span><br><span class="line"></span><br><span class="line">    post.request_review();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">""</span>, post.content());</span><br><span class="line"></span><br><span class="line">    post.approve();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">"I ate a salad for lunch today"</span>, post.content());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice that the only type we’re interacting with from the crate is the <code>Post</code> type. </p>
<ul>
<li>This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in—draft, waiting for review, or published. </li>
<li>Changing from one state to another will be managed internally within the <code>Post</code> type. The states change in response to the methods called by our library’s users on the <code>Post</code> instance, but they don’t have to manage the state changes directly. </li>
<li>Also, users can’t make a mistake with the states, like publishing a post before it’s reviewed.</li>
</ul>
<h4 id="17-3-1-Defining-Post-and-Creating-a-New-Instance-in-the-Draft-State"><a href="#17-3-1-Defining-Post-and-Creating-a-New-Instance-in-the-Draft-State" class="headerlink" title="17-3-1 Defining Post and Creating a New Instance in the Draft State"></a>17-3-1 Defining <code>Post</code> and Creating a New Instance in the Draft State</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Post</span></span> &#123;</span><br><span class="line">    state: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;dyn State&gt;&gt;,</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Post &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Post &#123;</span><br><span class="line">        Post &#123;</span><br><span class="line">            state: <span class="literal">Some</span>(<span class="built_in">Box</span>::new(Draft &#123;&#125;)),</span><br><span class="line">            content: <span class="built_in">String</span>::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">State</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Draft</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> Draft &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>State</code> trait defines the behavior shared by different post states, and the <code>Draft</code>, <code>PendingReview</code>, and <code>Published</code> states will all implement the <code>State</code> trait. </p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct. This ensures whenever we create a new instance of <code>Post</code>, it will start out as a draft. Because the <code>state</code> field of <code>Post</code> is private, there is no way to create a <code>Post</code> in any other state!</p>
<h4 id="17-3-2-Storing-the-Text-of-the-Post-Content"><a href="#17-3-2-Storing-the-Text-of-the-Post-Content" class="headerlink" title="17-3-2 Storing the Text of the Post Content"></a>17-3-2 Storing the Text of the Post Content</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Post &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_text</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.push_str(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This behavior doesn’t depend on the state the post is in, so it’s not part of the state pattern. </p>
<h4 id="17-3-3-Ensuring-the-Content-of-a-Draft-Post-Is-Empty"><a href="#17-3-3-Ensuring-the-Content-of-a-Draft-Post-Is-Empty" class="headerlink" title="17-3-3 Ensuring the Content of a Draft Post Is Empty"></a>17-3-3 Ensuring the Content of a Draft Post Is Empty</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Post &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="keyword">str</span> &#123;</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Adding a placeholder implementation for the <code>content</code> method on <code>Post</code> that always returns an empty string slice.</p>
<h4 id="17-3-4-Requesting-a-Review-of-the-Post-Changes-Its-State"><a href="#17-3-4-Requesting-a-Review-of-the-Post-Changes-Its-State" class="headerlink" title="17-3-4 Requesting a Review of the Post Changes Its State"></a>17-3-4 Requesting a Review of the Post Changes Its State</h4><p>Add functionality to request a review of a post, which should change its state from <code>Draft</code> to <code>PendingReview</code>. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Post &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(s) = <span class="keyword">self</span>.state.take() &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="literal">Some</span>(s.request_review())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Draft</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> Draft &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt; &#123;</span><br><span class="line">        <span class="built_in">Box</span>::new(PendingReview &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PendingReview</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> PendingReview &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17-3-5-Adding-the-approve-Method-that-Changes-the-Behavior-of-content"><a href="#17-3-5-Adding-the-approve-Method-that-Changes-the-Behavior-of-content" class="headerlink" title="17-3-5 Adding the approve Method that Changes the Behavior of content"></a>17-3-5 Adding the <code>approve</code> Method that Changes the Behavior of <code>content</code></h4><p>It will set <code>state</code> to the value that the current state says it should have when that state is approved.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Post &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(s) = <span class="keyword">self</span>.state.take() &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="literal">Some</span>(s.approve())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Draft</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> Draft &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PendingReview</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> PendingReview &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt; &#123;</span><br><span class="line">        <span class="built_in">Box</span>::new(Published &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Published</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> Published &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;dyn State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because the goal is to keep all these rules inside the structs that implement <code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass the post instance (that is, <code>self</code>) as an argument. Then we return the value that is returned from using the <code>content</code> method on the <code>state</code> value.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Post &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="keyword">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.state.as_ref().unwrap().content(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the value inside the <code>Option</code> rather than ownership of the value. Because <code>state</code> is an <code>&lt;Option&gt;</code>, when we call <code>as_ref</code>, an <code>Option&lt;&amp;Box&gt;</code> is returned. If we didn’t call <code>as_ref</code>, we would get an error because we can’t move <code>state</code> out of the borrowed <code>&amp;self</code> of the function parameter.</p>
<p>We then call the <code>unwrap</code> method, which we know will never panic, because we know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code> value when those methods are done. A <code>None</code> value is never possible, even though the compiler isn’t able to understand that.</p>
<p>At this point, when we call <code>content</code> on the <code>&amp;Box</code>, deref coercion will take effect on the <code>&amp;</code> and the <code>Box</code> so the <code>content</code> method will ultimately be called on the type that implements the <code>State</code> trait. That means we need to add <code>content</code> to the <code>State</code> trait definition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">'a</span> Post) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">str</span> &#123;</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Published</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> Published &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">'a</span> Post) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">str</span> &#123;</span><br><span class="line">        &amp;post.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We add a default implementation for the <code>content</code> method that returns an empty string slice. That means we don’t need to implement <code>content</code> on the <code>Draft</code> and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code> method and return the value in <code>post.content</code>.</p>
<p>Note that we need lifetime annotations on this method. We’re taking a reference to a <code>post</code> as an argument and returning a reference to part of that <code>post</code>, so the lifetime of the returned reference is related to the lifetime of the <code>post</code> argument.</p>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/blog" target="_blank" rel="noopener">here</a>.</p>
<h4 id="17-3-6-Trade-offs-of-the-State-Pattern"><a href="#17-3-6-Trade-offs-of-the-State-Pattern" class="headerlink" title="17-3-6 Trade-offs of the State Pattern"></a>17-3-6 Trade-offs of the State Pattern</h4><p>Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on <code>Post</code> know nothing about the various behaviors. </p>
<p>If we were to create an alternative implementation that didn’t use the state pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or even in the <code>main</code> code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those <code>match</code> expressions would need another arm.</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don’t need <code>match</code> expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</p>
<p>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other.</p>
<p>Another downside is that we’ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the <code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>; however, this would violate object safety, because the trait doesn’t know what the concrete <code>self</code> will be exactly. We want to be able to use <code>State</code> as a trait object, so we need its methods to be object safe.</p>
<h5 id="17-3-6-1-Encoding-States-and-Behavior-as-Types"><a href="#17-3-6-1-Encoding-States-and-Behavior-as-Types" class="headerlink" title="17-3-6-1 Encoding States and Behavior as Types"></a>17-3-6-1 Encoding States and Behavior as Types</h5><p>Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we’ll encode the states into different types. Consequently, Rust’s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> post = Post::new();</span><br><span class="line"></span><br><span class="line">    post.add_text(<span class="string">"I ate a salad for lunch today"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">""</span>, post.content());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead of having a <code>content</code> method on a draft post that returns an empty string, we’ll make it so draft posts don’t have the <code>content</code> method at all. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Post</span></span> &#123;</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DraftPost</span></span> &#123;</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Post &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; DraftPost &#123;</span><br><span class="line">        DraftPost &#123;</span><br><span class="line">            content: <span class="built_in">String</span>::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="keyword">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> DraftPost &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_text</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.push_str(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now the program ensures all posts start as draft posts, and draft posts don’t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</p>
<h5 id="17-3-6-2-Implementing-Transitions-as-Transformations-into-Different-Types"><a href="#17-3-6-2-Implementing-Transitions-as-Transformations-into-Different-Types" class="headerlink" title="17-3-6-2 Implementing Transitions as Transformations into Different Types"></a>17-3-6-2 Implementing Transitions as Transformations into Different Types</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> DraftPost &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>) -&gt; PendingReviewPost &#123;</span><br><span class="line">        PendingReviewPost &#123;</span><br><span class="line">            content: <span class="keyword">self</span>.content,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PendingReviewPost</span></span> &#123;</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PendingReviewPost &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>) -&gt; Post &#123;</span><br><span class="line">        Post &#123;</span><br><span class="line">            content: <span class="keyword">self</span>.content,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this implementation doesn’t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the <code>Post</code> implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> blog::Post;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> post = Post::new();</span><br><span class="line"></span><br><span class="line">    post.add_text(<span class="string">"I ate a salad for lunch today"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> post = post.request_review();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> post = post.approve();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">"I ate a salad for lunch today"</span>, post.content());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/blog2" target="_blank" rel="noopener">here</a>.</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/03/Rust/RPL/2020-01-21-RPL-Brief-Note-Vol3-Style/">
    <time datetime="2019-12-03T04:00:00.000Z" class="entry-date">
        2019-12-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/">Rust</a></li></ul>

    </footer>
</article>





  
    <article id="post-Rust/RPL/2019-12-31-RPL-Brief-Note-Vol5-Project" class="post-Rust/RPL/2019-12-31-RPL-Brief-Note-Vol5-Project post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol5-Project/">The Rust Programming Language Brief Note (Vol3-Project)</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol5-Project/" data-id="ckplazpe20007z2bz9vh5qwyf" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
            <!-- Table of Contents -->
              
        <h2 id="2-Programming-Guess"><a href="#2-Programming-Guess" class="headerlink" title="2 Programming Guess"></a>2 Programming Guess</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>; <span class="comment">// immutable </span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bar = <span class="number">5</span>; <span class="comment">// mutable</span></span><br><span class="line"></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess) </span><br><span class="line">    .expect(<span class="string">"Failed to read line"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> guess: <span class="keyword">u32</span> = guess.trim().parse()</span><br><span class="line">	.expect(<span class="string">"input a number"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> guess: <span class="keyword">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">     <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">     <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> guess.cmp(&amp;secret_number) &#123; </span><br><span class="line">     Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"Too small!"</span>), </span><br><span class="line">     Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"Too big!"</span>), </span><br><span class="line">     Ordering::Equal =&gt; &#123;</span><br><span class="line">     	<span class="built_in">println!</span>(<span class="string">"You win!"</span>);</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc --open // documents</span><br></pre></td></tr></table></figure>
<p><code>let mut guess = String::new();</code> line has created a mutable variable that is currently bound to a new, empty instance of a String.</p>
<p><code>io::stdin().read_line(&amp;mut guess)</code> reference, just like C pointer;</p>
<p><code>.expect(&#39;something);</code> <code>read_line</code> method return a Result type, The Result types are enumerations, often referred to as enums.  just like C enum to haddle errors. It’s also a callback.</p>
<p>Remember that a <code>crate</code> is a collection of Rust source code files. The project we’ve been building is a binary crate, which is an executable. The rand crate is a library crate, which contains code intended to be used in other programs.</p>
<p>A <code>match</code> expression is made up of arms. An <em>arm</em> consists of a <em>pattern</em> and the code that should be run if the value given to the beginning of the <code>match</code> expression fits that arm’s pattern. </p>
<p>Rust allows us to <em>shadow</em> the previous value of <code>guess</code> with a new one. This feature is often used in situations in which you want to convert a value from one type to another type.</p>
<p>We bind <code>guess</code> to the expression <code>guess.trim().parse()</code>. The <code>guess</code> in the expression refers to the original <code>guess</code> that was a <code>String</code> with the input in it. The <code>trim</code> method on a <code>String</code> instance will eliminate any whitespace at the beginning and end. Although <code>u32</code> can contain only numerical characters, the user must press enter to satisfy <code>read_line</code>. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents “newline,” the result of pressing enter. The <code>trim</code> method eliminates <code>\n</code>, resulting in just <code>5</code>.</p>
<p>The colon (<code>:</code>) after <code>guess</code> tells Rust we’ll annotate the variable’s type.</p>
<p>Switching from an <code>expect</code> call to a <code>match</code> expression is how you generally move from crashing on an error to handling the error. Remember that <code>parse</code> returns a <code>Result</code> type and <code>Result</code> is an enum that has the variants <code>Ok</code> or <code>Err</code>. We’re using a <code>match</code> expression here, as we did with the <code>Ordering</code> result of the <code>cmp</code> method.</p>
<ul>
<li>That <code>Ok</code> value will match the first arm’s pattern, and the <code>match</code> expression will just return the <code>num</code> value that <code>parse</code> produced and put inside the <code>Ok</code> value. </li>
<li>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an <code>Err</code> value that contains more information about the error. The <code>Err</code> value does not match the <code>Ok(num)</code> pattern in the first <code>match</code>arm, but it does match the <code>Err(_)</code> pattern in the second arm. </li>
</ul>
<h2 id="12-An-I-O-Project-Building-a-Command-Line-Program"><a href="#12-An-I-O-Project-Building-a-Command-Line-Program" class="headerlink" title="12 An I/O Project: Building a Command Line Program"></a>12 An I/O Project: Building a Command Line Program</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// collect is one function you do often need to annotate because Rust isn’t able to infer the kind of collection you want</span></span><br><span class="line">    <span class="comment">// immediately use collect to turn the iterator into a vector containing all the values produced by the iterator</span></span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">    	.expect(<span class="string">"wrong reading file..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cargo run test text</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>std::env::args</code> returns an iterator that produces <code>String</code> values</p>
</li>
<li><p><code>std::env::args_os</code> returns an iterator that produces <code>OsString</code> values</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extracting the Argument Parser</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line">    <span class="keyword">let</span> (query, filename) = parse_config(&amp;args);</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">    	.expect(<span class="string">"wrong reading file..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_config</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; (&amp;<span class="keyword">str</span>, &amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line">    (query, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s okay to use <code>clone</code> to copy a few strings to continue making progress.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grouping Configuration Values</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line">    <span class="keyword">let</span> config = parse_config(&amp;args);</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">    	.expect(<span class="string">"wrong reading file..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">	query: <span class="built_in">String</span>,</span><br><span class="line">    filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_config</span></span>(&amp;args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">	<span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">    <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line">    Config &#123;query, filename&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>parse_config</code> function is to create a <code>Config</code> instance, we can change <code>parse_config</code> from a plain function to a function named <code>new</code> that is associated with the <code>Config</code> struct. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creating a Constructor for Config</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args);</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">    	.expect(<span class="string">"wrong reading file..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">	query: <span class="built_in">String</span>,</span><br><span class="line">    filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(&amp;args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">    	<span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">        <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line">        Config &#123;query, filename&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Improving the Error Message</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(&amp;args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">	<span class="keyword">if</span> args.len() &lt; <span class="number">3</span> &#123;</span><br><span class="line">    	<span class="built_in">panic!</span>(<span class="string">"not enough arguments);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// USE</span></span><br><span class="line"><span class="comment">// Returning a Result from new Instead of Calling panic!</span></span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="keyword">str</span>&gt; &#123;</span><br><span class="line">    	<span class="keyword">if</span> args.len() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">Err</span>(<span class="string">"not enough arguments"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">        <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line">        <span class="literal">Ok</span>(Config &#123; query, filename&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// USE</span></span><br><span class="line"><span class="comment">// Calling Config::new and Handling Errors</span></span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line">    <span class="comment">// Using unwrap_or_else allows us to define some custom, non-panic! error handling.</span></span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args).unwrap_or_else(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Problem parsing arguments: &#123;&#125;"</span>, err);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extracting Logic from main</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="comment">// --snip--</span></span><br><span class="line">    run(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) &#123;</span><br><span class="line">	<span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">    	.expect(<span class="string">"wrong reading file..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// USE</span></span><br><span class="line"><span class="comment">// Returning Errors from the run Function</span></span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// removed the call to expect in favor of ? rather than panic! on an error,</span></span><br><span class="line">    <span class="comment">// ? will return the error value from the current function for the caller to handle.</span></span><br><span class="line">	<span class="keyword">let</span> contents = fs::read_to_string(config.filename)?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// USE</span></span><br><span class="line"><span class="comment">// Handling Errors Returned from run in main</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = run(config) &#123;</span><br><span class="line">    	<span class="built_in">println!</span>(<span class="string">"App error: &#123;&#125;"</span>, e);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// USE</span></span><br><span class="line"><span class="comment">// Spliting Code into a Library Crate</span></span><br><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> query: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="keyword">str</span>&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> minigrep;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> len <span class="literal">Err</span>(e) = minigrep::run(config) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Test-Driven<ul>
<li>Write a test that fails and run it to make sure it fails for the reason you expect.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed and make sure the tests continue to pass.</li>
<li>Repeat from step 1!</li>
</ul>
</li>
</ul>
<p>The whole code can be found here: <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/minigrep" target="_blank" rel="noopener">Coding-Collections/Rust/minigrep</a>.</p>
<h2 id="20-Final-Project-Building-a-Multithreaded-Web-Server"><a href="#20-Final-Project-Building-a-Multithreaded-Web-Server" class="headerlink" title="20 Final Project, Building a Multithreaded Web Server"></a>20 Final Project, Building a Multithreaded Web Server</h2><h3 id="20-1-Building-a-Single-Threaded-Web-Server"><a href="#20-1-Building-a-Single-Threaded-Web-Server" class="headerlink" title="20-1 Building a Single-Threaded Web Server"></a>20-1 Building a Single-Threaded Web Server</h3><p>Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages.</p>
<h4 id="20-1-1-Listening-to-the-Tcp-Connection"><a href="#20-1-1-Listening-to-the-Tcp-Connection" class="headerlink" title="20-1-1 Listening to the Tcp Connection"></a>20-1-1 Listening to the Tcp Connection</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">"127.0.0.1:7878"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming() &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = stream.unwrap();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Connection established!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it will return a new <code>TcpListener</code> instance. he <code>bind</code> function returns a <code>Result</code>, which indicates that binding might fail. </p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single <em>stream</em> represents an open connection between the client and the server. A <em>connection</em> is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, <code>TcpStream</code> will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this <code>for</code> loop will process each connection in turn and produce a series of streams for us to handle.</p>
<p><code>unwrap</code> terminate our program if the stream has any errors. The reason we might receive errors from the <code>incoming</code> method when a client connects to the server is that we’re not actually iterating over connections. Instead, we’re iterating over <em>connection attempts</em>. The connection might not be successful for a number of reasons, many of them operating system specific.</p>
<h4 id="20-1-2-Reading-the-Request"><a href="#20-1-2-Reading-the-Request" class="headerlink" title="20-1-2 Reading the Request"></a>20-1-2 Reading the Request</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">"127.0.0.1:7878"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming() &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = stream.unwrap();</span><br><span class="line"></span><br><span class="line">        handle_connection(stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_connection</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Request: &#123;&#125;"</span>, <span class="built_in">String</span>::from_utf8_lossy(&amp;buffer[..]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the <code>handle_connection</code> function, we’ve made the <code>stream</code> parameter mutable. The reason is that the <code>TcpStream</code> instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. </p>
<p><code>stream.read</code> will read bytes from the <code>TcpStream</code> and put them in the buffer. <code>String::from_utf8_lossy</code> function takes a <code>&amp;[u8]</code> and produces a <code>String</code> from it. The “lossy” part of the name indicates the behavior of this function when it sees an invalid UTF-8 sequence: it will replace the invalid sequence with <code>�</code>, the <code>U+FFFD REPLACEMENT CHARACTER</code>.</p>
<h4 id="20-1-3-Writing-a-Response"><a href="#20-1-3-Writing-a-Response" class="headerlink" title="20-1-3 Writing a Response"></a>20-1-3 Writing a Response</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_connection</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> response = <span class="string">"HTTP/1.1 200 OK\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    stream.write(response.as_bytes()).unwrap();</span><br><span class="line">    stream.flush().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>write</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends those bytes directly down the connection. Because the <code>write</code> operation could fail, we use <code>unwrap</code> on any error result as before. Again, in a real application you would add error handling here. </p>
<p><code>flush</code> will wait and prevent the program from continuing until all the bytes are written to the connection; <code>TcpStream</code> contains an internal buffer to minimize calls to the underlying operating system.</p>
<h4 id="20-1-4-Returning-Real-HTML"><a href="#20-1-4-Returning-Real-HTML" class="headerlink" title="20-1-4 Returning Real HTML"></a>20-1-4 Returning Real HTML</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_connection</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(<span class="string">"hello.html"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> response = <span class="built_in">format!</span>(<span class="string">"HTTP/1.1 200 OK\r\n\r\n&#123;&#125;"</span>, contents);</span><br><span class="line"></span><br><span class="line">    stream.write(response.as_bytes()).unwrap();</span><br><span class="line">    stream.flush().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="20-1-5-Validating-the-Request-and-Selectively-Responding"><a href="#20-1-5-Validating-the-Request-and-Selectively-Responding" class="headerlink" title="20-1-5 Validating the Request and Selectively Responding"></a>20-1-5 Validating the Request and Selectively Responding</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_connection</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> get = <span class="string">b"GET / HTTP/1.1\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> buffer.starts_with(get) &#123;</span><br><span class="line">        <span class="keyword">let</span> contents = fs::read_to_string(<span class="string">"hello.html"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> response = <span class="built_in">format!</span>(<span class="string">"HTTP/1.1 200 OK\r\n\r\n&#123;&#125;"</span>, contents);</span><br><span class="line"></span><br><span class="line">        stream.write(response.as_bytes()).unwrap();</span><br><span class="line">        stream.flush().unwrap();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> status_line = <span class="string">"HTTP/1.1 404 NOT FOUND\r\n\r\n"</span>;</span><br><span class="line">        <span class="keyword">let</span> contents = fs::read_to_string(<span class="string">"404.html"</span>).unwrap();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> response = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;&#123;&#125;"</span>, status_line, contents);</span><br><span class="line">        </span><br><span class="line">        stream.write(response.as_bytes()).unwrap();</span><br><span class="line">        stream.flush().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="20-1-6-A-Touch-of-Refactoring"><a href="#20-1-6-A-Touch-of-Refactoring" class="headerlink" title="20-1-6 A Touch of Refactoring"></a>20-1-6 A Touch of Refactoring</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_connection</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.starts_with(get) &#123;</span><br><span class="line">        (<span class="string">"HTTP/1.1 200 OK\r\n\r\n"</span>, <span class="string">"hello.html"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">"HTTP/1.1 404 NOT FOUND\r\n\r\n"</span>, <span class="string">"404.html"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> response = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;&#123;&#125;"</span>, status_line, contents);</span><br><span class="line"></span><br><span class="line">    stream.write(response.as_bytes()).unwrap();</span><br><span class="line">    stream.flush().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/hellosingle" target="_blank" rel="noopener">here</a>.</p>
<h3 id="20-2-Turning-Our-Single-Threaded-Server-into-a-Multithreaded-Server"><a href="#20-2-Turning-Our-Single-Threaded-Server-into-a-Multithreaded-Server" class="headerlink" title="20-2 Turning Our Single-Threaded Server into a Multithreaded Server"></a>20-2 Turning Our Single-Threaded Server into a Multithreaded Server</h3><h4 id="20-2-1-Simulating-a-Slow-Request-in-the-Current-Server-Implementation"><a href="#20-2-1-Simulating-a-Slow-Request-in-the-Current-Server-Implementation" class="headerlink" title="20-2-1 Simulating a Slow Request in the Current Server Implementation"></a>20-2-1 Simulating a Slow Request in the Current Server Implementation</h4><p>There are multiple ways we could change how our web server works to avoid having more requests back up behind a slow request; the one we’ll implement is a thread pool.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_connection</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> get = <span class="string">b"GET / HTTP/1.1\r\n"</span>;</span><br><span class="line">    <span class="keyword">let</span> sleep = <span class="string">b"GET /sleep HTTP/1.1\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">if</span> buffer.starts_with(get) &#123;</span><br><span class="line">        (<span class="string">"HTTP/1.1 200 OK\r\n\r\n"</span>, <span class="string">"hello.html"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.starts_with(sleep) &#123;</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">5</span>));</span><br><span class="line">        (<span class="string">"HTTP/1.1 200 OK\r\n\r\n"</span>, <span class="string">"hello.html"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">"HTTP/1.1 404 NOT FOUND\r\n\r\n"</span>, <span class="string">"404.html"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="20-2-2-Improving-Throughput-with-a-Thread-Pool"><a href="#20-2-2-Improving-Throughput-with-a-Thread-Pool" class="headerlink" title="20-2-2 Improving Throughput with a Thread Pool"></a>20-2-2 Improving Throughput with a Thread Pool</h4><p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to handle a task. As requests come in, they’ll be sent to the pool for processing. The pool will maintain a queue of incoming requests. Each of the threads in the pool will pop off a request from this queue, handle the request, and then ask the queue for another request.</p>
<p>When you’re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it’s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</p>
<p>We’ll use compiler-driven development here. We’ll write the code that calls the functions we want, and then we’ll look at errors from the compiler to determine what we should change next to get the code to work.</p>
<h5 id="20-2-2-1-Code-Structure-If-We-Could-Spawn-a-Thread-for-Each-Request"><a href="#20-2-2-1-Code-Structure-If-We-Could-Spawn-a-Thread-for-Each-Request" class="headerlink" title="20-2-2-1 Code Structure If We Could Spawn a Thread for Each Request"></a>20-2-2-1 Code Structure If We Could Spawn a Thread for Each Request</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">"127.0.0.1:7878"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming() &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = stream.unwrap();</span><br><span class="line"></span><br><span class="line">        thread::spawn(|| &#123;</span><br><span class="line">            handle_connection(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread::spawn</code> will create a new thread and then run the code in the closure in the new thread.</p>
<h5 id="20-2-2-2-Creating-a-Similar-Interface-for-a-Finite-Number-of-Threads"><a href="#20-2-2-2-Creating-a-Similar-Interface-for-a-Finite-Number-of-Threads" class="headerlink" title="20-2-2-2 Creating a Similar Interface for a Finite Number of Threads"></a>20-2-2-2 Creating a Similar Interface for a Finite Number of Threads</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/bin/main.rs</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">"127.0.0.1:7878"</span>).unwrap();</span><br><span class="line">    <span class="keyword">let</span> pool = ThreadPool::new(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming() &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = stream.unwrap();</span><br><span class="line"></span><br><span class="line">        pool.execute(|| &#123;</span><br><span class="line">            handle_connection(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We need to implement <code>pool.execute</code> so it takes the closure and gives it to a thread in the pool to run. This code won’t yet compile, but we’ll try so the compiler can guide us in how to fix it.</p>
<h5 id="20-2-2-3-Building-the-ThreadPool-Struct-Using-Compiler-Driven-Development"><a href="#20-2-2-3-Building-the-ThreadPool-Struct-Using-Compiler-Driven-Development" class="headerlink" title="20-2-2-3 Building the ThreadPool Struct Using Compiler Driven Development"></a>20-2-2-3 Building the <code>ThreadPool</code> Struct Using Compiler Driven Development</h5><p><code>cargo check</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        ThreadPool</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// from thread::spawn, because we want a similar function</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">execute</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">        <span class="keyword">where</span></span><br><span class="line">            F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="20-2-2-4-Validating-the-Number-of-Threads-in-new"><a href="#20-2-2-4-Validating-the-Number-of-Threads-in-new" class="headerlink" title="20-2-2-4 Validating the Number of Threads in new"></a>20-2-2-4 Validating the Number of Threads in <code>new</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">/// Create a new ThreadPool.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// The size is the number of threads in the pool.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// The `new` function will panic if the size is zero.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ThreadPool</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; <span class="built_in">Result</span>&lt;ThreadPool, PoolCreationError&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="20-2-2-5-Creating-Space-to-Store-the-Threads"><a href="#20-2-2-5-Creating-Space-to-Store-the-Threads" class="headerlink" title="20-2-2-5 Creating Space to Store the Threads"></a>20-2-2-5 Creating Space to Store the Threads</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span> &#123;</span><br><span class="line">    <span class="comment">// from thread::spawn, returns JoinHandle&lt;T&gt;</span></span><br><span class="line">    threads: <span class="built_in">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> threads = <span class="built_in">Vec</span>::with_capacity(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            <span class="comment">// create some threads and store them in the vector</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            threads</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ve brought <code>std::thread</code> into scope in the library crate, because we’re using <code>thread::JoinHandle</code> as the type of the items in the vector in <code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can hold <code>size</code> items. <code>with_capacity</code>  performs the same task as <code>Vec::new</code> but with an important difference: it preallocates space in the vector. Because we know we need to store <code>size</code> elements in the vector, doing this allocation up front is slightly more efficient than using <code>Vec::new</code>, which resizes itself as elements are inserted.</p>
<h5 id="20-2-2-6-A-Worker-Struct-Responsible-for-Sending-Code-from-the-ThreadPool-to-a-Thread"><a href="#20-2-2-6-A-Worker-Struct-Responsible-for-Sending-Code-from-the-ThreadPool-to-a-Thread" class="headerlink" title="20-2-2-6 A Worker Struct Responsible for Sending Code from the ThreadPool to a Thread"></a>20-2-2-6 A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</h5><p>The standard library provides <code>thread::spawn</code> as a way to create threads, and <code>thread::spawn</code> expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them <em>wait</em> for code that we’ll send later. </p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool, we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single <code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will take a closure of code to run and send it to the already running thread for execution. We’ll also give each worker an <code>id</code> so we can distinguish between the different workers in the pool when logging or debugging.</p>
<p>When we create a <code>ThreadPool</code> we’ll implement the code that sends the closure to the thread after we have <code>Worker</code> set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a <code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span> &#123;</span><br><span class="line">    workers: <span class="built_in">Vec</span>&lt;Worker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::with_capacity(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.push(Worker::new(id));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            workers</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span></span> &#123;</span><br><span class="line">    id: <span class="keyword">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>) -&gt; Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> thread = thread::spawn(|| &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="20-2-2-7-Sending-Requests-to-Threads-via-Channels"><a href="#20-2-2-7-Sending-Requests-to-Threads-via-Channels" class="headerlink" title="20-2-2-7 Sending Requests to Threads via Channels"></a>20-2-2-7 Sending Requests to Threads via Channels</h5><p>Currently, we get the closure we want to execute in the <code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch code to run from a queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>We’ll use a channel to function as the queue of jobs, and <code>execute</code> will send a job from the <code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its thread. Here is the plan:</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sending side of the channel.</li>
<li>Each <code>Worker</code> will hold on to the receiving side of the channel.</li>
<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute down the sending side of the channel.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiving side of the channel and execute the closures of any jobs it receives.</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span> &#123;</span><br><span class="line">    workers: <span class="built_in">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::with_capacity(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.push(Worker::new(id));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            workers,</span><br><span class="line">            sender,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the sending end. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::with_capacity(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.push(Worker::new(id, receiver));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            workers,</span><br><span class="line">            sender,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> thread = thread::spawn(|| &#123;</span><br><span class="line">            receiver;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We pass the receiving end of the channel into <code>Worker::new</code>, and then we use it inside the closure.</p>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This won’t work, as you’ll recall from Chapter 16: the channel implementation that Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single <code>receiver</code> among all the workers.</p>
<p>Additionally, taking a job off the channel queue involves mutating the <code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>; otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>To share ownership across multiple threads and allow the threads to mutate the value, we need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple workers own the receiver, and <code>Mutex</code> will ensure that only one worker gets a job from the receiver at a time. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(size: <span class="keyword">usize</span>) -&gt; ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> receiver = Arc::new(Mutex::new(receiver));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::with_capacity(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            workers,</span><br><span class="line">            sender,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We put the receiving end of the channel in an <code>Arc</code> and a <code>Mutex</code>. For each new worker, we clone the <code>Arc</code> to bump the reference count so the workers can share ownership of the receiving end.</p>
<h5 id="20-2-2-8-Implementing-the-execute-Method"><a href="#20-2-2-8-Implementing-the-execute-Method" class="headerlink" title="20-2-2-8 Implementing the execute Method"></a>20-2-2-8 Implementing the <code>execute</code> Method</h5><p>We’ll change <code>Job</code> from a struct to a type alias for a trait object that holds the type of closure that <code>execute</code> receives. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Job</span></span> = <span class="built_in">Box</span>&lt;dyn <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">execute</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">        <span class="keyword">where</span></span><br><span class="line">            F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> job = <span class="built_in">Box</span>::new(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.sender.send(job).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we send that job down the sending end of the channel. We’re calling <code>unwrap</code> on <code>send</code> for the case that sending fails. The reason we use <code>unwrap</code> is that we know the failure case won’t happen, but the compiler doesn’t know that.</p>
<p>Now we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> thread = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> job = receiver.lock().unwrap().recv().unwrap();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Worker &#123;&#125; got a job; executing."</span>, id);</span><br><span class="line"></span><br><span class="line">                (*job)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex is in a <em>poisoned</em> state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling <code>unwrap</code> to have this thread panic is the correct action to take. </p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the channel. A final <code>unwrap</code> moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the <code>send</code> method returns <code>Err</code> if the receiving side shuts down.</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will wait until a job becomes available. The <code>Mutex</code> ensures that only one <code>Worker</code> thread at a time is trying to request a job.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0161]: cannot move a value of <span class="built_in">type</span> std::ops::FnOnce() +</span><br><span class="line">std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be</span><br><span class="line">statically determined</span><br><span class="line">  --&gt; src/lib.rs:63:17</span><br><span class="line">   |</span><br><span class="line">63 |                 (*job)();</span><br><span class="line">   |                 ^^^^^^</span><br></pre></td></tr></table></figure>
<p>This error is fairly cryptic because the problem is fairly cryptic. To call a <code>FnOnce</code> closure that is stored in a <code>Box</code> (which is what our <code>Job</code> type alias is), the closure needs to move itself <em>out</em> of the <code>Box</code> because the closure takes ownership of <code>self</code> when we call it. In general, Rust doesn’t allow us to move a value out of a <code>Box</code> because Rust doesn’t know how big the value inside the <code>Box</code> will be: recall in Chapter 15 that we used <code>Box</code> precisely because we had something of an unknown size that we wanted to store in a <code>Box</code> to get a value of a known size.</p>
<p>We can write methods that use the syntax <code>self: Box</code>, which allows the method to take ownership of a <code>Self</code> value stored in a <code>Box</code>. That’s exactly what we want to do here, but unfortunately Rust won’t let us: the part of Rust that implements behavior when a closure is called isn’t implemented using <code>self: Box</code>. So Rust doesn’t yet understand that it could use <code>self: Box</code> in this situation to take ownership of the closure and move the closure out of the <code>Box</code>.</p>
<p>We can tell Rust explicitly that in this case we can take ownership of the value inside the <code>Box</code> using <code>self: Box</code>; then, once we have ownership of the closure, we can call it. This involves defining a new trait <code>FnBox</code> with the method <code>call_box</code> that will use <code>self: Box</code> in its signature, defining <code>FnBox</code> for any type that implements <code>FnOnce()</code>, changing our type alias to use the new trait, and changing <code>Worker</code> to use the <code>call_box</code> method. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">FnBox</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call_box</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="built_in">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> F &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call_box</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;F&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Job</span></span> = <span class="built_in">Box</span>&lt;dyn FnBox + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> thread = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> job = receiver.lock().unwrap().recv().unwrap();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Worker &#123;&#125; got a job; executing."</span>, id);</span><br><span class="line"></span><br><span class="line">                job.call_box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First, we create a new trait named <code>FnBox</code>. This trait has the one method <code>call_box</code>, which is similar to the <code>call</code> methods on the other <code>Fn*</code> traits except that it takes <code>self: Box</code> to take ownership of <code>self</code> and move the value out of the <code>Box</code>.</p>
<p>Next, we implement the <code>FnBox</code> trait for any type <code>F</code> that implements the <code>FnOnce()</code> trait. Effectively, this means that any <code>FnOnce()</code> closures can use our <code>call_box</code> method. The implementation of <code>call_box</code> uses <code>(*self)()</code> to move the closure out of the <code>Box</code> and call the closure.</p>
<p>We now need our <code>Job</code> type alias to be a <code>Box</code> of anything that implements our new trait <code>FnBox</code>. This will allow us to use <code>call_box</code> in <code>Worker</code> when we get a <code>Job</code> value instead of invoking the closure directly. Implementing the <code>FnBox</code> trait for any <code>FnOnce()</code> closure means we don’t have to change anything about the actual values we’re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</p>
<blockquote>
<p>Note: if you open <em>/sleep</em> in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> thread = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(job) = receiver.lock().unwrap().recv() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Worker &#123;&#125; got a job; executing."</span>, id);</span><br><span class="line"></span><br><span class="line">                job.call_box();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code compiles and runs but doesn’t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. </p>
<p>The reason is somewhat subtle: the <code>Mutex</code> struct has no public <code>unlock</code> method because the ownership of the lock is based on the lifetime of the <code>MutexGuard</code> within the <code>LockResult&gt;</code> that the <code>lock</code> method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don’t think carefully about the lifetime of the <code>MutexGuard</code>. Because the values in the <code>while</code> expression remain in scope for the duration of the block, the lock remains held for the duration of the call to <code>job.call_box()</code>, meaning other workers cannot receive jobs.</p>
<p>By using <code>loop</code> instead and acquiring the lock and a job within the block rather than outside it, the <code>MutexGuard</code> returned from the <code>lock</code> method is dropped as soon as the <code>let job</code> statement ends. This ensures that the lock is held during the call to <code>recv</code>, but it is released before the call to <code>job.call_box()</code>, allowing multiple requests to be serviced concurrently.</p>
<h3 id="20-3-Graceful-Shutdown-and-Cleanup"><a href="#20-3-Graceful-Shutdown-and-Cleanup" class="headerlink" title="20-3 Graceful Shutdown and Cleanup"></a>20-3 Graceful Shutdown and Cleanup</h3><p>Now we’ll implement the <code>Drop</code> trait to call <code>join</code> on each of the threads in the pool so they can finish the requests they’re working on before closing. Then we’ll implement a way to tell the threads they should stop accepting new requests and shut down. </p>
<h4 id="20-3-1-Implementing-the-Drop-Trait-on-ThreadPool"><a href="#20-3-1-Implementing-the-Drop-Trait-on-ThreadPool" class="headerlink" title="20-3-1 Implementing the Drop Trait on ThreadPool"></a>20-3-1 Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></h4><p>When the pool is dropped, our threads should all join to make sure they finish their work. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> ThreadPool &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> worker <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Shutting down worker &#123;&#125;"</span>, worker.id);</span><br><span class="line"></span><br><span class="line">            worker.thread.join().unwrap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The error tells us we can’t call <code>join</code> because we only have a mutable borrow of each <code>worker</code> and <code>join</code> takes ownership of its argument. To solve this issue, we need to move the thread out of the <code>Worker</code> instance that owns <code>thread</code> so <code>join</code> can consume the thread. </p>
<p>A <code>Worker</code> that is running will have a <code>Some</code> variant in <code>thread</code>, and when we want to clean up a <code>Worker</code>, we’ll replace <code>Some</code> with <code>None</code> so the <code>Worker</code> doesn’t have a thread to run.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span></span> &#123;</span><br><span class="line">    id: <span class="keyword">usize</span>,</span><br><span class="line">    thread: <span class="built_in">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We need to wrap the <code>thread</code> value in <code>Some</code> when we create a new <code>Worker</code>. We mentioned earlier that we intended to call <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread: <span class="literal">Some</span>(thread),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> ThreadPool &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> worker <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Shutting down worker &#123;&#125;"</span>, worker.id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(thread) = worker.thread.take() &#123;</span><br><span class="line">                thread.join().unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>take</code> method on <code>Option</code> takes the <code>Some</code> variant out and leaves <code>None</code> in its place. We’re using <code>if let</code> to destructure the <code>Some</code> and get the thread; then we call <code>join</code> on the thread. If a worker’s thread is already <code>None</code>, we know that worker has already had its thread cleaned up, so nothing happens in that case.</p>
<h4 id="20-3-2-Signaling-to-the-Threads-to-Stop-Listening-for-Jobs"><a href="#20-3-2-Signaling-to-the-Threads-to-Stop-Listening-for-Jobs" class="headerlink" title="20-3-2 Signaling to the Threads to Stop Listening for Jobs"></a>20-3-2 Signaling to the Threads to Stop Listening for Jobs</h4><p>Now, this code doesn’t function the way we want it to yet. The key is the logic in the closures run by the threads of the <code>Worker</code> instances: at the moment, we call <code>join</code>, but that won’t shut down the threads because they <code>loop</code> forever looking for jobs. If we try to drop our <code>ThreadPool</code> with our current implementation of <code>drop</code>, the main thread will block forever waiting for the first thread to finish.</p>
<p>To fix this problem, we’ll modify the threads so they listen for either a <code>Job</code> to run or a signal that they should stop listening and exit the infinite loop. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    NewJob(Job),</span><br><span class="line">    Terminate,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span> &#123;</span><br><span class="line">    workers: <span class="built_in">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Message&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ThreadPool &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">execute</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">        <span class="keyword">where</span></span><br><span class="line">            F: <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> job = <span class="built_in">Box</span>::new(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.sender.send(Message::NewJob(job)).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Worker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(id: <span class="keyword">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;</span><br><span class="line">        Worker &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> thread = thread::spawn(<span class="keyword">move</span> ||&#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> message = receiver.lock().unwrap().recv().unwrap();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">match</span> message &#123;</span><br><span class="line">                    Message::NewJob(job) =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">"Worker &#123;&#125; got a job; executing."</span>, id);</span><br><span class="line"></span><br><span class="line">                        job.call_box();</span><br><span class="line">                    &#125;,</span><br><span class="line">                    Message::Terminate =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">"Worker &#123;&#125; was told to terminate."</span>, id);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread: <span class="literal">Some</span>(thread),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To incorporate the <code>Message</code> enum, we need to change <code>Job</code> to <code>Message</code> in two places: the definition of <code>ThreadPool</code> and the signature of <code>Worker::new</code>. </p>
<p>The <code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped in the <code>Message::NewJob</code> variant. Then, in <code>Worker::new</code> where a <code>Message</code> is received from the channel, the job will be processed if the <code>NewJob</code> variant is received, and the thread will break out of the loop if the <code>Terminate</code> variant is received.</p>
<p>Then create messages of the <code>Terminate</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> ThreadPool &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Sending terminate message to all workers."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="keyword">self</span>.sender.send(Message::Terminate).unwrap();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Shutting down all workers."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> worker <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Shutting down worker &#123;&#125;"</span>, worker.id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(thread) = worker.thread.take() &#123;</span><br><span class="line">                thread.join().unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’re now iterating over the workers twice: once to send one <code>Terminate</code> message for each worker and once to call <code>join</code> on each worker’s thread. If we tried to send a message and <code>join</code> immediately in the same loop, we couldn’t guarantee that the worker in the current iteration would be the one to get the message from the channel.</p>
<p>To prevent Deadlock, we first put all of our <code>Terminate</code> messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before <code>join</code> is called on its thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">"127.0.0.1:7878"</span>).unwrap();</span><br><span class="line">    <span class="keyword">let</span> pool = ThreadPool::new(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming().take(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = stream.unwrap();</span><br><span class="line"></span><br><span class="line">        pool.execute(|| &#123;</span><br><span class="line">            handle_connection(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Shutting down."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration to the first two items at most. The <code>ThreadPool</code> will go out of scope at the end of <code>main</code>, and the <code>drop</code> implementation will run.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling hello v0.1.0 (file:///projects/hello)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 1.0 secs</span><br><span class="line">     Running `target/debug/hello`</span><br><span class="line">Worker 0 got a job; executing.</span><br><span class="line">Worker 3 got a job; executing.</span><br><span class="line">Shutting down.</span><br><span class="line">Sending terminate message to all workers.</span><br><span class="line">Shutting down all workers.</span><br><span class="line">Shutting down worker 0</span><br><span class="line">Worker 1 was told to terminate.</span><br><span class="line">Worker 2 was told to terminate.</span><br><span class="line">Worker 0 was told to terminate.</span><br><span class="line">Worker 3 was told to terminate.</span><br><span class="line">Shutting down worker 1</span><br><span class="line">Shutting down worker 2</span><br><span class="line">Shutting down worker 3</span><br></pre></td></tr></table></figure>
<p>We can see how this code works from the messages: workers 0 and 3 got the first two requests, and then on the third request, the server stopped accepting connections. When the <code>ThreadPool</code> goes out of scope at the end of <code>main</code>, its <code>Drop</code> implementation kicks in, and the pool tells all workers to terminate. The workers each print a message when they see the terminate message, and then the thread pool calls <code>join</code> to shut down each worker thread.</p>
<p>Notice one interesting aspect of this particular execution: the <code>ThreadPool</code> sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</p>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/hellomulti" target="_blank" rel="noopener">here</a>. Future work:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods.</li>
<li>Add tests of the library’s functionality.</li>
<li>Change calls to <code>unwrap</code> to more robust error handling.</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests.</li>
<li>Find a thread pool crate on <a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a> and implement a similar web server using the crate instead. Then compare its API and robustness to the thread pool we implemented.</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol5-Project/">
    <time datetime="2019-12-03T04:00:00.000Z" class="entry-date">
        2019-12-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graceful-Shutdown/">Graceful Shutdown</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/">Rust</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Server-Multithreaded-Server/">Web Server Multithreaded Server</a></li></ul>

    </footer>
</article>





  
    <article id="post-Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance" class="post-Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance/">The Rust Programming Language Brief Note (Vol5-Advance)</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance/" data-id="ckplazpeg000iz2bz6d0hcyuz" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
            <!-- Table of Contents -->
              
        <h2 id="15-Smart-Pointers"><a href="#15-Smart-Pointers" class="headerlink" title="15 Smart Pointers"></a>15 Smart Pointers</h2><p>Reference counting smart pointer enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.</p>
<p>References are pointers that only borrow data; in contrast, in many cases, smart pointers <em>own</em> the data they point to.</p>
<p>Smart pointers are usually implemented using structs. The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.</p>
<ul>
<li>The <code>Deref</code> trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers. </li>
<li>The <code>Drop</code> trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>
</ul>
<h3 id="15-1-Using-Box-to-Point-to-Data-on-the-Heap"><a href="#15-1-Using-Box-to-Point-to-Data-on-the-Heap" class="headerlink" title="15-1 Using Box to Point to Data on the Heap"></a>15-1 Using Box to Point to Data on the Heap</h3><p>The most straightforward smart pointer is a <em>box</em>, which allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. </p>
<p>Boxes don’t have performance overhead, other than storing their data on the heap instead of on the stack. Some situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size (See Enabling Recursive Types with Boxes).</li>
<li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so<ul>
<li>Transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. </li>
<li>Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. </li>
</ul>
</li>
<li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type (Ch17, Using Trait Objects That Allow for Values of Different Types).</li>
</ul>
<h4 id="15-1-1-Using-a-Box-lt-T-gt-to-Store-Data-on-the-Heap"><a href="#15-1-1-Using-a-Box-lt-T-gt-to-Store-Data-on-the-Heap" class="headerlink" title="15-1-1 Using a Box&lt;T&gt; to Store Data on the Heap"></a>15-1-1 Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Just like any owned value, when a box goes out of scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</p>
<h4 id="15-1-2-Enabling-Recursive-Types-with-Boxes"><a href="#15-1-2-Enabling-Recursive-Types-with-Boxes" class="headerlink" title="15-1-2 Enabling Recursive Types with Boxes"></a>15-1-2 Enabling Recursive Types with Boxes</h4><p>One type whose size can’t be known at compile time is a <em>recursive type</em>. Boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</p>
<h5 id="15-1-2-1-More-Information-About-the-Cons-List"><a href="#15-1-2-1-More-Information-About-the-Cons-List" class="headerlink" title="15-1-2-1 More Information About the Cons List"></a>15-1-2-1 More Information About the Cons List</h5><p>A <em>cons list</em> is a data structure that comes from the Lisp programming language and its dialects. “To cons <em>x</em> onto <em>y</em>” informally means to construct a new container instance by putting the element <em>x</em> at the start of this new container, followed by the container <em>y</em>.</p>
<p>Each item in a cons list contains two elements: the value of the current item and the next item. The last item in the list contains only a value called <code>Nil</code> without a next item. A cons list is produced by recursively calling the <code>cons</code> function. The canonical name to denote the base case of the recursion is <code>Nil</code>. Note that this is not the same as the “null” or “nil” concept in Chapter 6, which is an invalid or absent value.</p>
<p>Most of the time when you have a list of items in Rust, <code>Vec</code> is a better choice to use. More complex recursive data types <em>are</em> useful in various situations.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">	Cons(<span class="keyword">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0072]: recursive type `List` has infinite size</span></span><br></pre></td></tr></table></figure>
<p>The reason is that we’ve defined <code>List</code> with a variant that is recursive, Rust can’t figure out how much space it needs to store a <code>list</code> value.</p>
<h5 id="15-1-2-2-Computing-the-Size-of-a-Non-Recursive-Type"><a href="#15-1-2-2-Computing-the-Size-of-a-Non-Recursive-Type" class="headerlink" title="15-1-2-2 Computing the Size of a Non-Recursive Type"></a>15-1-2-2 Computing the Size of a Non-Recursive Type</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">	Quit, </span><br><span class="line">    Move &#123;x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>&#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="keyword">i32</span>, <span class="keyword">i32</span>, <span class="keyword">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because only one variant will be used, the most space a <code>Message</code> value will need is the space it would take to store the largest of its variants.</p>
<h5 id="15-1-2-3-Using-Box-lt-T-gt-to-Get-a-Recursive-Type-with-a-Known-Size"><a href="#15-1-2-3-Using-Box-lt-T-gt-to-Get-a-Recursive-Type-with-a-Known-Size" class="headerlink" title="15-1-2-3 Using Box&lt;T&gt; to Get a Recursive Type with a Known Size"></a>15-1-2-3 Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</h5><p>Instead of storing a value directly, we’ll change the data structure to store the value indirectly by storing a pointer to the value instead.</p>
<p>Because a <code>Box</code> is a pointer, Rust always knows how much space a <code>Box</code> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to. This means we can put a <code>Box</code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly. The <code>Box</code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant. Conceptually, we still have a list, created with lists “holding” other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">	Cons(<span class="keyword">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> list = Cons(<span class="number">1</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>Cons</code> variant will need the size of an <code>i32</code> plus the space to store the box’s pointer data. </p>
<p><img src="https://doc.rust-lang.org/stable/book/img/trpl15-02.svg" alt=""></p>
<p>The <code>Box</code> type is a smart pointer because it implements the <code>Deref</code> trait, which allows <code>Box</code> values to be treated like references.  When a <code>Box</code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code>Drop</code> trait implementation.</p>
<h3 id="15-2-Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait"><a href="#15-2-Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait" class="headerlink" title="15-2 Treating Smart Pointers Like Regular References with the Deref Trait"></a>15-2 Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</h3><p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the <em>dereference operator</em>, <code>*</code>. By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>
<h4 id="15-2-1-Following-the-Pointer-to-the-Value-with-the-Dereference-Operator"><a href="#15-2-1-Following-the-Pointer-to-the-Value-with-the-Dereference-Operator" class="headerlink" title="15-2-1 Following the Pointer to the Value with the Dereference Operator"></a>15-2-1 Following the Pointer to the Value with the Dereference Operator</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="comment">// use *y to follow the reference to the value it’s pointing to (hence dereference). </span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-2-2-Using-Box-lt-T-gt-Like-a-Reference"><a href="#15-2-2-Using-Box-lt-T-gt-Like-a-Reference" class="headerlink" title="15-2-2 Using Box&lt;T&gt; Like a Reference"></a>15-2-2 Using <code>Box&lt;T&gt;</code> Like a Reference</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here we set <code>y</code> to be an instance of a box pointing to the value in <code>x</code> rather than a reference pointing to the value of <code>x</code>. </p>
<h4 id="15-2-3-Defining-Our-Own-Smart-Pointer"><a href="#15-2-3-Defining-Our-Own-Smart-Pointer" class="headerlink" title="15-2-3 Defining Our Own Smart Pointer"></a>15-2-3 Defining Our Own Smart Pointer</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    	MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0614]: type `MyBox&lt;&#123;integer&#125;&gt;` cannot be dereferenced</span></span><br></pre></td></tr></table></figure>
<p>Because we haven’t implemented that ability on our type. To enable dereferencing with the <code>*</code> operator, we implement the <code>Deref</code> trait.</p>
<h4 id="15-2-4-Treating-a-Type-Like-a-Reference-by-Implementing-the-Deref-Trait"><a href="#15-2-4-Treating-a-Type-Like-a-Reference-by-Implementing-the-Deref-Trait" class="headerlink" title="15-2-4 Treating a Type Like a Reference by Implementing the Deref Trait"></a>15-2-4 Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</h4><p>The <code>Deref</code> trait, provided by the standard library, requires us to implement one method named <code>deref</code> that borrows <code>self</code> and returns a reference to the inner data. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// defines an associated type for the Deref trait to use</span></span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &amp;self.0, returns a reference to the value we want to access with the * operator</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">    	&amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references. The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that it knows how to dereference.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*y </span><br><span class="line"><span class="comment">// means</span></span><br><span class="line">*(y.deref())</span><br></pre></td></tr></table></figure>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary, is the ownership system. </p>
<ul>
<li>If the <code>deref</code> method returned the value directly instead of a reference to the value, the value would be moved out of <code>self</code>. </li>
<li>We don’t want to take ownership of the inner value inside <code>MyBox</code> in this case or in most cases where we use the dereference operator.</li>
</ul>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.</p>
<h4 id="15-2-5-Implicit-Deref-Coercions-with-Functions-and-Methods"><a href="#15-2-5-Implicit-Deref-Coercions-with-Functions-and-Methods" class="headerlink" title="15-2-5 Implicit Deref Coercions with Functions and Methods"></a>15-2-5 Implicit Deref Coercions with Functions and Methods</h4><p>Deref coercion converts a reference to a type that implements <code>Deref</code> into a reference to a type that <code>Deref</code> can convert the original type into. Deref coercion happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because we implemented the <code>Deref</code> trait on <code>MyBox</code>, Rust can turn <code>&amp;MyBox</code> into <code>&amp;String</code> by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code> on <code>String</code> that returns a string slice, and this is in the API documentation for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which matches the <code>hello</code> function’s definition.</p>
<p>If Rust didn’t implement deref coercion:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>(*m)</code> dereferences the <code>MyBox</code> into a <code>String</code>. Then the <code>&amp;</code> and <code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to match the signature of <code>hello</code>.</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</p>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/deref" target="_blank" rel="noopener">here</a>.</p>
<h4 id="15-2-6-How-Deref-Coercion-Interacts-with-Mutability"><a href="#15-2-6-How-Deref-Coercion-Interacts-with-Mutability" class="headerlink" title="15-2-6 How Deref Coercion Interacts with Mutability"></a>15-2-6 How Deref Coercion Interacts with Mutability</h4><p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code> operator on mutable references.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is <em>not</em> possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don’t guarantee that. Therefore, Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.</p>
<h3 id="15-3-Running-Code-on-Cleanup-with-the-Drop-Trait"><a href="#15-3-Running-Code-on-Cleanup-with-the-Drop-Trait" class="headerlink" title="15-3 Running Code on Cleanup with the Drop Trait"></a>15-3 Running Code on Cleanup with the <code>Drop</code> Trait</h3><p><code>Drop</code> lets you customize what happens when a value is about to go out of scope. The <code>Drop</code> trait is almost always used when implementing a smart pointer. For example, <code>Box</code> customizes <code>Drop</code> to deallocate the space on the heap that the box points to.</p>
<p>In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. The <code>Drop</code> trait requires you to implement one method named <code>drop</code> that takes a mutable reference to <code>self</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">	data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    	<span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> c = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"my stuff"</span>) &#125;;</span><br><span class="line">    <span class="keyword">let</span> d = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"other staff"</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointers created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomSmartPointers created.</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `other stuff`!</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `my stuff`!</span></span><br></pre></td></tr></table></figure>
<h4 id="15-3-1-Dropping-a-Value-Early-with-std-mem-drop"><a href="#15-3-1-Dropping-a-Value-Early-with-std-mem-drop" class="headerlink" title="15-3-1 Dropping a Value Early with std::mem::drop"></a>15-3-1 Dropping a Value Early with <code>std::mem::drop</code></h4><p>Unfortunately, it’s not straightforward to disable the automatic <code>drop</code> functionality. Disabling <code>drop</code> isn’t usually necessary; the whole point of the <code>Drop</code> trait is that it’s taken care of automatically. </p>
<p>Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the <code>drop</code> method that releases the lock to run so other code in the same scope can acquire the lock. </p>
<p>Rust doesn’t let you call the <code>Drop</code> trait’s <code>drop</code> method manually; instead you have to call the <code>std::mem::drop</code> function provided by the standard library if you want to force a value to be dropped before the end of its scope.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> c = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"some data"</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created"</span>);</span><br><span class="line">    c.<span class="built_in">drop</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0040]: explicit use of destructor method</span></span><br></pre></td></tr></table></figure>
<p>We’re not allowed to explicitly call <code>drop</code>. The error message uses the term <em>destructor</em>, which is the general programming term for a function that cleans up an instance.</p>
<p>A <em>destructor</em> is analogous to a <em>constructor</em>, which creates an instance. The <code>drop</code> function in Rust is one particular destructor.</p>
<p>Rust doesn’t let us call <code>drop</code> explicitly because Rust would still automatically call <code>drop</code> on the value at the end of <code>main</code>. This would be a <em>double free</em> error because Rust would be trying to clean up the same value twice.</p>
<p>The <code>std::mem::drop</code> function is different from the <code>drop</code> method in the <code>Drop</code> trait. We call it by passing the value we want to force to be dropped early as an argument. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"some data"</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>);</span><br><span class="line">    <span class="built_in">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `some data`!</span></span><br><span class="line"><span class="comment">// CustomSmartPointer dropped before the end of main.</span></span><br></pre></td></tr></table></figure>
<h3 id="15-4-Rc-lt-T-gt-the-Reference-Counted-Smart-Pointer"><a href="#15-4-Rc-lt-T-gt-the-Reference-Counted-Smart-Pointer" class="headerlink" title="15-4 Rc&lt;T&gt; the Reference Counted Smart Pointer"></a>15-4 <code>Rc&lt;T&gt;</code> the Reference Counted Smart Pointer</h3><p>When a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn’t be cleaned up unless it doesn’t have any edges pointing to it.</p>
<p>To enable multiple ownership, Rust has a type called <code>Rc</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc</code> type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
<p>We use the <code>Rc</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p>
<p>Note that <code>Rc</code> is only for use in single-threaded scenarios. </p>
<h4 id="15-4-1-Using-Rc-lt-T-gt-to-Share-Data"><a href="#15-4-1-Using-Rc-lt-T-gt-to-Share-Data" class="headerlink" title="15-4-1 Using Rc&lt;T&gt; to Share Data"></a>15-4-1 Using <code>Rc&lt;T&gt;</code> to Share Data</h4><p><img src="https://doc.rust-lang.org/stable/book/img/trpl15-03.svg" alt=""></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="keyword">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Cons(<span class="number">5</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">10</span>, <span class="built_in">Box</span>::new(Nil))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0382]: use of moved value: `a`</span></span><br></pre></td></tr></table></figure>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code> is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn’t let us compile <code>let a = Cons(10, &amp;Nil);</code> for example, because the temporary <code>Nil</code> value would be dropped before <code>a</code> could take a reference to it.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="keyword">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Each Cons variant will now hold a value and an Rc&lt;T&gt; pointing to a List</span></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="comment">// clone the Rc&lt;List&gt; that a is holding</span></span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="comment">// increasing the number of references from two to three</span></span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Every time we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc</code> will increase, and the data won’t be cleaned up unless there are zero references to it.</p>
<p>The implementation of <code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’ implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the reference count, which doesn’t take much time. </p>
<h4 id="15-4-2-Cloning-an-Rc-lt-T-gt-Increases-the-Reference-Count"><a href="#15-4-2-Cloning-an-Rc-lt-T-gt-Increases-the-Reference-Count" class="headerlink" title="15-4-2 Cloning an Rc&lt;T&gt; Increases the Reference Count"></a>15-4-2 Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count after creating a = 1</span></span><br><span class="line"><span class="comment">// count after creating b = 2</span></span><br><span class="line"><span class="comment">// count after creating c = 3</span></span><br><span class="line"><span class="comment">// count after c goes out of scope = 2</span></span><br></pre></td></tr></table></figure>
<p>The implementation of the <code>Drop</code> trait decreases the reference count automatically when an <code>Rc</code> value goes out of scope.</p>
<h3 id="15-5-RefCell-lt-T-gt-and-the-Interior-Mutability-Pattern"><a href="#15-5-RefCell-lt-T-gt-and-the-Interior-Mutability-Pattern" class="headerlink" title="15-5 RefCell&lt;T&gt; and the Interior Mutability Pattern"></a>15-5 <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</h3><h4 id="15-5-1-Enforcing-Borrowing-Rules-at-Runtime-with-RefCell-lt-T-gt"><a href="#15-5-1-Enforcing-Borrowing-Rules-at-Runtime-with-RefCell-lt-T-gt" class="headerlink" title="15-5-1 Enforcing Borrowing Rules at Runtime with RefCell&lt;T&gt;"></a>15-5-1 Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></h4><p>Unlike <code>Rc</code>, the <code>RefCell</code> type represents single ownership over the data it holds. </p>
<ul>
<li>With references and <code>Box</code>, the borrowing rules’ invariants are enforced at compile time. With <code>RefCell</code>, these invariants are enforced <em>at runtime</em>. </li>
<li>With references, if you break these rules, you’ll get a compiler error. With <code>RefCell</code>, if you break these rules, your program will panic and exit.</li>
</ul>
<p>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust’s default.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. </p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The <code>RefCell</code> type is useful <strong>when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that</strong>.</p>
<p>Similar to <code>Rc</code>, <code>RefCell</code> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context.</p>
<p>A recap of the reasons to choose <code>Box</code>, <code>Rc</code>, or <code>RefCell</code>:</p>
<ul>
<li><code>Rc</code> enables multiple owners of the same data; <code>Box</code> and <code>RefCell</code> have single owners.</li>
<li><code>Box</code> allows immutable or mutable borrows checked at compile time; <code>Rc</code> allows only immutable borrows checked at compile time; <code>RefCell</code> allows immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell</code> allows mutable borrows checked at runtime, you can mutate the value inside the <code>RefCell</code> even when the <code>RefCell</code> is immutable.</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em> pattern. </p>
<h4 id="15-5-2-Interior-Mutability-A-Mutable-Borrow-to-an-Immutable-Value"><a href="#15-5-2-Interior-Mutability-A-Mutable-Borrow-to-an-Immutable-Value" class="headerlink" title="15-5-2 Interior Mutability, A Mutable Borrow to an Immutable Value"></a>15-5-2 Interior Mutability, A Mutable Borrow to an Immutable Value</h4><p>A consequence of the borrowing rules is that when you have an immutable value, you can’t borrow it mutably.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0596]: cannot borrow immutable local variable `x` as mutable</span></span><br></pre></td></tr></table></figure>
<p>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value’s methods would not be able to mutate the value. Using <code>RefCell</code> is one way to get the ability to have interior mutability. But <code>RefCell</code> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of a compiler error.</p>
<h5 id="15-5-2-1-A-Use-Case-for-interior-Mutability-Mock-Objects"><a href="#15-5-2-1-A-Use-Case-for-interior-Mutability-Mock-Objects" class="headerlink" title="15-5-2-1 A Use Case for interior Mutability, Mock Objects"></a>15-5-2-1 A Use Case for interior Mutability, Mock Objects</h5><p>A <em>test double</em> is the general programming concept for a type used in place of another type during testing. <em>Mock objects</em> are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide called <code>Messenger</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="comment">// send that takes an immutable reference to self and the text of the message. </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="keyword">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="keyword">usize</span>,</span><br><span class="line">    max: <span class="keyword">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Messenger &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="keyword">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="keyword">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="keyword">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You are over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">             <span class="keyword">self</span>.messenger.send(<span class="string">"Urgent warning: You've used up over 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Warning: You've used up over 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We need a mock object that, instead of sending an email or text message when we call <code>send</code>, will only keep track of the messages it’s told to send. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: <span class="built_in">vec!</span>[] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable</span></span><br></pre></td></tr></table></figure>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages, because the <code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the suggestion from the error text to use <code>&amp;mut self</code> instead, because then the signature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait definition.</p>
<p>This is a situation in which interior mutability can help! We’ll store the <code>sent_messages</code> within a <code>RefCell</code>, and then the <code>send</code> message will be able to modify <code>sent_messages</code> to store the messages we’ve seen.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">		<span class="comment">// call borrow on the RefCell&lt;Vec&lt;String&gt;&gt; to get an immutable reference to the vector.</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For the implementation of the <code>send</code> method, the first parameter is still an immutable borrow of <code>self</code>, which matches the trait definition. We call <code>borrow_mut</code> on the <code>RefCell&gt;</code> in <code>self.sent_messages</code> to get a mutable reference to the value inside the <code>RefCell&gt;</code>, which is the vector. Then we can call <code>push</code> on the mutable reference to the vector to keep track of the messages sent during the test.</p>
<h5 id="15-5-2-2-Keeping-Track-of-Borrows-at-Runtime-with-RefCell-lt-T-gt"><a href="#15-5-2-2-Keeping-Track-of-Borrows-at-Runtime-with-RefCell-lt-T-gt" class="headerlink" title="15-5-2-2 Keeping Track of Borrows at Runtime with RefCell&lt;T&gt;"></a>15-5-2-2 Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></h5><p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code> syntax, respectively. With <code>RefCell</code>, we use the <code>borrow</code> and <code>borrow_mut</code> methods, which are part of the safe API that belongs to <code>RefCell</code>. The <code>borrow</code> method returns the smart pointer type <code>Ref</code>, and <code>borrow_mut</code> returns the smart pointer type <code>RefMut</code>. Both types implement <code>Deref</code>, so we can treat them like regular references.</p>
<p>The <code>RefCell</code> keeps track of how many <code>Ref</code> and <code>RefMut</code> smart pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell</code> increases its count of how many immutable borrows are active. When a <code>Ref</code> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, <code>RefCell</code> lets us have many immutable borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of <code>RefCell</code> will panic at runtime. We’re deliberately trying to create two mutable borrows active for the same scope to illustrate that <code>RefCell</code> prevents us from doing this at runtime.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> one_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> two_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br><span class="line"></span><br><span class="line">        one_borrow.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        two_borrow.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// already borrowed: BorrowMutError. </span></span><br><span class="line"><span class="comment">// This is how RefCell&lt;T&gt; handles violations of the borrowing rules at runtime.</span></span><br></pre></td></tr></table></figure>
<p>Catching borrowing errors at runtime rather than compile time means that you would find a mistake in your code later in the development process and possibly not until your code was deployed to production. Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time. However, using <code>RefCell</code> makes it possible to write a mock object that can modify itself to keep track of the messages it has seen while you’re using it in a context where only immutable values are allowed. You can use <code>RefCell</code> despite its trade-offs to get more functionality than regular references provide.</p>
<h4 id="15-5-3-Having-Multiple-Owners-of-Mutable-Data-by-Combing-Rc-lt-T-gt-and-RefCell-lt-T-gt"><a href="#15-5-3-Having-Multiple-Owners-of-Mutable-Data-by-Combing-Rc-lt-T-gt-and-RefCell-lt-T-gt" class="headerlink" title="15-5-3 Having Multiple Owners of Mutable Data by Combing Rc&lt;T&gt; and RefCell&lt;T&gt;"></a>15-5-3 Having Multiple Owners of Mutable Data by Combing <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></h4><p>A common way to use <code>RefCell</code> is in combination with <code>Rc</code>. Recall that <code>Rc</code> lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an <code>Rc</code> that holds a <code>RefCell</code>, you can get a value that can have multiple owners <em>and</em> that you can mutate!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="keyword">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span></span><br><span class="line"><span class="comment">// b after = Cons(RefCell &#123; value: 6 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span></span><br><span class="line"><span class="comment">// c after = Cons(RefCell &#123; value: 10 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span></span><br></pre></td></tr></table></figure>
<p>We need to clone <code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from <code>value</code>.</p>
<p>The <code>borrow_mut</code> method uses the automatic dereferencing feature to dereference the <code>Rc</code> to the inner <code>RefCell</code> value, returns a <code>RefMut</code> smart pointer, and we use the dereference operator on it and change the inner value.</p>
<p>By using <code>RefCell</code>, we have an outwardly immutable <code>List</code> value. But we can use the methods on <code>RefCell</code> that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures.</p>
<p>The standard library has other types that provide interior mutability, such as <code>Cell</code>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the <code>Cell</code>. There’s also <code>Mutex</code>, which offers interior mutability that’s safe to use across threads.</p>
<h3 id="15-6-Reference-Cycles-Can-Leak-Memory"><a href="#15-6-Reference-Cycles-Can-Leak-Memory" class="headerlink" title="15-6 Reference Cycles Can Leak Memory"></a>15-6 Reference Cycles Can Leak Memory</h3><p>Rust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a <em>memory leak</em>). </p>
<p>Preventing memory leaks entirely is not one of Rust’s guarantees in the same way that disallowing data races at compile time is, meaning memory leaks are memory safe in Rust. </p>
<p>We can see that Rust allows memory leaks by using <code>Rc</code> and <code>RefCell</code>: it’s possible to create references where items refer to each other in a cycle. This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.</p>
<h4 id="15-6-1-Creating-a-Reference-Cycle"><a href="#15-6-1-Creating-a-Reference-Cycle" class="headerlink" title="15-6-1 Creating a Reference Cycle"></a>15-6-1 Creating a Reference Cycle</h4><p>Let’s look at how a reference cycle might happen and how to prevent it:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    <span class="comment">// we want to modify which List value a Cons variant is pointing to. </span></span><br><span class="line">    Cons(<span class="keyword">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> List &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">tail</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Cons(_, item) =&gt; <span class="literal">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code creates a list in <code>a</code> and a list in <code>b</code> that points to the list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a reference cycle. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, RefCell::new(Rc::new(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a initial rc count = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a next item = &#123;:?&#125;"</span>, a.tail());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Rc::new(Cons(<span class="number">10</span>, RefCell::new(Rc::clone(&amp;a))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a rc count after b creation = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b initial rc count = &#123;&#125;"</span>, Rc::strong_count(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b next item = &#123;:?&#125;"</span>, b.tail());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(link) = a.tail() &#123;</span><br><span class="line">        *link.borrow_mut() = Rc::clone(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b rc count after changing a = &#123;&#125;"</span>, Rc::strong_count(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a rc count after changing a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uncomment the next line to see that we have a cycle;</span></span><br><span class="line">    <span class="comment">// it will overflow the stack</span></span><br><span class="line">    <span class="comment">// println!("a next item = &#123;:?&#125;", a.tail());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a initial rc count = 1</span></span><br><span class="line"><span class="comment">// a next item = Some(RefCell &#123; value: Nil &#125;)</span></span><br><span class="line"><span class="comment">// a rc count after b creation = 2</span></span><br><span class="line"><span class="comment">// b initial rc count = 1</span></span><br><span class="line"><span class="comment">// b next item = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)</span></span><br><span class="line"><span class="comment">// b rc count after changing a = 2</span></span><br><span class="line"><span class="comment">// a rc count after changing a = 2</span></span><br></pre></td></tr></table></figure>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We do that by using the <code>tail</code> method to get a reference to the <code>RefCell&gt;</code> in <code>a</code>, which we put in the variable <code>link</code>. Then we use the <code>borrow_mut</code> method on the <code>RefCell&gt;</code> to change the value inside from an <code>Rc</code> that holds a <code>Nil</code> value to the <code>Rc</code> in <code>b</code>.</p>
<p><img src="https://doc.rust-lang.org/stable/book/img/trpl15-04.svg" alt=""></p>
<p>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren’t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</p>
<p>If you have <code>RefCell</code> values that contain <code>Rc</code> values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don’t create cycles; you can’t rely on Rust to catch them. </p>
<p>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing above, we always want <code>Cons</code> variants to own their list, so reorganizing the data structure isn’t possible. </p>
<h4 id="15-6-2-Preventing-Reference-Cycles-Turning-an-Rc-lt-T-gt-into-a-Weak-lt-T-gt"><a href="#15-6-2-Preventing-Reference-Cycles-Turning-an-Rc-lt-T-gt-into-a-Weak-lt-T-gt" class="headerlink" title="15-6-2 Preventing Reference Cycles, Turning an Rc&lt;T&gt; into a Weak&lt;T&gt;"></a>15-6-2 Preventing Reference Cycles, Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></h4><p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the <code>strong_count</code> of an <code>Rc</code> instance, and an <code>Rc</code> instance is only cleaned up if its <code>strong_count</code> is 0. You can also create a <em>weak reference</em> to the value within an <code>Rc</code> instance by calling <code>Rc::downgrade</code> and passing a reference to the <code>Rc</code>. When you call <code>Rc::downgrade</code>, you get a smart pointer of type <code>Weak</code>. Instead of increasing the <code>strong_count</code> in the <code>Rc</code> instance by 1, calling <code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc</code> type uses <code>weak_count</code> to keep track of how many <code>Weak</code> references exist, similar to <code>strong_count</code>. The difference is the <code>weak_count</code> doesn’t need to be 0 for the <code>Rc</code> instance to be cleaned up.</p>
<p>Strong references are how you can share ownership of an <code>Rc</code> instance. Weak references don’t express an ownership relationship. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>
<p>Because the value that <code>Weak</code> references might have been dropped, to do anything with the value that a <code>Weak</code> is pointing to, you must make sure the value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak</code> instance, which will return an <code>Option&gt;</code>. You’ll get a result of <code>Some</code> if the <code>Rc</code> value has not been dropped yet and a result of <code>None</code> if the <code>Rc</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option</code>, Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there won’t be an invalid pointer.</p>
<h5 id="15-6-2-1-Creating-a-Tree-Data-Structure-a-Node-with-Child-Nodes"><a href="#15-6-2-1-Creating-a-Tree-Data-Structure-a-Node-with-Child-Nodes" class="headerlink" title="15-6-2-1 Creating a Tree Data Structure, a Node with Child Nodes"></a>15-6-2-1 Creating a Tree Data Structure, a Node with Child Nodes</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="keyword">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with variables so we can access each <code>Node</code> in the tree directly. </p>
<p>To do this, we define the <code>Vec</code> items to be values of type <code>Rc</code>. We also want to modify which nodes are children of another node, so we have a <code>RefCell</code> in <code>children</code> around the <code>Vec&gt;</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="15-6-2-2-Adding-a-Reference-from-a-Child-to-Its-Parent"><a href="#15-6-2-2-Adding-a-Reference-from-a-Child-to-Its-Parent" class="headerlink" title="15-6-2-2 Adding a Reference from a Child to Its Parent"></a>15-6-2-2 Adding a Reference from a Child to Its Parent</h5><p>It can’t contain an <code>Rc</code>, because that would create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and <code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code> values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="keyword">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A node will be able to refer to its parent node but doesn’t own its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;,</span></span><br><span class="line"><span class="comment">// children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;,</span></span><br><span class="line"><span class="comment">// children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>Once we have the <code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak</code> reference to its parent. We use the <code>borrow_mut</code> method on the <code>RefCell&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the <code>Rc::downgrade</code> function to create a <code>Weak</code> reference to <code>branch</code> from the <code>Rc</code> in <code>branch.</code></p>
<p>The lack of infinite output indicates that this code didn’t create a reference cycle. We can also tell this by looking at the values we get from calling <code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<h5 id="15-6-2-3-Visualizing-Changes-to-strong-count-and-weak-count"><a href="#15-6-2-3-Visualizing-Changes-to-strong-count-and-weak-count" class="headerlink" title="15-6-2-3 Visualizing Changes to strong_count and weak_count"></a>15-6-2-3 Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"leaf strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::new(Weak::new()),</span><br><span class="line">            children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"branch strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">            Rc::strong_count(&amp;branch),</span><br><span class="line">            Rc::weak_count(&amp;branch),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"leaf strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">            Rc::strong_count(&amp;leaf),</span><br><span class="line">            Rc::weak_count(&amp;leaf),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"leaf strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br><span class="line"><span class="comment">// branch strong = 1, weak = 1</span></span><br><span class="line"><span class="comment">// leaf strong = 2, weak = 0</span></span><br><span class="line"><span class="comment">// leaf parent = None</span></span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br></pre></td></tr></table></figure>
<h2 id="16-Fearless-Concurrency"><a href="#16-Fearless-Concurrency" class="headerlink" title="16 Fearless Concurrency"></a>16 Fearless Concurrency</h2><p>The ownership and type systems are a powerful set of tools to help manage memory safety <em>and</em> concurrency problems!</p>
<h3 id="16-1-Using-Threads-to-Run-Code-Simultaneously"><a href="#16-1-Using-Threads-to-Run-Code-Simultaneously" class="headerlink" title="16-1 Using Threads to Run Code Simultaneously"></a>16-1 Using Threads to Run Code Simultaneously</h3><p>Multiple threads problems:</p>
<ul>
<li>Race conditions</li>
<li>Deadlock</li>
<li>Bugs that happen only in certain situations</li>
</ul>
<p>Special implementation of threads:</p>
<ul>
<li>1:1</li>
<li>M:N</li>
</ul>
<p>What most important to Rust is runtime support. <em>Runtime</em> is a confusing term and can have different meanings in different contexts. In this context, by <em>runtime</em> we mean code that is included by the language in every binary. Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</p>
<p>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</p>
<h4 id="16-1-1-Creating-a-New-Thread-with-spawn"><a href="#16-1-1-Creating-a-New-Thread-with-spawn" class="headerlink" title="16-1-1 Creating a New Thread with spawn"></a>16-1-1 Creating a New Thread with <code>spawn</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The new thread will be stopped when the main thread ends, whether or not it has finished running. </p>
<h4 id="16-1-2-Waiting-for-All-Threads-to-Finish-Using-join-Handles"><a href="#16-1-2-Waiting-for-All-Threads-to-Finish-Using-join-Handles" class="headerlink" title="16-1-2 Waiting for All Threads to Finish Using join Handles"></a>16-1-2 Waiting for All Threads to Finish Using <code>join</code> Handles</h4><p>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of <code>thread::spawn</code> in a variable. The return type of <code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned value that, when we call the <code>join</code> method on it, will wait for its thread to finish. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi number 1 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 1 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 5 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 6 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 7 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 8 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 9 from the spawned thread!</span></span><br></pre></td></tr></table></figure>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the thread represented by the handle terminates. <em>Blocking</em> a thread means that thread is prevented from performing work or exiting.</p>
<p>The two threads continue alternating, but the main thread waits because of the call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi number 1 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 5 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 6 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 7 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 8 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 9 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 1 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the main thread!</span></span><br></pre></td></tr></table></figure>
<h4 id="16-1-3-Using-move-Closures-with-Threads"><a href="#16-1-3-Using-move-Closures-with-Threads" class="headerlink" title="16-1-3 Using move Closures with Threads"></a>16-1-3 Using <code>move</code> Closures with Threads</h4><p>The <code>move</code> closure is often used alongside <code>thread::spawn</code> because it allows you to use data from one thread in another thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</span></span><br></pre></td></tr></table></figure>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t tell how long the spawned thread will run, so it doesn’t know if the reference to <code>v</code> will always be valid.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drop</span>(v); <span class="comment">// oh no!</span></span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span></span><br></pre></td></tr></table></figure>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take ownership of the values it’s using rather than allowing Rust to infer that it should borrow the values. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we added move to the closure, we would move v into the closure’s environment, and we could no longer call drop on it in the main thread. </span></span><br><span class="line">    <span class="comment">// drop(v);</span></span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-Using-Message-Passing-to-Transfer-Data-Between-Threads"><a href="#16-2-Using-Message-Passing-to-Transfer-Data-Between-Threads" class="headerlink" title="16-2 Using Message Passing to Transfer Data Between Threads"></a>16-2 Using Message Passing to Transfer Data Between Threads</h3><p>One increasingly popular approach to ensuring safe concurrency is <em>message passing</em>, where threads or actors communicate by sending each other messages containing data. Go slogan “Do not communicate by sharing memory; instead, share memory by communicating.”</p>
<p>One major tool Rust has for accomplishing message-sending concurrency is the <em>channel</em>. A channel in programming has two halves: a transmitter and a receiver. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be <em>closed</em> if either the transmitter or receiver half is dropped.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We create a new channel using the <code>mpsc::channel</code> function, it returns a tuple, the first element of which is the sending end and the second element is the receiving end. <code>mpsc</code> stands for <em>multiple producer, single consumer</em>. </p>
<p>The way Rust’s standard library implements channels means a channel can have multiple <em>sending</em> ends that produce values but only one <em>receiving</em> end that consumes those values.</p>
<p>The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel by using <code>move</code>.</p>
<p>The transmitting end has a <code>send</code> method that takes the value we want to send. The <code>send</code> method returns a <code>Result</code> type, so if the receiving end has already been dropped and there’s nowhere to send a value, the send operation will return an error. In this example, we’re calling <code>unwrap</code> to panic in case of an error. But in a real application, we would handle it properly.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code>. We’re using <code>recv</code>, short for <em>receive</em>, which will block the main thread’s execution and wait until a value is sent down the channel. Once a value is sent, <code>recv</code> will return it in a <code>Result</code>. When the sending end of the channel closes, <code>recv</code> will return an error to signal that no more values will be coming.</p>
<p>The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result</code> immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code> value if there aren’t any messages this time. Using <code>try_recv</code> is useful if this thread has other work to do while waiting for messages: we could write a loop that calls <code>try_recv</code> every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</p>
<h4 id="16-2-1-Channels-and-Ownership-Transference"><a href="#16-2-1-Channels-and-Ownership-Transference" class="headerlink" title="16-2-1 Channels and Ownership Transference"></a>16-2-1 Channels and Ownership Transference</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"val is &#123;&#125;"</span>, val);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0382]: use of moved value: `val`</span></span><br></pre></td></tr></table></figure>
<p>The <code>send</code> function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it. </p>
<h4 id="16-2-2-Sending-Multiple-Values-and-Seeing-the-Receiver-Waiting"><a href="#16-2-2-Sending-Multiple-Values-and-Seeing-the-Receiver-Waiting" class="headerlink" title="16-2-2 Sending Multiple Values and Seeing the Receiver Waiting"></a>16-2-2 Sending Multiple Values and Seeing the Receiver Waiting</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-2-3-Creating-Multiple-Producers-by-Cloning-the-Transmitter"><a href="#16-2-3-Creating-Multiple-Producers-by-Cloning-the-Transmitter" class="headerlink" title="16-2-3 Creating Multiple Producers by Cloning the Transmitter"></a>16-2-3 Creating Multiple Producers by Cloning the Transmitter</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx1.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"more"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"messages"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"for"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"you"</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Got: hi</span></span><br><span class="line"><span class="comment">// Got: more</span></span><br><span class="line"><span class="comment">// Got: from</span></span><br><span class="line"><span class="comment">// Got: messages</span></span><br><span class="line"><span class="comment">// Got: for</span></span><br><span class="line"><span class="comment">// Got: the</span></span><br><span class="line"><span class="comment">// Got: thread</span></span><br><span class="line"><span class="comment">// Got: you</span></span><br></pre></td></tr></table></figure>
<h3 id="16-3-Shared-State-Concurrency"><a href="#16-3-Shared-State-Concurrency" class="headerlink" title="16-3 Shared-State Concurrency"></a>16-3 Shared-State Concurrency</h3><p>Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time.</p>
<h4 id="16-3-1-Using-Mutexes-to-Allow-Access-to-Data-from-One-Thread-at-a-Time"><a href="#16-3-1-Using-Mutexes-to-Allow-Access-to-Data-from-One-Thread-at-a-Time" class="headerlink" title="16-3-1 Using Mutexes to Allow Access to Data from One Thread at a Time"></a>16-3-1 Using Mutexes to Allow Access to Data from One Thread at a Time</h4><p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in, a mutex allows only one thread to access some data at any given time. To access the data in a mutex, a thread must first signal that it wants access by asking to acquire the mutex’s <em>lock</em>. </p>
<p>Management of mutexes can be incredibly tricky to get right (lock and unlock), which is why so many people are enthusiastic about channels. However, thanks to Rust’s type system and ownership rules, you can’t get locking and unlocking wrong.</p>
<h5 id="16-3-1-1-The-API-of-Mutex-lt-T-gt"><a href="#16-3-1-1-The-API-of-Mutex-lt-T-gt" class="headerlink" title="16-3-1-1 The API of Mutex&lt;T&gt;"></a>16-3-1-1 The API of <code>Mutex&lt;T&gt;</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// m = 6</span></span><br></pre></td></tr></table></figure>
<p><code>lock</code> call will block the current thread so it can’t do any work until it’s our turn to have the lock. The call to <code>lock</code> would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we’ve chosen to <code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p><code>Mutex</code> is a smart pointer. More accurately, the call to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>, wrapped in a <code>LockResult</code> that we handled with the call to <code>unwrap</code>. </p>
<p>The <code>MutexGuard</code> smart pointer implements <code>Deref</code> to point at our inner data; the smart pointer also has a <code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope.</p>
<h5 id="16-3-1-2-Sharing-a-Mutex-lt-T-gt-Between-Multiple-Threads"><a href="#16-3-1-2-Sharing-a-Mutex-lt-T-gt-Between-Multiple-Threads" class="headerlink" title="16-3-1-2 Sharing a Mutex&lt;T&gt; Between Multiple Threads"></a>16-3-1-2 Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> counter = Mutex::new(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handle = <span class="built_in">vec!</span>[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    	<span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">		hundles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">    	handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result:&#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0382]: capture of moved value: `counter`</span></span><br></pre></td></tr></table></figure>
<p>The <code>counter</code> value is moved into the closure and then captured when we call <code>lock</code>. That description sounds like what we wanted, but it’s not allowed!</p>
<p>We can’t move ownership of <code>counter</code> into multiple threads. This was hard to see because our threads were in a loop, and Rust can’t point to different threads in different iterations of the loop.</p>
<h5 id="16-3-1-3-Multiple-Ownership-with-Multiple-Threads"><a href="#16-3-1-3-Multiple-Ownership-with-Multiple-Threads" class="headerlink" title="16-3-1-3 Multiple Ownership with Multiple Threads"></a>16-3-1-3 Multiple Ownership with Multiple Threads</h5><p>We’ll wrap the <code>Mutex</code> in <code>Rc</code> and clone the <code>Rc</code> before moving ownership to the thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> counter = Rc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    	<span class="keyword">let</span> counter = Rc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        	<span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">    	handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;: std::marker::Send` is not satisfied</span></span><br></pre></td></tr></table></figure>
<p><code>Rc</code> is not safe to share across threads. When <code>Rc</code> manages the reference count, it adds to the count for each call to <code>clone</code> and subtracts from the count when each clone is dropped. But it doesn’t use any concurrency primitives to make sure that changes to the count can’t be interrupted by another thread. This could lead to wrong counts—subtle bugs that could in turn lead to memory leaks or a value being dropped before we’re done with it. What we need is a type exactly like <code>Rc</code> but one that makes changes to the reference count in a thread-safe way.</p>
<h5 id="16-3-1-4-Atomic-Reference-Counting-with-Arc-lt-T-gt"><a href="#16-3-1-4-Atomic-Reference-Counting-with-Arc-lt-T-gt" class="headerlink" title="16-3-1-4 Atomic Reference Counting with Arc&lt;T&gt;"></a>16-3-1-4 Atomic Reference Counting with <code>Arc&lt;T&gt;</code></h5><p><code>Arc</code> <em>is</em> a type like <code>Rc</code> that is safe to use in concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically reference counted</em> type. Atomics work like primitive types but are safe to share across threads.</p>
<p>Why all primitive types aren’t atomic and why standard library types aren’t implemented to use <code>Arc</code> by default? The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result: 10</span></span><br></pre></td></tr></table></figure>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/arc" target="_blank" rel="noopener">here</a>.</p>
<h4 id="16-3-2-Similarities-Between-RefCell-lt-T-gt-Rc-lt-T-gt-and-Mutex-lt-T-gt-Arc-lt-T-gt"><a href="#16-3-2-Similarities-Between-RefCell-lt-T-gt-Rc-lt-T-gt-and-Mutex-lt-T-gt-Arc-lt-T-gt" class="headerlink" title="16-3-2 Similarities Between RefCell&lt;T&gt;/Rc&lt;T&gt; and Mutex&lt;T&gt;/Arc&lt;T&gt;"></a>16-3-2 Similarities Between <code>RefCell&lt;T&gt;/Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;/Arc&lt;T&gt;</code></h4><p><code>counter</code> is immutable but we could get a mutable reference to the value inside it, <code>Mutex</code> provides interior mutability, as the <code>Cell</code> family does. </p>
<ul>
<li>We use <code>RefCell</code> to allow us to mutate contents inside an <code>Rc</code></li>
<li>We use <code>Mutex</code> to mutate contents inside an <code>Arc</code>.</li>
</ul>
<p>Rust can’t protect you from all kinds of logic errors when you use <code>Mutex</code>. </p>
<ul>
<li>using <code>Rc</code> came with the risk of creating reference cycles, where two <code>Rc</code> values refer to each other, causing memory leaks. </li>
<li><code>Mutex</code> comes with the risk of creating <em>deadlocks</em>. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. </li>
</ul>
<h3 id="16-4-Extensible-Concurrency-with-the-Sync-and-Send-Traits"><a href="#16-4-Extensible-Concurrency-with-the-Sync-and-Send-Traits" class="headerlink" title="16-4 Extensible Concurrency with the Sync and Send Traits"></a>16-4 Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</h3><p>Rust language has <em>very</em> few concurrency features. Almost every concurrency feature we’ve talked about so far in this chapter has been part of the standard library, not the language. However, two concurrency concepts are embedded in the language: the <code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<h4 id="16-4-1-Allowing-Transference-of-Ownership-Between-Threads-with-Send"><a href="#16-4-1-Allowing-Transference-of-Ownership-Between-Threads-with-Send" class="headerlink" title="16-4-1 Allowing Transference of Ownership Between Threads with Send"></a>16-4-1 Allowing Transference of Ownership Between Threads with <code>Send</code></h4><p>The <code>Send</code> marker trait indicates that ownership of the type implementing <code>Send</code> can be transferred between threads. Almost every Rust type is <code>Send</code>, but there are some exceptions, including <code>Rc</code>: this cannot be <code>Send</code> because if you cloned an <code>Rc</code> value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, <code>Rc</code> is implemented for use in single-threaded situations where you don’t want to pay the thread-safe performance penalty.</p>
<h4 id="16-4-2-Allowing-Access-from-Multiple-Threads-with-Sync"><a href="#16-4-2-Allowing-Access-from-Multiple-Threads-with-Sync" class="headerlink" title="16-4-2 Allowing Access from Multiple Threads with Sync"></a>16-4-2 Allowing Access from Multiple Threads with <code>Sync</code></h4><p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing <code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is <code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code>, meaning the reference can be sent safely to another thread. Similar to <code>Send</code>, primitive types are <code>Sync</code>, and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>The smart pointer <code>Rc</code> is also not <code>Sync</code> for the same reasons that it’s not <code>Send</code>. The <code>RefCell</code> type and the family of related <code>Cell</code> types are not <code>Sync</code>. The smart pointer <code>Mutex</code> is <code>Sync</code> and can be used to share access with multiple threads.</p>
<h4 id="16-4-3-Implementing-Send-and-Sync-Manually-Is-Unsafe"><a href="#16-4-3-Implementing-Send-and-Sync-Manually-Is-Unsafe" class="headerlink" title="16-4-3 Implementing Send and Sync Manually Is Unsafe"></a>16-4-3 Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</h4><p>Because types that are made up of <code>Send</code> and <code>Sync</code> traits are automatically also <code>Send</code> and <code>Sync</code>, we don’t have to implement those traits manually. Building new concurrent types not made up of <code>Send</code> and <code>Sync</code> parts requires careful thought to uphold the safety guarantees. </p>
<h2 id="19-Advanced-Features"><a href="#19-Advanced-Features" class="headerlink" title="19 Advanced Features"></a>19 Advanced Features</h2><h3 id="19-1-Unsafe-Rust"><a href="#19-1-Unsafe-Rust" class="headerlink" title="19-1 Unsafe Rust"></a>19-1 Unsafe Rust</h3><p>One reason is static analysis is conservative; Another is that the underlying computer hardware is inherently unsafe.</p>
<h4 id="19-1-1-Unsafe-Superpowers"><a href="#19-1-1-Unsafe-Superpowers" class="headerlink" title="19-1-1 Unsafe Superpowers"></a>19-1-1 Unsafe Superpowers</h4><p><code>unsafe</code> doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked. </p>
<p>The <code>unsafe</code> keyword only gives you access to these four features that are then not checked by the compiler for memory safety. </p>
<p><code>unsafe</code> does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems. You’ll ensure the code inside an <code>unsafe</code> block will access memory in a valid way.</p>
<h4 id="19-1-2-Dereferencing-a-Raw-Pointer"><a href="#19-1-2-Dereferencing-a-Raw-Pointer" class="headerlink" title="19-1-2 Dereferencing a Raw Pointer"></a>19-1-2 Dereferencing a Raw Pointer</h4><p>Unsafe Rust has two new types called <em>raw pointers</em> that are similar to references. As with references, raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the dereference operator; it’s part of the type name. In the context of raw pointers, <em>immutable</em> means that the pointer can’t be directly assigned to after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<p>Give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply. </p>
<p>How to create an immutable and a mutable raw pointer from references:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">i32</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="keyword">i32</span>;</span><br></pre></td></tr></table></figure>
<p>We can create raw pointers in safe code (don’t include <code>unsafe</code>); we just can’t dereference raw pointers outside an unsafe block.</p>
<p>Next, we’ll create a raw pointer whose validity we can’t be so certain of. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = <span class="number">0x012345usize</span>;</span><br><span class="line"><span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">i32</span>;</span><br></pre></td></tr></table></figure>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em> raw pointers and read the data being pointed to. We use the dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">i32</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="keyword">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"r1 is: &#123;&#125;"</span>, *r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r2 is: &#123;&#125;"</span>, *r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Creating a pointer does no harm; it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.</p>
<p>Normally, if we create an immutable and a mutable reference to <code>num</code>, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race.</p>
<p>Why would you ever use raw pointers? </p>
<ul>
<li>One major use case is when interfacing with C code</li>
<li>Another is when building up safe abstractions that the borrow checker doesn’t understand</li>
</ul>
<h4 id="19-1-3-Calling-an-Unsafe-Function-or-Method"><a href="#19-1-3-Calling-an-Unsafe-Function-or-Method" class="headerlink" title="19-1-3 Calling an Unsafe Function or Method"></a>19-1-3 Calling an Unsafe Function or Method</h4><p>The <code>unsafe</code> keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dangerous</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">	dangerous();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// without unsafe, error[E0133]: call to unsafe function requires unsafe function or block</span></span><br></pre></td></tr></table></figure>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other unsafe operations within an unsafe function, we don’t need to add another <code>unsafe</code> block.</p>
<h5 id="19-1-3-1-Creating-a-Safe-Abstraction-over-Unsafe-Code"><a href="#19-1-3-1-Creating-a-Safe-Abstraction-over-Unsafe-Code" class="headerlink" title="19-1-3-1 Creating a Safe Abstraction over Unsafe Code"></a>19-1-3-1 Creating a Safe Abstraction over Unsafe Code</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split_at_mut usage</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (a, b) = r.split_at_mut(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>
<p>We can’t implement this function using only safe Rust. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="keyword">i32</span>], mid: <span class="keyword">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="keyword">i32</span>], &amp;<span class="keyword">mut</span> [<span class="keyword">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid],</span><br><span class="line">     &amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0499]: cannot borrow `*slice` as mutable more than once at a time</span></span><br></pre></td></tr></table></figure>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="keyword">i32</span>], mid: <span class="keyword">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="keyword">i32</span>], &amp;<span class="keyword">mut</span> [<span class="keyword">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line">    <span class="keyword">let</span> ptr = slice.as_mut_ptr();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">         slice::from_raw_parts_mut(ptr.offset(mid <span class="keyword">as</span> <span class="keyword">isize</span>), len - mid))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code> method to access the raw pointer of a slice. In this case, because we have a mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code>, which we’ve stored in the variable <code>ptr</code>.</p>
<p>The <code>slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice. Then we call the <code>offset</code> method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at <code>mid</code>.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid. The <code>offset</code> method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. </p>
<p>By looking at the code and by adding the assertion that <code>mid</code> must be less than or equal to <code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block will be valid pointers to data within the slice. </p>
<p>This is an acceptable and appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as <code>unsafe</code>, and we can call this function from safe Rust.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MAY CRASH</span></span><br><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> address = <span class="number">0x01234usize</span>;</span><br><span class="line"><span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="keyword">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice: &amp;[<span class="keyword">i32</span>] = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    slice::from_raw_parts_mut(r, <span class="number">10000</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid <code>i32</code> values. Attempting to use <code>slice</code> as though it’s a valid slice results in undefined behavior.</p>
<h5 id="19-1-3-2-Using-extern-Functions-to-Call-External-Code"><a href="#19-1-3-2-Using-extern-Functions-to-Call-External-Code" class="headerlink" title="19-1-3-2 Using extern Functions to Call External Code"></a>19-1-3-2 Using <code>extern</code> Functions to Call External Code</h5><p>Functions declared within <code>extern</code> blocks are always unsafe to call from Rust code. The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">abs</span></span>(input: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">    	<span class="built_in">println!</span>(<span class="string">"Absolute value of -3 according to C: &#123;&#125;"</span>, abs(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-1-4-Accessing-or-Modifying-a-Mutable-Static-Variable"><a href="#19-1-4-Accessing-or-Modifying-a-Mutable-Static-Variable" class="headerlink" title="19-1-4 Accessing or Modifying a Mutable Static Variable"></a>19-1-4 Accessing or Modifying a Mutable Static Variable</h4><p>In Rust, global variables are called <em>static</em> variables. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="keyword">str</span> = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"name is: &#123;&#125;"</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention, and we <em>must</em> annotate the variable’s type, which is <code>&amp;&#39;static str</code> in this example. Static variables can only store references with the <code>&#39;static</code> lifetime, which means the Rust compiler can figure out the lifetime; we don’t need to annotate it explicitly. Accessing an immutable static variable is safe.</p>
<p>Difference between constants and immutable static variables:</p>
<ul>
<li>Values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used.</li>
<li>Static variables can be mutable. Accessing and modifying mutable static variables is <em>unsafe</em>.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="keyword">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="keyword">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"COUNTER: &#123;&#125;"</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Any code that reads or writes from <code>mut COUNTER</code> must be within an <code>unsafe</code> block. </p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</p>
<h4 id="19-1-5-Implementing-an-Unsafe-Trait"><a href="#19-1-5-Implementing-an-Unsafe-Trait" class="headerlink" title="19-1-5 Implementing an Unsafe Trait"></a>19-1-5 Implementing an Unsafe Trait</h4><p>A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="comment">// methods go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="keyword">i32</span> &#123;</span><br><span class="line">    <span class="comment">// method implementations go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that the compiler can’t verify.</p>
<h3 id="19-2-Advanced-Traits"><a href="#19-2-Advanced-Traits" class="headerlink" title="19-2 Advanced Traits"></a>19-2 Advanced Traits</h3><h4 id="19-2-1-Specifying-Placeholder-Types-in-Trait-Definitions-with-Associated-Types"><a href="#19-2-1-Specifying-Placeholder-Types-in-Trait-Definitions-with-Associated-Types" class="headerlink" title="19-2-1 Specifying Placeholder Types in Trait Definitions with Associated Types"></a>19-2-1 Specifying Placeholder Types in Trait Definitions with Associated Types</h4><p><em>Associated types</em> connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The type <code>Item</code> is a placeholder type, and the <code>next</code> method’s definition shows that it will return values of type <code>Option</code>. Implementors of the <code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code> method will return an <code>Option</code> containing a value of that concrete type.</p>
<p>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="keyword">u32</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Generics:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The difference is that when using generics, we must annotate the types in each implementation; because we can also implement <code>Iterator for Counter</code> or any other type, we could have multiple implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the <code>next</code> method on <code>Counter</code>, we would have to provide type annotations to indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>With associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times. With the definition that uses associated types, we can only choose what the type of <code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>. We don’t have to specify that we want an iterator of <code>u32</code> values everywhere that we call <code>next</code> on <code>Counter</code>.</p>
<h4 id="19-2-2-Default-Generic-Type-Parameters-and-Operator-Overloading"><a href="#19-2-2-Default-Generic-Type-Parameters-and-Operator-Overloading" class="headerlink" title="19-2-2 Default Generic Type  Parameters and Operator Overloading"></a>19-2-2 Default Generic Type  Parameters and Operator Overloading</h4><p>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is <code>&lt;PlaceholderType=ConcreteType&gt;</code> when declaring the generic type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="keyword">i32</span>,</span><br><span class="line">    y: <span class="keyword">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Add <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Point) -&gt; Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,</span><br><span class="line">               Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its definition:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RHS=Self</code> is called <em>default type parameters</em>. The <code>RHS</code> generic type parameter (short for “right hand side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t specify a concrete type for <code>RHS</code> when we implement the <code>Add</code> trait, the type of <code>RHS</code> will default to <code>Self</code>, which will be the type we’re implementing <code>Add</code> on.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Millimeters</span></span>(<span class="keyword">u32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meters</span></span>(<span class="keyword">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Add&lt;Meters&gt; <span class="keyword">for</span> Millimeters &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Meters) -&gt; Millimeters &#123;</span><br><span class="line">        Millimeters(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add</code> to set the value of the <code>RHS</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>Two ways to use default type parameters:</p>
<ul>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ul>
<p>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</p>
<p>The standard library’s <code>Add</code> trait is an example of the second purpose: usually, you’ll add two like types, but the <code>Add</code> trait provides the ability to customize beyond that. Using a default type parameter in the <code>Add</code> trait definition means you don’t have to specify the extra parameter most of the time.</p>
<h4 id="19-2-3-Fully-Qualified-Syntax-for-Disambiguation-Calling-Methods-with-the-Same-Name"><a href="#19-2-3-Fully-Qualified-Syntax-for-Disambiguation-Calling-Methods-with-the-Same-Name" class="headerlink" title="19-2-3 Fully Qualified Syntax for Disambiguation, Calling Methods with the Same Name"></a>19-2-3 Fully Qualified Syntax for Disambiguation, Calling Methods with the Same Name</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Pilot</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Wizard</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Pilot <span class="keyword">for</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"This is your captain speaking."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Wizard <span class="keyword">for</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Up!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"*waving arms furiously*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> person = Human;</span><br><span class="line">    person.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *waving arms furiously*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> person = Human;</span><br><span class="line">    Pilot::fly(&amp;person);</span><br><span class="line">    Wizard::fly(&amp;person);</span><br><span class="line">    person.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This is your captain speaking.</span></span><br><span class="line"><span class="comment">// Up!</span></span><br><span class="line"><span class="comment">// *waving arms furiously*</span></span><br></pre></td></tr></table></figure>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that both implement one <em>trait</em>, Rust could figure out which implementation of a trait to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are part of traits don’t have a <code>self</code> parameter. When two types in the same scope implement that trait, Rust can’t figure out which type you mean unless you use <em>fully qualified syntax</em>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Animal</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Dog &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"Spot"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Animal <span class="keyword">for</span> Dog &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"puppy"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"A baby dog is called a &#123;&#125;"</span>, Dog::baby_name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A baby dog is called a Spot</span></span><br></pre></td></tr></table></figure>
<p>We want <code>A baby dog is called a puppy</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"A baby dog is called a &#123;&#125;"</span>, Animal::baby_name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0283]: type annotations required: cannot resolve `_: Animal`</span></span><br></pre></td></tr></table></figure>
<p>Because <code>Animal::baby_name</code> is an associated function rather than a method, and thus doesn’t have a <code>self</code> parameter, Rust can’t figure out which implementation of <code>Animal::baby_name</code> we want.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"A baby dog is called a &#123;&#125;"</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::baby_name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A baby dog is called a puppy</span></span><br></pre></td></tr></table></figure>
<p>In general, fully qualified syntax is defined as follows:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::function(receiver_if_method, next_arg, ...);</span><br></pre></td></tr></table></figure>
<p>For associated functions, there would not be a <code>receiver</code>: there would only be the list of other arguments. </p>
<p>You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.</p>
<h4 id="19-2-4-Using-Supertraits-to-Require-One-Trait’s-Functionality-Within-Another-Trait"><a href="#19-2-4-Using-Supertraits-to-Require-One-Trait’s-Functionality-Within-Another-Trait" class="headerlink" title="19-2-4 Using Supertraits to Require One Trait’s Functionality Within Another Trait"></a>19-2-4 Using Supertraits to Require One Trait’s Functionality Within Another Trait</h4><p>Sometimes, you might need one trait to use another trait’s functionality. In this case, you need to rely on the dependent trait also being implemented. The trait you rely on is a <em>supertrait</em> of the trait you’re implementing.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OutlinePrint</span></span>: fmt::Display &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">outline_print</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> output = <span class="keyword">self</span>.to_string();</span><br><span class="line">        <span class="keyword">let</span> len = output.len();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">"*"</span>.repeat(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"*&#123;&#125;*"</span>, <span class="string">" "</span>.repeat(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"* &#123;&#125; *"</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"*&#123;&#125;*"</span>, <span class="string">" "</span>.repeat(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">"*"</span>.repeat(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we can use the <code>to_string</code> function that is automatically implemented for any type that implements <code>Display</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="keyword">i32</span>,</span><br><span class="line">    y: <span class="keyword">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> OutlinePrint <span class="keyword">for</span> Point &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>When we try to implement <code>OutlinePrint</code> on a type that doesn’t implement <code>Display</code>, We get an error saying that <code>Display</code> is required but not implemented.</p>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that <code>OutlinePrint</code> requires:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">"(&#123;&#125;, &#123;&#125;)"</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-2-5-Using-the-Newtype-Pattern-to-Implement-External-Traits-on-External-Types"><a href="#19-2-5-Using-the-Newtype-Pattern-to-Implement-External-Traits-on-External-Types" class="headerlink" title="19-2-5 Using the Newtype Pattern to Implement External Traits on External Types"></a>19-2-5 Using the Newtype Pattern to Implement External Traits on External Types</h4><p>In Chapter 10 in the <a href="https://doc.rust-lang.org/stable/book/ch10-02-traits.html#implementing-a-trait-on-a-type" target="_blank" rel="noopener">“Implementing a Trait on a Type”</a> section, we mentioned the orphan rule that states we’re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It’s possible to get around this restriction using the <em>newtype pattern</em>, which involves creating a new type in a tuple struct. </p>
<p><em>Newtype</em> is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec</code>, which the orphan rule prevents us from doing directly because the <code>Display</code> trait and the <code>Vec</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct that holds an instance of <code>Vec</code>; then we can implement <code>Display</code> on <code>Wrapper</code> and use the <code>Vec</code> value.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span></span>(<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Wrapper &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">"[&#123;&#125;]"</span>, <span class="keyword">self</span>.<span class="number">0</span>.join(<span class="string">", "</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> w = Wrapper(<span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"hello"</span>), <span class="built_in">String</span>::from(<span class="string">"world"</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"w = &#123;&#125;"</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec</code>, because <code>Wrapper</code> is a tuple struct and <code>Vec</code> is the item at index 0 in the tuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it doesn’t have the methods of the value it’s holding. We would have to implement all the methods of <code>Vec</code> directly on <code>Wrapper</code> such that the methods delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a <code>Vec</code>. If we wanted the new type to have every method the inner type has, implementing the <code>Deref</code> trait on the <code>Wrapper</code> to return the inner type would be a solution. </p>
<p>If we don’t want the <code>Wrapper</code> type to have all the methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s behavior—we would have to implement just the methods we do want manually.</p>
<h3 id="19-3-Advanced-Types"><a href="#19-3-Advanced-Types" class="headerlink" title="19-3 Advanced Types"></a>19-3 Advanced Types</h3><h4 id="19-3-1-Using-the-Newtype-Pattern-for-Type-Safety-and-Abstraction"><a href="#19-3-1-Using-the-Newtype-Pattern-for-Type-Safety-and-Abstraction" class="headerlink" title="19-3-1 Using the Newtype Pattern for Type Safety and Abstraction"></a>19-3-1 Using the Newtype Pattern for Type Safety and Abstraction</h4><p>The newtype pattern is useful for tasks beyond those we’ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value.</p>
<p>Another use of the newtype pattern is in abstracting away some implementation details of a type.</p>
<h4 id="19-3-2-Creating-Type-Synonyms-with-Type-Aliases"><a href="#19-3-2-Creating-Type-Synonyms-with-Type-Aliases" class="headerlink" title="19-3-2 Creating Type Synonyms with Type Aliases"></a>19-3-2 Creating Type Synonyms with Type Aliases</h4><p>Along with the newtype pattern, Rust provides the ability to declare a <em>type alias</em> to give an existing type another name. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Kilometers</span></span> = <span class="keyword">i32</span>;</span><br></pre></td></tr></table></figure>
<p>The alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>, it is not a separate, new type.</p>
<p>Using this method, we don’t get the type checking benefits that we get from the newtype pattern discussed earlier.</p>
<p>The main use case for type synonyms is to reduce repetition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f: <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt; = <span class="built_in">Box</span>::new(|| <span class="built_in">println!</span>(<span class="string">"hi"</span>));</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_long_type</span></span>(f: <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt;) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Thunk</span></span> = <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> f: Thunk = <span class="built_in">Box</span>::new(|| <span class="built_in">println!</span>(<span class="string">"hi"</span>));</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_long_type</span></span>(f: Thunk) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Type aliases are also commonly used with the <code>Result</code> type for reducing repetition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Write</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="keyword">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">usize</span>, Error&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">flush</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_all</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="keyword">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_fmt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: fmt::Arguments) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// E filled in as std::io::Error</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, std::io::Error&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Write</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="keyword">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">usize</span>&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">flush</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_all</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="keyword">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_fmt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: Arguments) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because it’s an alias, it’s just another <code>Result</code>, which means we can use any methods that work on <code>Result</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<h4 id="19-3-3-The-Never-Type-that-Never-Returns"><a href="#19-3-3-The-Never-Type-that-Never-Returns" class="headerlink" title="19-3-3 The Never Type that Never Returns"></a>19-3-3 The Never Type that Never Returns</h4><p>Rust has a special type named <code>!</code> that’s known in type theory lingo as the <em>empty type</em> because it has no values. We prefer to call it the <em>never type</em> because it stands in the place of the return type when a function will never return.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>() -&gt; ! &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Functions that return never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code> so <code>bar</code> can never possibly return.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guess: <span class="keyword">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">    <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>match</code> arms must all return the same type, <code>continue</code> has a <code>!</code> value. Because <code>!</code> can never have a value, Rust decides that the type of <code>guess</code> is <code>u32</code>. </p>
<p>The never type is useful with the <code>panic!</code> macro as well.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unwrap</span></span>(<span class="keyword">self</span>) -&gt; T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="literal">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">"called `Option::unwrap()` on a `None` value"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>.</p>
<h4 id="19-3-4-Dynamically-Sized-Types-and-the-Sized-Trait"><a href="#19-3-4-Dynamically-Sized-Types-and-the-Sized-Trait" class="headerlink" title="19-3-4 Dynamically Sized Types and the Sized Trait"></a>19-3-4 Dynamically Sized Types and the <code>Sized</code> Trait</h4><p><em>dynamically sized types</em>. sometimes referred to as <em>DSTs</em> or <em>unsized types</em>, these types let us write code using values whose size we can know only at runtime.</p>
<p><code>str</code> on its own, is a DST. We can’t know how long the string is until runtime, meaning we can’t create a variable of type <code>str</code>, nor can we take an argument of type <code>str</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// does not work</span></span><br><span class="line"><span class="keyword">let</span> s1: <span class="keyword">str</span> = <span class="string">"Hello there!"</span>;</span><br><span class="line"><span class="keyword">let</span> s2: <span class="keyword">str</span> = <span class="string">"How's it going?"</span>;</span><br></pre></td></tr></table></figure>
<p>Rust needs to know how much memory to allocate for any value of a particular type, and all values of a type must use the same amount of memory. If Rust allowed us to write this code, these two <code>str</code> values would need to take up the same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of storage and <code>s2</code> needs 15. This is why it’s not possible to create a variable holding a dynamically sized type.</p>
<p>We make the types of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. The slice data structure stores the starting position and the length of the slice. So although a <code>&amp;T</code> is a single value that stores the memory address of where the <code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its length. The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</p>
<p>Rust has a particular trait called the <code>Sized</code> trait to determine whether or not a type’s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T&gt;(t: T) &#123;&#125;</span><br><span class="line"><span class="comment">// is treated as though we had written</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>By default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>We would read this as “<code>T</code> may or may not be <code>Sized</code>.” This syntax is only available for <code>Sized</code>, not any other traits.</p>
<h3 id="19-4-Advanced-Functions-and-Closures"><a href="#19-4-Advanced-Functions-and-Closures" class="headerlink" title="19-4 Advanced Functions and Closures"></a>19-4 Advanced Functions and Closures</h3><h4 id="19-4-1-Function-Pointers"><a href="#19-4-1-Function-Pointers" class="headerlink" title="19-4-1 Function Pointers"></a>19-4-1 Function Pointers</h4><p>Functions coerce to the type <code>fn</code> (with a lowercase f), not to be confused with the <code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function pointer</em>. The syntax for specifying that a parameter is a function pointer is similar to that of closures.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(x: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_twice</span></span>(f: <span class="function"><span class="keyword">fn</span></span>(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span>, arg: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">    f(arg) + f(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> answer = do_twice(add_one, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The answer is: &#123;&#125;"</span>, answer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the parameter type directly rather than declaring a generic type parameter with one of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>), so you can always pass a function pointer as an argument for a function that expects a closure.</p>
<p>It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</p>
<p>An example of where you would want to only accept <code>fn</code> and not closures is when interfacing with external code that doesn’t have closures: C functions can accept functions as arguments, but C doesn’t have closures.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list_of_numbers = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list_of_strings: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(|i| i.to_string()) <span class="comment">// closure</span></span><br><span class="line">    .collect();</span><br></pre></td></tr></table></figure>
<p>Or name a function as the argument to <code>map</code> instead of the closure:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list_of_numbers = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list_of_strings: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(<span class="built_in">ToString</span>::to_string) <span class="comment">// named function</span></span><br><span class="line">    .collect();</span><br></pre></td></tr></table></figure>
<p>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    Value(<span class="keyword">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list_of_statuses: <span class="built_in">Vec</span>&lt;Status&gt; =</span><br><span class="line">    (<span class="number">0u32</span>..<span class="number">20</span>)</span><br><span class="line">    .map(Status::Value)</span><br><span class="line">    .collect();</span><br></pre></td></tr></table></figure>
<p>Here we create <code>Status::Value</code> instances using each <code>u32</code> value in the range that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>. </p>
<h4 id="19-4-2-Returning-Closures"><a href="#19-4-2-Returning-Closures" class="headerlink" title="19-4-2 Returning Closures"></a>19-4-2 Returning Closures</h4><p>Closures are represented by traits, which means you can’t return closures directly. In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function. But you can’t do that with closures because they don’t have a concrete type that is returnable; you’re not allowed to use the function pointer <code>fn</code> as a return type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_closure</span></span>() -&gt; <span class="built_in">Fn</span>(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">	|x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static: std::marker::Sized` is not satisfied</span></span><br></pre></td></tr></table></figure>
<p>The error references the <code>Sized</code> trait again! Rust doesn’t know how much space it will need to store the closure. </p>
<p>We can use a trait object:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">returns_closure</span></span>() -&gt; <span class="built_in">Box</span>&lt;dyn <span class="built_in">Fn</span>(<span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span>&gt; &#123;</span><br><span class="line">    	<span class="built_in">Box</span>::new(|x| x+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-5-Macros"><a href="#19-5-Macros" class="headerlink" title="19-5 Macros"></a>19-5 Macros</h3><p>The term <em>macro</em> refers to a family of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds of <em>procedural</em> macros:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
<h4 id="19-5-1-The-Difference-Between-Macros-and-Functions"><a href="#19-5-1-The-Difference-Between-Macros-and-Functions" class="headerlink" title="19-5-1 The Difference Between Macros and Functions"></a>19-5-1 The Difference Between Macros and Functions</h4><p>Fundamentally, macros are a way of writing code that writes other code, which is known as <em>metaprogramming</em>. Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t.</p>
<ul>
<li>A function signature must declare the number and type of parameters the function has. Macros can take a variable number of parameters.</li>
<li>Macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.</li>
<li>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. </li>
<li>You must define macros or bring them into scope <em>before</em> you call them in a file, as opposed to functions you can define anywhere and call anywhere.</li>
</ul>
<h4 id="19-5-2-Declarative-Macros-with-macro-rules-for-General-Metaprogramming"><a href="#19-5-2-Declarative-Macros-with-macro-rules-for-General-Metaprogramming" class="headerlink" title="19-5-2 Declarative Macros with macro_rules! for General Metaprogramming"></a>19-5-2 Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</h4><p>The most widely used form of macros in Rust is <em>declarative macros</em>, which allow you to write something similar to a Rust <code>match</code> expression. </p>
<p>Like <code>match</code>, macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="keyword">u32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,];</span><br></pre></td></tr></table></figure>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector of five string slices. We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope.</p>
<p>First, a set of parentheses encompasses the whole pattern. A dollar sign (<code>$</code>) is next, followed by a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any Rust expression and gives the expression the name <code>$x</code>.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character could optionally appear after the code that matches the code in <code>$()</code>. The <code>*</code> specifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p><code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code> in the pattern zero or more times depending on how many times the pattern matches. The <code>$x</code> is replaced with each expression matched. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">temp_vec.push(<span class="number">1</span>);</span><br><span class="line">temp_vec.push(<span class="number">2</span>);</span><br><span class="line">temp_vec.push(<span class="number">3</span>);</span><br><span class="line">temp_vec</span><br></pre></td></tr></table></figure>
<h4 id="19-5-3-Procedural-Macros-for-Generating-Code-from-Attributes"><a href="#19-5-3-Procedural-Macros-for-Generating-Code-from-Attributes" class="headerlink" title="19-5-3 Procedural Macros for Generating Code from Attributes"></a>19-5-3 Procedural Macros for Generating Code from Attributes</h4><p>The second form of macros is <em>procedural macros</em>, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</p>
<p>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</p>
<p>When creating procedural macros, the definitions must reside in their own crate with a special crate type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[some_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">some_name</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>TokenStream</code> type is defined by the <code>proc_macro</code> crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input <code>TokenStream</code>, and the code the macro produces is the output <code>TokenStream</code>. </p>
<h4 id="19-5-4-How-to-Write-a-Custom-derive-Macro"><a href="#19-5-4-How-to-Write-a-Custom-derive-Macro" class="headerlink" title="19-5-4 How to Write a Custom derive Macro"></a>19-5-4 How to Write a Custom <code>derive</code> Macro</h4><p>We’ll provide a procedural macro so users can annotate their type with <code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code> function. </p>
<p>Filename: <code>src/main.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"><span class="keyword">use</span> hello_macro_derive::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(HelloMacro)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pancakes</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    Pancakes::hello_macro();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done. </p>
<p>Step1: make a new library crate: <code>$ cargo new hello_macro --lib</code></p>
<p>Step2: define the <code>HelloMacro</code> trait and its associated function</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">HelloMacro</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here crate user could implement the trait to achieve the desired functionality:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pancakes</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> HelloMacro <span class="keyword">for</span> Pancakes &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hello, Macro! My name is Pancakes!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    Pancakes::hello_macro();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, they would need to write the implementation block for each type they wanted to use with <code>hello_macro</code>.</p>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. We need a macro to generate code at compile time.</p>
<p>Step3: define the procedural macro</p>
<p>Procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named <code>foo</code>, a custom derive procedural macro crate is called <code>foo_derive</code>. Start a new crate <code>hello_macro_derive</code> inside <code>hello_macro</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_macro_derive --lib</span><br></pre></td></tr></table></figure>
<p>The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. </p>
<p>We could instead have the <code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the procedural macro code. However, the way we’ve structured the project makes it possible for programmers to use <code>hello_macro</code> even if they don’t want the <code>derive</code> functionality.</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate. We’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, so we need to add them as dependencies. </p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">"0.14.4"</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">"0.6.3"</span></span><br></pre></td></tr></table></figure>
<p>Filename: <code>hello_macro_derive/src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro_derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="comment">// Construct a representation of Rust code as a syntax tree</span></span><br><span class="line">    <span class="comment">// that we can manipulate</span></span><br><span class="line">    <span class="keyword">let</span> ast = syn::parse(input).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the trait implementation</span></span><br><span class="line">    impl_hello_macro(&amp;ast)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler’s API that allows us to read and manipulate Rust code from our code.</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back into Rust code. </p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we’ve annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and specified the name, <code>HelloMacro</code>, which matches our trait name; this is the convention most procedural macros follow.</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a <code>TokenStream</code> to a data structure that we can then interpret and perform operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in <code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the parsed Rust code.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeriveInput get from parsing the struct Pancakes;</span></span><br><span class="line">DeriveInput &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    ident: Ident &#123;</span><br><span class="line">        ident: <span class="string">"Pancakes"</span>,</span><br><span class="line">        span: #<span class="number">0</span> bytes(<span class="number">95</span>..<span class="number">103</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    data: Struct(</span><br><span class="line">        DataStruct &#123;</span><br><span class="line">            struct_token: Struct,</span><br><span class="line">            fields: Unit,</span><br><span class="line">            semi_token: <span class="literal">Some</span>(</span><br><span class="line">                Semi</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’re calling <code>unwrap</code> to cause the <code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function fails here. It’s necessary for our procedural macro to panic on errors because <code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to conform to the procedural macro API. We’ve simplified this example by using <code>unwrap</code>; in production code, you should provide more specific error messages about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code> into a <code>DeriveInput</code> instance.</p>
<p>Filename: <code>hello_macro_derive/src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">impl_hello_macro</span></span>(ast: &amp;syn::DeriveInput) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> name = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> gen = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> HelloMacro <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Hello, Macro! My name is &#123;&#125;"</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>name</code> variable will contain an <code>Ident</code> struct instance that, when printed, will be the string <code>&quot;Pancakes&quot;</code>.</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the <code>quote!</code> macro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by calling the <code>into</code> method, which consumes this intermediate representation and returns a value of the required <code>TokenStream</code> type.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust expression, such as <code>1 + 2</code>, and at compile time turns the expression into a string literal, such as <code>&quot;1 + 2&quot;</code>. Macros evaluate the expression and then turn the result into a <code>String</code>. There is a possibility that the <code>#name</code> input might be an expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code> and <code>hello_macro_derive</code>. Create a new binary project  <code>cargo new pancakes</code>. Add <code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies. If publishing  to <a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a>, they would be regular dependencies; if not, specify them as <code>path</code> dependencies:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">hello_macro</span> = &#123; path = <span class="string">"../hello_macro"</span> &#125;</span><br><span class="line"><span class="attr">hello_macro_derive</span> = &#123; path = <span class="string">"../hello_macro/hello_macro_derive"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>With the code <em>src/main.rs</em>, run <code>cargo run</code>: it should print <code>Hello, Macro! My name is Pancakes!</code> </p>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/custommacro/" target="_blank" rel="noopener">here</a>.</p>
<h4 id="19-5-5-Attribute-like-macros"><a href="#19-5-5-Attribute-like-macros" class="headerlink" title="19-5-5 Attribute-like macros"></a>19-5-5 Attribute-like macros</h4><p>Attribute-like macros are similar to custom derive macros, but instead of generating code for the <code>derive</code> attribute, they allow you to create new attributes. They’re also more flexible: <code>derive</code> only works for structs and enums; attributes can be applied to other items as well, such as functions.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the contents of the attribute: the <code>GET, &quot;/&quot;</code> part. The second is the body of the item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest of the function’s body.</p>
<h4 id="19-5-6-Function-like-macros"><a href="#19-5-6-Function-like-macros" class="headerlink" title="19-5-6 Function-like macros"></a>19-5-6 Function-like macros</h4><p>Function-like macros define macros that look like function calls. <code>macro_rules!</code> macros can be defined only using the match-like syntax. Function-like macros take a <code>TokenStream</code> parameter and their definition manipulates that <code>TokenStream</code> using Rust code as the other two types of procedural macros do. </p>
<p>An example of a function-like macro is an <code>sql!</code> macro that might be called like so:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sql = sql!(SELECT * FROM posts WHERE id=<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>This macro would parse the SQL statement inside it and check that it’s syntactically correct. The <code>sql!</code> macro would be defined like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sql</span></span>(input: TokenStream) -&gt; TokenStream &#123;&#125;</span><br></pre></td></tr></table></figure>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance/">
    <time datetime="2019-12-03T04:00:00.000Z" class="entry-date">
        2019-12-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/">Rust</a></li></ul>

    </footer>
</article>





  
    <article id="post-KG/2019-12-02-NLM" class="post-KG/2019-12-02-NLM post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2019/12/02/KG/2019-12-02-NLM/">自然语言记忆模块（NLM）</a>
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://www.yam.gift/2019/12/02/KG/2019-12-02-NLM/" data-id="ckggncisp006smtbzhk99ifft" class="leave-reply bdsharebuttonbox" data-cmd="more">undefined</a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>本文主要介绍自然语言的记忆（存储与查询）模块，初衷是作为 chatbot 的 Layer 之一，主要功能是记忆（存储）从对话或训练数据学到的 “知识”，然后在需要时唤起（查询） 。目前成熟的方法是以图数据库作为载体，将知识存储为一系列的 ”节点“ 和 ”关系“。之后再基于这些存储的 ”节点“ 和 ”关系“ 进行相关查询。也可以理解为构建 Data Model 的问题。</p>
<p>项目地址：<a href="https://github.com/hscspring/NLM" target="_blank" rel="noopener">https://github.com/hscspring/NLM</a></p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>图数据库的典型代表是 <a href="http://neo4j.com/" target="_blank" rel="noopener">Neo4j</a>，Neo4j 中有几个很重要的概念：标签、节点和关系。标签是一类节点，可以看作是节点的类别，节点一般是某一个实体；关系存在于两个实体间，可以有多种不同的关系。节点和关系可以有多个属性。实践来看，Python 语言可以使用社区的 <a href="https://github.com/technige/py2neo" target="_blank" rel="noopener">technige/py2neo</a>，当然还可以使用官方的 <a href="https://github.com/neo4j/neo4j-python-driver" target="_blank" rel="noopener">neo4j/neo4j-python-driver: Neo4j Bolt driver for Python</a>，两者的目的都是将数据 import 进 database 并进行相应的查询。</p>
<p>Neo4j 的特点要求导入的数据尽量是结构化的，也就是我们要事先有实体和它的类别（实体的属性可有可无），实体与实体间的关系（关系的属性可有可无）。我们期待能从对话或无监督的语料中自动提取实体和关系，然后自动 import 进 Neo4j。为了避免导入数据的混乱，自然最好能有先验的 “类别”，比如节点类别 Person，Movie 等，关系类别 LOVES，ACTS 等。所以，对于文本输入，我们需要一个信息提取器，将文本中的符合先验类别的节点和关系提取出来。如果输入是 NLU 模块输出的 ”意图和实体“ ，则需要一个分类器，将意图分类到对应的 Relation 类别，将实体分类到 Node 类别。</p>
        
          <p class="article-more-link">
            <a href="/2019/12/02/KG/2019-12-02-NLM/#more" class="more-link">More <span class="meta-nav">→</span></a>
          </p>
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/02/KG/2019-12-02-NLM/">
    <time datetime="2019-12-02T14:00:00.000Z" class="entry-date">
        2019-12-02
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Thinking/">Thinking</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Knowledge-Graph/">Knowledge Graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NLM/">NLM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NLP/">NLP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Neo4j/">Neo4j</a></li></ul>

    </footer>
</article>





  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
      </nav>
    </nav>
  
</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a><span class="category-list-count">54</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Feeling/">Feeling</a><span class="category-list-count">77</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thinking/">Thinking</a><span class="category-list-count">17</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Music</h3>
    <div class="widget-content">
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=541131&auto=0&height=66"></iframe>
      <!-- 评论代码 -->
      <!-- <audio src="http://qnimg.lovevivian.cn/miss.mp3" controls="controls"
             style="width:100%">
        您的浏览器不支持 audio 标签。
      </audio> -->
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/AE/" style="font-size: 10px;">AE</a> <a href="/tags/AI/" style="font-size: 19.09px;">AI</a> <a href="/tags/ALBERT/" style="font-size: 10px;">ALBERT</a> <a href="/tags/AR/" style="font-size: 10px;">AR</a> <a href="/tags/AUC/" style="font-size: 10px;">AUC</a> <a href="/tags/Accuracy/" style="font-size: 10px;">Accuracy</a> <a href="/tags/Activation/" style="font-size: 10px;">Activation</a> <a href="/tags/Algorithm/" style="font-size: 13.64px;">Algorithm</a> <a href="/tags/Array/" style="font-size: 10px;">Array</a> <a href="/tags/Attention/" style="font-size: 12.73px;">Attention</a> <a href="/tags/Automatic-Speech-Processing/" style="font-size: 10px;">Automatic Speech Processing</a> <a href="/tags/BERT/" style="font-size: 12.73px;">BERT</a> <a href="/tags/Backtracking/" style="font-size: 10px;">Backtracking</a> <a href="/tags/Backward/" style="font-size: 10px;">Backward</a> <a href="/tags/Bahdanau-Attention/" style="font-size: 10px;">Bahdanau Attention</a> <a href="/tags/Bart/" style="font-size: 10px;">Bart</a> <a href="/tags/Bayes/" style="font-size: 10px;">Bayes</a> <a href="/tags/Beam-Search/" style="font-size: 10px;">Beam Search</a> <a href="/tags/Bert/" style="font-size: 14.55px;">Bert</a> <a href="/tags/Bert-Flow/" style="font-size: 10px;">Bert-Flow</a> <a href="/tags/Bi-LSTM/" style="font-size: 10px;">Bi-LSTM</a> <a href="/tags/Binary-Search/" style="font-size: 11.82px;">Binary Search</a> <a href="/tags/Blending/" style="font-size: 10px;">Blending</a> <a href="/tags/Business/" style="font-size: 11.82px;">Business</a> <a href="/tags/C/" style="font-size: 10.91px;">C</a> <a href="/tags/CCG/" style="font-size: 10.91px;">CCG</a> <a href="/tags/CFG/" style="font-size: 10px;">CFG</a> <a href="/tags/CKY/" style="font-size: 10px;">CKY</a> <a href="/tags/CNN/" style="font-size: 10px;">CNN</a> <a href="/tags/CRF/" style="font-size: 10px;">CRF</a> <a href="/tags/CYK/" style="font-size: 10px;">CYK</a> <a href="/tags/Calculus/" style="font-size: 10px;">Calculus</a> <a href="/tags/Catalan/" style="font-size: 10px;">Catalan</a> <a href="/tags/ChatBot/" style="font-size: 10px;">ChatBot</a> <a href="/tags/Chi2/" style="font-size: 10px;">Chi2</a> <a href="/tags/Chunking/" style="font-size: 10px;">Chunking</a> <a href="/tags/Classification/" style="font-size: 10px;">Classification</a> <a href="/tags/Cognition/" style="font-size: 10.91px;">Cognition</a> <a href="/tags/Collaborative-Filtering/" style="font-size: 10px;">Collaborative Filtering</a> <a href="/tags/Collins-Parser/" style="font-size: 10px;">Collins Parser</a> <a href="/tags/Computational-Linguistics/" style="font-size: 10px;">Computational Linguistics</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Computer-Science/" style="font-size: 12.73px;">Computer Science</a> <a href="/tags/Confusing-Labels/" style="font-size: 10px;">Confusing Labels</a> <a href="/tags/Context-Free-Grammars/" style="font-size: 10px;">Context-Free Grammars</a> <a href="/tags/Coordinate-Ascent/" style="font-size: 10px;">Coordinate Ascent</a> <a href="/tags/Cosine/" style="font-size: 10.91px;">Cosine</a> <a href="/tags/Cosine-Similarity/" style="font-size: 10px;">Cosine Similarity</a> <a href="/tags/Cross-Entropy/" style="font-size: 10px;">Cross Entropy</a> <a href="/tags/Cross-brackets/" style="font-size: 10px;">Cross-brackets</a> <a href="/tags/Ctrl/" style="font-size: 10px;">Ctrl</a> <a href="/tags/DB/" style="font-size: 10.91px;">DB</a> <a href="/tags/DNN/" style="font-size: 10px;">DNN</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/Data-Clearing/" style="font-size: 10px;">Data Clearing</a> <a href="/tags/Data-Preprocess/" style="font-size: 10px;">Data Preprocess</a> <a href="/tags/Data-Science/" style="font-size: 15.45px;">Data Science</a> <a href="/tags/Data-Structure/" style="font-size: 16.36px;">Data Structure</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/DeBERTa/" style="font-size: 10px;">DeBERTa</a> <a href="/tags/Decoder/" style="font-size: 10px;">Decoder</a> <a href="/tags/Decoding/" style="font-size: 10px;">Decoding</a> <a href="/tags/Deep/" style="font-size: 10px;">Deep</a> <a href="/tags/DeepGraph/" style="font-size: 10px;">DeepGraph</a> <a href="/tags/DeepLearning/" style="font-size: 11.82px;">DeepLearning</a> <a href="/tags/Dependence/" style="font-size: 10px;">Dependence</a> <a href="/tags/Diary/" style="font-size: 10.91px;">Diary</a> <a href="/tags/Disentangled-Attention/" style="font-size: 10px;">Disentangled Attention</a> <a href="/tags/DistilBERT/" style="font-size: 10px;">DistilBERT</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Dynamic-Mask/" style="font-size: 10px;">Dynamic-Mask</a> <a href="/tags/EDA/" style="font-size: 10px;">EDA</a> <a href="/tags/EMD/" style="font-size: 10px;">EMD</a> <a href="/tags/ERNIE/" style="font-size: 10px;">ERNIE</a> <a href="/tags/Economics/" style="font-size: 10px;">Economics</a> <a href="/tags/Edit-Distance/" style="font-size: 10px;">Edit Distance</a> <a href="/tags/Elasticsearch/" style="font-size: 10px;">Elasticsearch</a> <a href="/tags/Electra/" style="font-size: 10px;">Electra</a> <a href="/tags/Elixir/" style="font-size: 10.91px;">Elixir</a> <a href="/tags/Embedding/" style="font-size: 10.91px;">Embedding</a> <a href="/tags/Embeddings/" style="font-size: 10.91px;">Embeddings</a> <a href="/tags/Encoder/" style="font-size: 10px;">Encoder</a> <a href="/tags/Entropy/" style="font-size: 10.91px;">Entropy</a> <a href="/tags/Evaluation/" style="font-size: 10.91px;">Evaluation</a> <a href="/tags/F1/" style="font-size: 10px;">F1</a> <a href="/tags/FDW/" style="font-size: 10px;">FDW</a> <a href="/tags/FSM/" style="font-size: 10px;">FSM</a> <a href="/tags/Feature-Engineering/" style="font-size: 10px;">Feature Engineering</a> <a href="/tags/Feature-based/" style="font-size: 10px;">Feature-based</a> <a href="/tags/Few-Shot/" style="font-size: 10px;">Few-Shot</a> <a href="/tags/Fine-tuning/" style="font-size: 10px;">Fine-tuning</a> <a href="/tags/Formal-Grammars/" style="font-size: 11.82px;">Formal Grammars</a> <a href="/tags/Forward/" style="font-size: 10px;">Forward</a> <a href="/tags/Full-Text-Search/" style="font-size: 10px;">Full-Text-Search</a> <a href="/tags/Function-Syntax/" style="font-size: 10px;">Function Syntax</a> <a href="/tags/Funk-MF/" style="font-size: 10px;">Funk MF</a> <a href="/tags/Funnel-Transformer/" style="font-size: 10px;">Funnel Transformer</a> <a href="/tags/GBTD/" style="font-size: 10px;">GBTD</a> <a href="/tags/GELU/" style="font-size: 10px;">GELU</a> <a href="/tags/GPT-2/" style="font-size: 10px;">GPT-2</a> <a href="/tags/GPU/" style="font-size: 10px;">GPU</a> <a href="/tags/GRU/" style="font-size: 10px;">GRU</a> <a href="/tags/GSG/" style="font-size: 10px;">GSG</a> <a href="/tags/Gan/" style="font-size: 10px;">Gan</a> <a href="/tags/Garden-path/" style="font-size: 10px;">Garden-path</a> <a href="/tags/Glow/" style="font-size: 10px;">Glow</a> <a href="/tags/Graceful-Shutdown/" style="font-size: 10px;">Graceful Shutdown</a> <a href="/tags/Gradient-Descent/" style="font-size: 10px;">Gradient Descent</a> <a href="/tags/Graph/" style="font-size: 10.91px;">Graph</a> <a href="/tags/GraphQL/" style="font-size: 10.91px;">GraphQL</a> <a href="/tags/Grid-Grammar/" style="font-size: 10px;">Grid Grammar</a> <a href="/tags/HMM/" style="font-size: 10.91px;">HMM</a> <a href="/tags/Hard-SVM/" style="font-size: 10px;">Hard-SVM</a> <a href="/tags/Hinge-Loss/" style="font-size: 10px;">Hinge Loss</a> <a href="/tags/IE/" style="font-size: 10px;">IE</a> <a href="/tags/IQR/" style="font-size: 10px;">IQR</a> <a href="/tags/Imbalance-Data/" style="font-size: 10px;">Imbalance Data</a> <a href="/tags/Industry/" style="font-size: 10px;">Industry</a> <a href="/tags/Information-Extraction/" style="font-size: 10px;">Information Extraction</a> <a href="/tags/Information-Theory/" style="font-size: 10px;">Information Theory</a> <a href="/tags/Isolation-Forest/" style="font-size: 10px;">Isolation Forest</a> <a href="/tags/ItemCF/" style="font-size: 10px;">ItemCF</a> <a href="/tags/Jaccard/" style="font-size: 10px;">Jaccard</a> <a href="/tags/Job/" style="font-size: 10px;">Job</a> <a href="/tags/KKT/" style="font-size: 10px;">KKT</a> <a href="/tags/KS/" style="font-size: 10px;">KS</a> <a href="/tags/Kernel/" style="font-size: 10px;">Kernel</a> <a href="/tags/Kernel-Function/" style="font-size: 10px;">Kernel Function</a> <a href="/tags/Kernel-Method/" style="font-size: 10px;">Kernel Method</a> <a href="/tags/Keyword/" style="font-size: 10px;">Keyword</a> <a href="/tags/Knowledge-Graph/" style="font-size: 10.91px;">Knowledge Graph</a> <a href="/tags/LM/" style="font-size: 10.91px;">LM</a> <a href="/tags/LOF/" style="font-size: 10px;">LOF</a> <a href="/tags/LR/" style="font-size: 10px;">LR</a> <a href="/tags/LSTM/" style="font-size: 10px;">LSTM</a> <a href="/tags/Language-Model/" style="font-size: 10.91px;">Language Model</a> <a href="/tags/Lexical-Semantics/" style="font-size: 10px;">Lexical Semantics</a> <a href="/tags/Lexicalism/" style="font-size: 10px;">Lexicalism</a> <a href="/tags/Lexicalized-CFG/" style="font-size: 10px;">Lexicalized CFG</a> <a href="/tags/Lexicalized-Grammars/" style="font-size: 10px;">Lexicalized Grammars</a> <a href="/tags/Linear-Algebra/" style="font-size: 10px;">Linear Algebra</a> <a href="/tags/Linear-Sturcture/" style="font-size: 10px;">Linear Sturcture</a> <a href="/tags/Linked-List/" style="font-size: 10px;">Linked List</a> <a href="/tags/LinkedList/" style="font-size: 10.91px;">LinkedList</a> <a href="/tags/Logistic-Regression/" style="font-size: 10px;">Logistic Regression</a> <a href="/tags/Lucene/" style="font-size: 10px;">Lucene</a> <a href="/tags/Luong-Attention/" style="font-size: 10px;">Luong Attention</a> <a href="/tags/MEMM/" style="font-size: 10px;">MEMM</a> <a href="/tags/MF/" style="font-size: 10px;">MF</a> <a href="/tags/Machine/" style="font-size: 10px;">Machine</a> <a href="/tags/Machine-Learning/" style="font-size: 15.45px;">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 10px;">Machine Translation</a> <a href="/tags/Manacher/" style="font-size: 10px;">Manacher</a> <a href="/tags/Managemnt/" style="font-size: 11.82px;">Managemnt</a> <a href="/tags/Markov/" style="font-size: 10px;">Markov</a> <a href="/tags/Materialized-Views/" style="font-size: 10px;">Materialized Views</a> <a href="/tags/Math/" style="font-size: 10.91px;">Math</a> <a href="/tags/Matplotlib/" style="font-size: 10px;">Matplotlib</a> <a href="/tags/Matrix-Factorization/" style="font-size: 10px;">Matrix Factorization</a> <a href="/tags/Median/" style="font-size: 10px;">Median</a> <a href="/tags/Metric/" style="font-size: 10px;">Metric</a> <a href="/tags/Minimum-Edit-Distance/" style="font-size: 10px;">Minimum Edit Distance</a> <a href="/tags/Minkowski/" style="font-size: 10px;">Minkowski</a> <a href="/tags/Model-Evaluation/" style="font-size: 10px;">Model Evaluation</a> <a href="/tags/Module/" style="font-size: 10px;">Module</a> <a href="/tags/Multi-Head-Attention/" style="font-size: 10px;">Multi-Head Attention</a> <a href="/tags/Multiway-Tree/" style="font-size: 10px;">Multiway Tree</a> <a href="/tags/NER/" style="font-size: 10.91px;">NER</a> <a href="/tags/NLG/" style="font-size: 10px;">NLG</a> <a href="/tags/NLM/" style="font-size: 10px;">NLM</a> <a href="/tags/NLP/" style="font-size: 20px;">NLP</a> <a href="/tags/NLU/" style="font-size: 10px;">NLU</a> <a href="/tags/Naive-Bayes/" style="font-size: 10px;">Naive Bayes</a> <a href="/tags/Neo4j/" style="font-size: 10px;">Neo4j</a> <a href="/tags/Ngram/" style="font-size: 10.91px;">Ngram</a> <a href="/tags/Normalizing-Flow/" style="font-size: 10px;">Normalizing Flow</a> <a href="/tags/NumPy/" style="font-size: 10px;">NumPy</a> <a href="/tags/Occupation/" style="font-size: 10px;">Occupation</a> <a href="/tags/Orientation/" style="font-size: 10px;">Orientation</a> <a href="/tags/P-R/" style="font-size: 10px;">P-R</a> <a href="/tags/PCCG/" style="font-size: 10px;">PCCG</a> <a href="/tags/PCFG/" style="font-size: 10px;">PCFG</a> <a href="/tags/PEGASUS/" style="font-size: 10px;">PEGASUS</a> <a href="/tags/PPMI/" style="font-size: 10px;">PPMI</a> <a href="/tags/PageRank/" style="font-size: 10px;">PageRank</a> <a href="/tags/Palindromic/" style="font-size: 10px;">Palindromic</a> <a href="/tags/Pandas/" style="font-size: 10px;">Pandas</a> <a href="/tags/Partial-Parsing/" style="font-size: 10px;">Partial Parsing</a> <a href="/tags/Pearson/" style="font-size: 10px;">Pearson</a> <a href="/tags/Philosophy/" style="font-size: 10.91px;">Philosophy</a> <a href="/tags/Phrase-Structure-Grammar/" style="font-size: 10px;">Phrase Structure Grammar</a> <a href="/tags/Phrase-Structure-Grammars/" style="font-size: 10px;">Phrase Structure Grammars</a> <a href="/tags/PoS/" style="font-size: 10px;">PoS</a> <a href="/tags/Pooling/" style="font-size: 10px;">Pooling</a> <a href="/tags/Position-Encoding/" style="font-size: 10px;">Position-Encoding</a> <a href="/tags/Postgres/" style="font-size: 10.91px;">Postgres</a> <a href="/tags/Pragmatic-Automatic-Processing/" style="font-size: 10px;">Pragmatic Automatic Processing</a> <a href="/tags/Pre-training/" style="font-size: 10.91px;">Pre-training</a> <a href="/tags/Precision/" style="font-size: 10px;">Precision</a> <a href="/tags/Pretraining/" style="font-size: 10.91px;">Pretraining</a> <a href="/tags/Probabilistic-Grammar/" style="font-size: 10px;">Probabilistic Grammar</a> <a href="/tags/Probabilistic-Model/" style="font-size: 10px;">Probabilistic Model</a> <a href="/tags/ProtoBERT/" style="font-size: 10px;">ProtoBERT</a> <a href="/tags/Psychology/" style="font-size: 10.91px;">Psychology</a> <a href="/tags/PyPI/" style="font-size: 10px;">PyPI</a> <a href="/tags/Python/" style="font-size: 18.18px;">Python</a> <a href="/tags/Quant/" style="font-size: 10px;">Quant</a> <a href="/tags/Query/" style="font-size: 10px;">Query</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/RELU/" style="font-size: 10px;">RELU</a> <a href="/tags/RFE/" style="font-size: 10px;">RFE</a> <a href="/tags/RMSE/" style="font-size: 10px;">RMSE</a> <a href="/tags/RNN/" style="font-size: 10px;">RNN</a> <a href="/tags/ROC/" style="font-size: 10px;">ROC</a> <a href="/tags/Recall/" style="font-size: 10px;">Recall</a> <a href="/tags/Recommendation/" style="font-size: 13.64px;">Recommendation</a> <a href="/tags/Recursion/" style="font-size: 10.91px;">Recursion</a> <a href="/tags/Reformer/" style="font-size: 10px;">Reformer</a> <a href="/tags/Regex/" style="font-size: 10px;">Regex</a> <a href="/tags/Regular-Expression/" style="font-size: 10px;">Regular Expression</a> <a href="/tags/Reinforcement-Learning/" style="font-size: 10px;">Reinforcement Learning</a> <a href="/tags/Relationship-Extraction/" style="font-size: 10px;">Relationship Extraction</a> <a href="/tags/Representation/" style="font-size: 10px;">Representation</a> <a href="/tags/Reqular-Expressions/" style="font-size: 10px;">Reqular Expressions</a> <a href="/tags/RoBERTa/" style="font-size: 10px;">RoBERTa</a> <a href="/tags/Rotated-Sorted-Array/" style="font-size: 10px;">Rotated Sorted Array</a> <a href="/tags/Rust/" style="font-size: 14.55px;">Rust</a> <a href="/tags/SCFG/" style="font-size: 10px;">SCFG</a> <a href="/tags/SGD/" style="font-size: 10px;">SGD</a> <a href="/tags/SMO/" style="font-size: 10px;">SMO</a> <a href="/tags/SQL/" style="font-size: 10.91px;">SQL</a> <a href="/tags/SRN/" style="font-size: 10px;">SRN</a> <a href="/tags/SVD/" style="font-size: 10px;">SVD++</a> <a href="/tags/SVM/" style="font-size: 10.91px;">SVM</a> <a href="/tags/Seaborn/" style="font-size: 10px;">Seaborn</a> <a href="/tags/Search/" style="font-size: 10.91px;">Search</a> <a href="/tags/Segmentation/" style="font-size: 10px;">Segmentation</a> <a href="/tags/Self-Attention/" style="font-size: 11.82px;">Self-Attention</a> <a href="/tags/Semantic-Automatic-Processing/" style="font-size: 10px;">Semantic Automatic Processing</a> <a href="/tags/Semantic-Similarity/" style="font-size: 10px;">Semantic Similarity</a> <a href="/tags/Sentence-Similarity/" style="font-size: 10px;">Sentence Similarity</a> <a href="/tags/Sentence-BERT/" style="font-size: 10px;">Sentence-BERT</a> <a href="/tags/Sentiment-Classification/" style="font-size: 10px;">Sentiment Classification</a> <a href="/tags/Siamese/" style="font-size: 10px;">Siamese</a> <a href="/tags/Sigmoid/" style="font-size: 10px;">Sigmoid</a> <a href="/tags/Similarity/" style="font-size: 10px;">Similarity</a> <a href="/tags/Simon/" style="font-size: 10px;">Simon</a> <a href="/tags/Simpson-Paradox/" style="font-size: 10px;">Simpson Paradox</a> <a href="/tags/Skill/" style="font-size: 10px;">Skill</a> <a href="/tags/Slide/" style="font-size: 10px;">Slide</a> <a href="/tags/Smoothing/" style="font-size: 10.91px;">Smoothing</a> <a href="/tags/Soft-SVM/" style="font-size: 10px;">Soft-SVM</a> <a href="/tags/Softmax/" style="font-size: 10px;">Softmax</a> <a href="/tags/Sort/" style="font-size: 10.91px;">Sort</a> <a href="/tags/Spell-Check/" style="font-size: 10px;">Spell Check</a> <a href="/tags/SqueezeBERT/" style="font-size: 10px;">SqueezeBERT</a> <a href="/tags/Stack/" style="font-size: 10px;">Stack</a> <a href="/tags/Stacking/" style="font-size: 10px;">Stacking</a> <a href="/tags/Statistics/" style="font-size: 10px;">Statistics</a> <a href="/tags/Stirling/" style="font-size: 10px;">Stirling</a> <a href="/tags/StratifiedKFold/" style="font-size: 10px;">StratifiedKFold</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/Style/" style="font-size: 10px;">Style</a> <a href="/tags/Substring/" style="font-size: 10px;">Substring</a> <a href="/tags/Summarization/" style="font-size: 10px;">Summarization</a> <a href="/tags/Supertagging/" style="font-size: 10px;">Supertagging</a> <a href="/tags/Swap/" style="font-size: 10px;">Swap</a> <a href="/tags/System/" style="font-size: 10.91px;">System</a> <a href="/tags/TF-IDF/" style="font-size: 10px;">TF-IDF</a> <a href="/tags/Tagging/" style="font-size: 10px;">Tagging</a> <a href="/tags/TanH/" style="font-size: 10px;">TanH</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Text-Generation/" style="font-size: 10px;">Text Generation</a> <a href="/tags/Text-Normalization/" style="font-size: 10px;">Text Normalization</a> <a href="/tags/TextRank/" style="font-size: 10px;">TextRank</a> <a href="/tags/Thought/" style="font-size: 10px;">Thought</a> <a href="/tags/Transformer/" style="font-size: 17.27px;">Transformer</a> <a href="/tags/Transformer-XL/" style="font-size: 10px;">Transformer-XL</a> <a href="/tags/Tree/" style="font-size: 10px;">Tree</a> <a href="/tags/Treebank/" style="font-size: 10px;">Treebank</a> <a href="/tags/Tuning/" style="font-size: 10px;">Tuning</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/Unity-Operation/" style="font-size: 10px;">Unity Operation</a> <a href="/tags/UserCF/" style="font-size: 10px;">UserCF</a> <a href="/tags/Vagrant/" style="font-size: 10px;">Vagrant</a> <a href="/tags/Valence/" style="font-size: 10px;">Valence</a> <a href="/tags/Vector-Semantics/" style="font-size: 10px;">Vector Semantics</a> <a href="/tags/VirtualBox/" style="font-size: 10px;">VirtualBox</a> <a href="/tags/Visualization/" style="font-size: 10px;">Visualization</a> <a href="/tags/Viterbi/" style="font-size: 10.91px;">Viterbi</a> <a href="/tags/Voting/" style="font-size: 10px;">Voting</a> <a href="/tags/WOE/" style="font-size: 10px;">WOE</a> <a href="/tags/Web-Server-Multithreaded-Server/" style="font-size: 10px;">Web Server Multithreaded Server</a> <a href="/tags/Wide/" style="font-size: 10px;">Wide</a> <a href="/tags/Word2vec/" style="font-size: 10px;">Word2vec</a> <a href="/tags/Work/" style="font-size: 10px;">Work</a> <a href="/tags/XLNet/" style="font-size: 10px;">XLNet</a> <a href="/tags/Z-Score/" style="font-size: 10px;">Z-Score</a> <a href="/tags/ZhouZhihua/" style="font-size: 10px;">ZhouZhihua</a> <a href="/tags/Zipf/" style="font-size: 10px;">Zipf</a> <a href="/tags/binning/" style="font-size: 10px;">binning</a> <a href="/tags/few-shot/" style="font-size: 10px;">few-shot</a> <a href="/tags/knowledge-Graph/" style="font-size: 10px;">knowledge Graph</a> <a href="/tags/node2vec/" style="font-size: 10px;">node2vec</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2021/06/06/Paper/2021-06-06-ProtoBERT/">Few-Shot NER and BERT Noisy Learning：ProtoBERT Paper Note</a>
          </li>
        
          <li>
            <a href="/2021/05/22/Paper/2021-05-22-BERTology/">深度探索 Bert：BERTology Paper Note</a>
          </li>
        
          <li>
            <a href="/2021/02/19/ExpSum/2021-02-19-AI-Engineer-Growing-I/">AI 工程师养成记（上）</a>
          </li>
        
          <li>
            <a href="/2021/01/17/Paper/2021-01-17-SqueezeBERT/">SqueezeBERT 论文笔记</a>
          </li>
        
          <li>
            <a href="/2020/12/27/Paper/2020-12-27-Sentence-Bert/">从 Sentence-BERT 谈句子表征</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AE/">AE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a><span class="tag-list-count">49</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ALBERT/">ALBERT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AR/">AR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AUC/">AUC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Accuracy/">Accuracy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activation/">Activation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/">Array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Attention/">Attention</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Automatic-Speech-Processing/">Automatic Speech Processing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BERT/">BERT</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backtracking/">Backtracking</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backward/">Backward</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bahdanau-Attention/">Bahdanau Attention</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bart/">Bart</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bayes/">Bayes</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Beam-Search/">Beam Search</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bert/">Bert</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bert-Flow/">Bert-Flow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bi-LSTM/">Bi-LSTM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binary-Search/">Binary Search</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blending/">Blending</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Business/">Business</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCG/">CCG</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CFG/">CFG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CKY/">CKY</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CNN/">CNN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CRF/">CRF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CYK/">CYK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Calculus/">Calculus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Catalan/">Catalan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChatBot/">ChatBot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chi2/">Chi2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chunking/">Chunking</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Classification/">Classification</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cognition/">Cognition</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collaborative-Filtering/">Collaborative Filtering</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collins-Parser/">Collins Parser</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computational-Linguistics/">Computational Linguistics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/">Computer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Science/">Computer Science</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Confusing-Labels/">Confusing Labels</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Context-Free-Grammars/">Context-Free Grammars</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coordinate-Ascent/">Coordinate Ascent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cosine/">Cosine</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cosine-Similarity/">Cosine Similarity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cross-Entropy/">Cross Entropy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cross-brackets/">Cross-brackets</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ctrl/">Ctrl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/">DB</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNN/">DNN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Clearing/">Data Clearing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Preprocess/">Data Preprocess</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Science/">Data Science</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/">Data Structure</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DeBERTa/">DeBERTa</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Decoder/">Decoder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Decoding/">Decoding</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deep/">Deep</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DeepGraph/">DeepGraph</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DeepLearning/">DeepLearning</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dependence/">Dependence</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Diary/">Diary</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Disentangled-Attention/">Disentangled Attention</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DistilBERT/">DistilBERT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/">Django</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dynamic-Mask/">Dynamic-Mask</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EDA/">EDA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EMD/">EMD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ERNIE/">ERNIE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Economics/">Economics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Edit-Distance/">Edit Distance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elasticsearch/">Elasticsearch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Electra/">Electra</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elixir/">Elixir</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedding/">Embedding</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embeddings/">Embeddings</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Encoder/">Encoder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Entropy/">Entropy</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Evaluation/">Evaluation</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/F1/">F1</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FDW/">FDW</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FSM/">FSM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feature-Engineering/">Feature Engineering</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feature-based/">Feature-based</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Few-Shot/">Few-Shot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fine-tuning/">Fine-tuning</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Formal-Grammars/">Formal Grammars</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Forward/">Forward</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Full-Text-Search/">Full-Text-Search</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Function-Syntax/">Function Syntax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Funk-MF/">Funk MF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Funnel-Transformer/">Funnel Transformer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GBTD/">GBTD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GELU/">GELU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPT-2/">GPT-2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPU/">GPU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GRU/">GRU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GSG/">GSG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gan/">Gan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Garden-path/">Garden-path</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glow/">Glow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graceful-Shutdown/">Graceful Shutdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradient-Descent/">Gradient Descent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/">Graph</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GraphQL/">GraphQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Grid-Grammar/">Grid Grammar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HMM/">HMM</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hard-SVM/">Hard-SVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hinge-Loss/">Hinge Loss</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IE/">IE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IQR/">IQR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Imbalance-Data/">Imbalance Data</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Industry/">Industry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Information-Extraction/">Information Extraction</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Information-Theory/">Information Theory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Isolation-Forest/">Isolation Forest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ItemCF/">ItemCF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jaccard/">Jaccard</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Job/">Job</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KKT/">KKT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KS/">KS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel/">Kernel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel-Function/">Kernel Function</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel-Method/">Kernel Method</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Keyword/">Keyword</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Knowledge-Graph/">Knowledge Graph</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LM/">LM</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LOF/">LOF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LR/">LR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LSTM/">LSTM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Language-Model/">Language Model</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lexical-Semantics/">Lexical Semantics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lexicalism/">Lexicalism</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lexicalized-CFG/">Lexicalized CFG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lexicalized-Grammars/">Lexicalized Grammars</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linear-Algebra/">Linear Algebra</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linear-Sturcture/">Linear Sturcture</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linked-List/">Linked List</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/">LinkedList</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Logistic-Regression/">Logistic Regression</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lucene/">Lucene</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Luong-Attention/">Luong Attention</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MEMM/">MEMM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MF/">MF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine/">Machine</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Translation/">Machine Translation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Manacher/">Manacher</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Managemnt/">Managemnt</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markov/">Markov</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Materialized-Views/">Materialized Views</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matplotlib/">Matplotlib</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matrix-Factorization/">Matrix Factorization</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Median/">Median</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metric/">Metric</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Minimum-Edit-Distance/">Minimum Edit Distance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Minkowski/">Minkowski</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Model-Evaluation/">Model Evaluation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Module/">Module</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Multi-Head-Attention/">Multi-Head Attention</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Multiway-Tree/">Multiway Tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NER/">NER</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLG/">NLG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLM/">NLM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/">NLP</a><span class="tag-list-count">68</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLU/">NLU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Naive-Bayes/">Naive Bayes</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Neo4j/">Neo4j</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ngram/">Ngram</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Normalizing-Flow/">Normalizing Flow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NumPy/">NumPy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Occupation/">Occupation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Orientation/">Orientation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/P-R/">P-R</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PCCG/">PCCG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PCFG/">PCFG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEGASUS/">PEGASUS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PPMI/">PPMI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PageRank/">PageRank</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Palindromic/">Palindromic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pandas/">Pandas</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Partial-Parsing/">Partial Parsing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pearson/">Pearson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Philosophy/">Philosophy</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Phrase-Structure-Grammar/">Phrase Structure Grammar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Phrase-Structure-Grammars/">Phrase Structure Grammars</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PoS/">PoS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pooling/">Pooling</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Position-Encoding/">Position-Encoding</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgres/">Postgres</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pragmatic-Automatic-Processing/">Pragmatic Automatic Processing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pre-training/">Pre-training</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Precision/">Precision</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pretraining/">Pretraining</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probabilistic-Grammar/">Probabilistic Grammar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Probabilistic-Model/">Probabilistic Model</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ProtoBERT/">ProtoBERT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Psychology/">Psychology</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyPI/">PyPI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quant/">Quant</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Query/">Query</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Queue/">Queue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RELU/">RELU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RFE/">RFE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RMSE/">RMSE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RNN/">RNN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROC/">ROC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recall/">Recall</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recommendation/">Recommendation</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recursion/">Recursion</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reformer/">Reformer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regex/">Regex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regular-Expression/">Regular Expression</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reinforcement-Learning/">Reinforcement Learning</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Relationship-Extraction/">Relationship Extraction</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Representation/">Representation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reqular-Expressions/">Reqular Expressions</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RoBERTa/">RoBERTa</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rotated-Sorted-Array/">Rotated Sorted Array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/">Rust</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCFG/">SCFG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SGD/">SGD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SMO/">SMO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SRN/">SRN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVD/">SVD++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVM/">SVM</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seaborn/">Seaborn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Search/">Search</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Segmentation/">Segmentation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Self-Attention/">Self-Attention</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Semantic-Automatic-Processing/">Semantic Automatic Processing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Semantic-Similarity/">Semantic Similarity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentence-Similarity/">Sentence Similarity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentence-BERT/">Sentence-BERT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentiment-Classification/">Sentiment Classification</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Siamese/">Siamese</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sigmoid/">Sigmoid</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Similarity/">Similarity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Simon/">Simon</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Simpson-Paradox/">Simpson Paradox</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Skill/">Skill</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slide/">Slide</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Smoothing/">Smoothing</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Soft-SVM/">Soft-SVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Softmax/">Softmax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spell-Check/">Spell Check</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SqueezeBERT/">SqueezeBERT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack/">Stack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stacking/">Stacking</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Statistics/">Statistics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stirling/">Stirling</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/StratifiedKFold/">StratifiedKFold</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Style/">Style</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Substring/">Substring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Summarization/">Summarization</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Supertagging/">Supertagging</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swap/">Swap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/System/">System</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TF-IDF/">TF-IDF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tagging/">Tagging</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TanH/">TanH</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/">Test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Text-Generation/">Text Generation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Text-Normalization/">Text Normalization</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TextRank/">TextRank</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thought/">Thought</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transformer/">Transformer</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transformer-XL/">Transformer-XL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/">Tree</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Treebank/">Treebank</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tuning/">Tuning</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-Operation/">Unity Operation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UserCF/">UserCF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vagrant/">Vagrant</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Valence/">Valence</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vector-Semantics/">Vector Semantics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VirtualBox/">VirtualBox</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Visualization/">Visualization</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Viterbi/">Viterbi</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Voting/">Voting</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WOE/">WOE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-Server-Multithreaded-Server/">Web Server Multithreaded Server</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wide/">Wide</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Word2vec/">Word2vec</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Work/">Work</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XLNet/">XLNet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Z-Score/">Z-Score</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZhouZhihua/">ZhouZhihua</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zipf/">Zipf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binning/">binning</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/few-shot/">few-shot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/knowledge-Graph/">knowledge Graph</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node2vec/">node2vec</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2021 Yam
    All rights reserved.</p>
    <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p>
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <!-- <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> -->
    <!-- <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span> -->
    <!-- <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span> -->

</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
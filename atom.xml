<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yam</title>
  
  <subtitle>Feeling, Coding, Thinking</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yam.gift/"/>
  <updated>2019-12-28T08:56:49.711Z</updated>
  <id>https://www.yam.gift/</id>
  
  <author>
    <name>Yam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Neural Architectures for Named Entity Recognition Note</title>
    <link href="https://www.yam.gift/2019/12/28/Paper/2019-12-28-Neural-Architectures-for-Named-Entity-Recognition/"/>
    <id>https://www.yam.gift/2019/12/28/Paper/2019-12-28-Neural-Architectures-for-Named-Entity-Recognition/</id>
    <published>2019-12-28T09:00:00.000Z</published>
    <updated>2019-12-28T08:56:49.711Z</updated>
    
    <content type="html"><![CDATA[<p>Paper: <a href="https://arxiv.org/pdf/1603.01360.pdf" target="_blank" rel="noopener">1603.01360.pdf</a></p><p>code: </p><ul><li><p><a href="https://github.com/clab/stack-lstm-ner" target="_blank" rel="noopener">clab/stack-lstm-ner: NER system based on stack LSTMs</a></p></li><li><p><a href="https://github.com/glample/tagger" target="_blank" rel="noopener">glample/tagger: Named Entity Recognition Tool</a></p></li></ul><p>核心思想：pretrained + character-based 词表示分别学习形态和拼写，Bi-LSTM + CRF 和基于转移的模型均可以对输出标签的依赖关系建模。</p><p>看了 Related Work 后发现很多想法其实早就冒出来了，不同的论文在不同点上使用了不同的方法，本篇恰好用这样的方法取得了最好的效果。其实，我觉得更加有意思的是基于转移的模型，它构建了一个 action 的时间序列，感觉更加抽象，想法更加精妙。</p><a id="more"></a><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>传统命名实体识别依赖人工设计特征和和领域知识。本文提出两种架构：</p><ul><li>Bi-LSTM + CRF</li><li>transition-based 方法构建和标注分割</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>NER 的挑战性：</p><ul><li>大多数领域只有少量标注数据</li><li>实体的词几乎毫无限制，要从一个小数据集泛化太难</li></ul><p>人工设计特征和领域知识在实际中使用广泛，但太耗时且很难迁移；无监督一般又是作为有监督的补充。本文提出的架构与语言和特征无关，模型被设计用来获取两个直觉：</p><ul><li>实体经常由多个 token 组成，对每个 token 的 tag 进行联合推理很重要。对比了 Bi-LSTM +CRF 和一个新模型（使用了一种灵感来自基于堆栈 LSTM 表示的 transition-based 算法来构造和标记输入句子的 chunks）。</li><li>实体 token 级别的证据既包括拼写（被标记的单词看起来像什么），也包括分布证据（被标记的单词倾向于出现在语料中哪里）。使用了字符级别的词表示和分布表示。</li></ul><h2 id="LSTM-CRF-Model"><a href="#LSTM-CRF-Model" class="headerlink" title="LSTM-CRF Model"></a>LSTM-CRF Model</h2><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>这里的 LSTM 和我们平时见的稍微不一样：</p><script type="math/tex; mode=display">\begin{aligned} \mathbf{i}_{t}=& \sigma\left(\mathbf{W}_{x i} \mathbf{x}_{t}+\mathbf{W}_{h i} \mathbf{h}_{t-1}+\mathbf{W}_{c i} \mathbf{c}_{t-1}+\mathbf{b}_{i}\right) \\ \mathbf{c}_{t}=&\left(1-\mathbf{i}_{t}\right) \odot \mathbf{c}_{t-1}+\\ & \mathbf{i}_{t} \odot \tanh \left(\mathbf{W}_{x c} \mathbf{x}_{t}+\mathbf{W}_{h c} \mathbf{h}_{t-1}+\mathbf{b}_{c}\right) \\ \mathbf{o}_{t}=& \sigma\left(\mathbf{W}_{x o} \mathbf{x}_{t}+\mathbf{W}_{h o} \mathbf{h}_{t-1}+\mathbf{W}_{c o} \mathbf{c}_{t}+\mathbf{b}_{o}\right) \\ \mathbf{h}_{t}=\mathbf{o}_{t} \odot \tanh \left(\mathbf{c}_{t}\right) \end{aligned}</script><p>它的更新有点像 GRU，输出像 LSTM。</p><h3 id="CRF-Tagging-Models"><a href="#CRF-Tagging-Models" class="headerlink" title="CRF Tagging Models"></a>CRF Tagging Models</h3><p>NER 任务的标签之间相互不独立，CRF 比较合适：</p><ul><li><p>给定句子序列：X = (x1, …, xn)</p></li><li><p>P 是 Bi-LSTM 的输出矩阵，n×k，k 是不同 tags 的数量，Pij 表示给定句子第 i 个 token 是第 j 个 tag 的分数</p></li><li><p>对预测序列：y = (y1, …, yn)，score 定义如下：</p><script type="math/tex; mode=display">  s(\mathbf{X}, \mathbf{y})=\sum_{i=0}^{n} A_{y_{i}, y_{i+1}}+\sum_{i=1}^{n} P_{i, y_{i}}</script><p>  A 是转移分数，Aij 表示 tag i 转移到 tag j 的分数</p></li><li><p>softmax</p><script type="math/tex; mode=display">  p(\mathbf{y} | \mathbf{X})=\frac{e^{s(\mathbf{X}, \mathbf{y})}}{\sum_{\tilde{\mathbf{Y}} \in \mathbf{Y}_{\mathbf{X}}} e^{s(\mathbf{X}, \widetilde{\mathbf{y}})}}</script></li><li><p>loss function</p><script type="math/tex; mode=display">  \begin{aligned} \log (p(\mathbf{y} | \mathbf{X})) &=s(\mathbf{X}, \mathbf{y})-\log \left(\sum_{\widetilde{\mathbf{y}} \in \mathbf{Y}_{\mathbf{X}}} e^{s(\mathbf{X}, \widetilde{\mathbf{y}})}\right) \\ &=s(\mathbf{X}, \mathbf{y})-\underset{\tilde{\mathbf{y}} \in \mathbf{Y}_{\mathbf{X}}}{\operatorname{logadd}} s(\mathbf{X}, \widetilde{\mathbf{y}}) \end{aligned}</script><p>  Yx 表示输入句子 X 所有可能的 tag 序列</p></li><li><p>decoding</p><script type="math/tex; mode=display">  \mathbf{y}^{*}=\underset{\tilde{\mathbf{y}} \in \mathbf{Y}_{\mathbf{X}}}{\operatorname{argmax}} s(\mathbf{X}, \widetilde{\mathbf{y}})</script></li></ul><h3 id="Parameterization-and-Training"><a href="#Parameterization-and-Training" class="headerlink" title="Parameterization and Training"></a>Parameterization and Training</h3><p><img src="http://qnimg.lovevivian.cn/paper-neural-architectures-for-ner-1.jpeg" alt=""></p><p>A 和 P 就是参数，c 和 CRF 层加一层能提升效果。训练就是最大化 loss function。</p><h3 id="Tagging-Schemes"><a href="#Tagging-Schemes" class="headerlink" title="Tagging Schemes"></a>Tagging Schemes</h3><p>没有用常规的 IOB，而是用了 IOBES，IOB 和常规的一样，S 表示一个 token 是一个实体，E 表示实体的结尾。不过并没有发现比 IOB 有明显的改善。</p><h2 id="Transition-Based-Chunking-Model"><a href="#Transition-Based-Chunking-Model" class="headerlink" title="Transition-Based Chunking Model"></a>Transition-Based Chunking Model</h2><p>这个模型直接对多个 token 的实体构建表示，它依赖 stack 数据结构来增量构造输入块（chunks）。使用了 Stack-LSTM（LSTM + 栈指针）架构，它允许 embedding 一个栈的对象（push 和 pop），看起来就像一个维持对内容 summary embedding 的栈。</p><p>关于 Stack-LSTM 的论文：<a href="https://www.aclweb.org/anthology/P15-1033/" target="_blank" rel="noopener">Transition-Based Dependency Parsing with Stack Long Short-Term Memory - ACL Anthology</a>。</p><h3 id="Chunking-Algorithm"><a href="#Chunking-Algorithm" class="headerlink" title="Chunking Algorithm"></a>Chunking Algorithm</h3><p><img src="http://qnimg.lovevivian.cn/paper-neural-architectures-for-ner-2.jpeg" alt=""></p><ul><li><p>两个 stack：output 和 stack，分别表示已完成的 chunks 和暂存空间</p></li><li><p>一个 buffer：包含将要处理的词</p></li></ul><p>包括下面的转移：</p><ul><li>SHIFT 将 word 从 buffer 移动到 stack</li><li>OUT 将 word 从 buffer 移动到 output stack：REDUCE(y) 从栈顶 pop 所有的 item 生成一个 “chunk”，标记为 label y，然后 push 一个这个 chunk 的表示到 output stack。</li></ul><p><img src="http://qnimg.lovevivian.cn/paper-neural-architectures-for-ner-3.jpeg" alt=""></p><p>给定 content 的 stack，buffer 和 output，以及历史 action，针对每一个 time step 上 action 的分布建模。</p><p>具体而言，每一个 action 都计算一个固定维度的 embedding，然后 concat 后获得完整的状态表示，这个表示用于定义每个 time step 可能采取的行动分布。模型就是最大化给定输入句子参考 action 序列（从标记语料中提取）的条件概率。预测时，使用贪婪算法选择最大概率的 action。</p><p>因为是直接预测 “块” ，所以和使用的标记方法无关。</p><h3 id="Representing-Labeled-Chunks"><a href="#Representing-Labeled-Chunks" class="headerlink" title="Representing Labeled Chunks"></a>Representing Labeled Chunks</h3><p>REDUCE 操作执行时，算法将一个序列的 token 从 stack 移到 output 作为一个 chunk。这个序列的表示用一个 Bi-LSTM 计算，输入是所有 token 的 embedding 加上一个表示 chunk 类型的 token，也就是 g(u, …, v, r)，r 就是那个 label 类型的 embedding。最后 output buffer 就只包括一个向量，用来表示每个生成的与长度无关的标记了的 chunk。</p><h2 id="Input-Word-Embeddings"><a href="#Input-Word-Embeddings" class="headerlink" title="Input Word Embeddings"></a>Input Word Embeddings</h2><ul><li>字符级别的词表示（关注词的拼写）</li><li>大规模语料顺序敏感的 embedding（关注在大规模语料上的多变性）</li><li>dropout（防止依赖某一个表示）</li></ul><h3 id="Character-based-models-of-words"><a href="#Character-based-models-of-words" class="headerlink" title="Character-based models of words"></a>Character-based models of words</h3><p><img src="http://qnimg.lovevivian.cn/paper-neural-architectures-for-ner-4.jpeg" alt=""></p><p>为了训练 UNK，用 UNK 按 50% 的概率替换单例。LSTM 的 hidden dimension 为 25，左右加起来是 50。由于 RNN 倾向于最近的输入，所以期望前向 LSTM 能够表示词的后缀，后向 LSTM 能够表示词的前缀。本文认为重要的信息是位置独立的，使得 LSTM 成为建模词和字母关系的一个很好的先验。</p><h3 id="Pretrained-embeddings"><a href="#Pretrained-embeddings" class="headerlink" title="Pretrained embeddings"></a>Pretrained embeddings</h3><p>skip-n-gram（词顺序），训练时候精调。</p><h3 id="Dropout-training"><a href="#Dropout-training" class="headerlink" title="Dropout training"></a>Dropout training</h3><p>最后一层 embedding layer（在图 1 的 Bi-LSTM 前）使用一个 dropout mask，模型效果提升显著。</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p>BP + SGD + lr 0.01 + gradient clipping 5.0，效果好于 Adam 或 Adadelta</p><p>LSTM-CRF 双向都是单层 layer，维度 100，调整维度对模型影响不大，dropout 0.5，高比例负样影响结果，低比例训练时间加长。</p><p>Stack-LSTM 双层，维度 100，action 维度 16，output embedding 维度 20。</p><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>CoNLL-2002, CONLL-2003，四类实体：地名，人名，组织名和杂项，没有使用 POS tag，除了在英文 dataset 上把数字替换成 0 外没有做任何其他预处理。</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>Stack-LSTM 更加依赖基于字符的表示，猜测是，LSTM-CRF 因为 Bi-LSTM 获得更多的上下文信息因而可能需要较少的拼写信息；而 Stack-LSTM 逐个使用单词，并且对单词 chunk 时仅仅依赖词表示。</p><p><img src="http://qnimg.lovevivian.cn/paper-neural-architectures-for-ner-5.jpeg" alt=""></p><h3 id="Network-architectures"><a href="#Network-architectures" class="headerlink" title="Network architectures"></a>Network architectures</h3><p><img src="http://qnimg.lovevivian.cn/paper-neural-architectures-for-ner-6.jpeg" alt=""></p><ul><li>word embedding +7.31</li><li>CRF +1.79</li><li>dropout +1.17</li><li>character-level word embedding +0.74</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><ul><li>Carreras et al. (2002) 组合小的固定深度的决策树</li><li>Florian et al. (2003) 组合四个不同的分类器</li><li>Qi et al. (2009) 大规模语料上使用神经网络无监督学习</li></ul><p>神经网络：</p><ul><li>Collobert et al. (2001) 序列词 embedding + CNN + CRF（CRF 首次出现的地方）</li><li>Huang et al. (2015) 和 LSTM-CRF 类似，但使用了人工设计的拼写特征</li><li>Zhou, Xu (2015) 使用了类似模型，并将其用到语义角色标注任务</li><li>Lin, Wu (2009) Linear chain CRF + L2 正则，他们添加了从网络数据中提取的词组聚类特征和拼写特征</li><li>Passos et al. (2014) Linear chain CRF + 拼写特征 + gazetteers</li></ul><p>语言独立模型：</p><ul><li>Cucerzan, Yarowsky (1999; 2002) 半监督 bootstrapping，联合训练字符级别和 token 级别的特征</li><li>Eisenstein et al. (2011) Bayesian 非参数几乎无监督的方法构建命名实体数据库</li><li>Ratinov, Roth (2009) 量化对比了一些 NER 方法，使用规范化的平均感知器并汇总上下文信息来构建监督模型</li></ul><p>letter-based 表示：</p><ul><li>Gillick et al. (2015) 使用 seq2seq 模型，character-based 表示作为 encoder</li><li>Chiu, Nichols (2015) 与本文结构类似，但使用了 CNN 来学习 character-based 特征</li><li>Santos, Guimaraes (2015) 类上</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>模型的一个关键点是对 output label 的依赖性建模（CRF 和基于转移的算法）；词表示也非常重要，pretrained 词表示和 character-based 表示分别捕获了形态和拼写信息；dropout 用来防止过拟合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Paper: &lt;a href=&quot;https://arxiv.org/pdf/1603.01360.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1603.01360.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;code: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/clab/stack-lstm-ner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clab/stack-lstm-ner: NER system based on stack LSTMs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/glample/tagger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;glample/tagger: Named Entity Recognition Tool&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;核心思想：pretrained + character-based 词表示分别学习形态和拼写，Bi-LSTM + CRF 和基于转移的模型均可以对输出标签的依赖关系建模。&lt;/p&gt;
&lt;p&gt;看了 Related Work 后发现很多想法其实早就冒出来了，不同的论文在不同点上使用了不同的方法，本篇恰好用这样的方法取得了最好的效果。其实，我觉得更加有意思的是基于转移的模型，它构建了一个 action 的时间序列，感觉更加抽象，想法更加精妙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Feeling" scheme="https://www.yam.gift/categories/Feeling/"/>
    
    
      <category term="NLP" scheme="https://www.yam.gift/tags/NLP/"/>
    
      <category term="NER" scheme="https://www.yam.gift/tags/NER/"/>
    
      <category term="CRF" scheme="https://www.yam.gift/tags/CRF/"/>
    
      <category term="Bi-LSTM" scheme="https://www.yam.gift/tags/Bi-LSTM/"/>
    
      <category term="Embedding" scheme="https://www.yam.gift/tags/Embedding/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer2（Python 版）解析</title>
    <link href="https://www.yam.gift/2019/12/17/DS/2019-12-17-Coding-Review2-Explanation/"/>
    <id>https://www.yam.gift/2019/12/17/DS/2019-12-17-Coding-Review2-Explanation/</id>
    <published>2019-12-17T15:00:00.000Z</published>
    <updated>2019-12-17T15:24:30.631Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://yam.gift/2019/12/15/DS/2019-12-15-Coding-Review2-Explanation-Vol1/" target="_blank" rel="noopener">剑指 Offer2（Python 版）解析（上） | Yam</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://yam.gift/2019/12/15/DS/2019-12-15-Coding-Review2-Explanation-Vol1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer2（Pytho
      
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
      <category term="Data Structure" scheme="https://www.yam.gift/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://www.yam.gift/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer2（Python 版）解析（上）</title>
    <link href="https://www.yam.gift/2019/12/15/DS/2019-12-15-Coding-Review2-Explanation-Vol1/"/>
    <id>https://www.yam.gift/2019/12/15/DS/2019-12-15-Coding-Review2-Explanation-Vol1/</id>
    <published>2019-12-15T15:00:00.000Z</published>
    <updated>2019-12-15T15:18:24.543Z</updated>
    
    <content type="html"><![CDATA[<p><div class="toc"><ul class="toc-item"><li><span><a href="#总览" data-toc-modified-id="总览-1">总览</a></span></li><li><span><a href="#第一章：面试的流程" data-toc-modified-id="第一章：面试的流程-2">第一章：面试的流程</a></span></li><li><span><a href="#第二章：面试需要的基础知识" data-toc-modified-id="第二章：面试需要的基础知识-3">第二章：面试需要的基础知识</a></span><ul class="toc-item"><li><span><a href="#面试题-2：实现-Singleton-模式" data-toc-modified-id="面试题-2：实现-Singleton-模式-3.1">面试题 2：实现 Singleton 模式</a></span></li><li><span><a href="#面试题-3（一）：找出数组中重复的数字" data-toc-modified-id="面试题-3（一）：找出数组中重复的数字-3.2">面试题 3（一）：找出数组中重复的数字</a></span></li><li><span><a href="#面试题-3（二）：不修改数组找出重复的数字" data-toc-modified-id="面试题-3（二）：不修改数组找出重复的数字-3.3">面试题 3（二）：不修改数组找出重复的数字</a></span></li><li><span><a href="#面试题-4：二维数组中的查找" data-toc-modified-id="面试题-4：二维数组中的查找-3.4">面试题 4：二维数组中的查找</a></span></li><li><span><a href="#面试题-5：替换空格" data-toc-modified-id="面试题-5：替换空格-3.5">面试题 5：替换空格</a></span></li><li><span><a href="#面试题-6：从尾到头打印链表" data-toc-modified-id="面试题-6：从尾到头打印链表-3.6">面试题 6：从尾到头打印链表</a></span></li><li><span><a href="#面试题-7：重建二叉树" data-toc-modified-id="面试题-7：重建二叉树-3.7">面试题 7：重建二叉树</a></span></li><li><span><a href="#面试题-8：二叉树的下一个节点" data-toc-modified-id="面试题-8：二叉树的下一个节点-3.8">面试题 8：二叉树的下一个节点</a></span></li><li><span><a href="#面试题-9：用两个栈实现队列" data-toc-modified-id="面试题-9：用两个栈实现队列-3.9">面试题 9：用两个栈实现队列</a></span></li><li><span><a href="#面试题-10：斐波那契数列" data-toc-modified-id="面试题-10：斐波那契数列-3.10">面试题 10：斐波那契数列</a></span></li><li><span><a href="#面试题-11：旋转数组的最小数字" data-toc-modified-id="面试题-11：旋转数组的最小数字-3.11">面试题 11：旋转数组的最小数字</a></span></li><li><span><a href="#面试题-12：矩阵中的路径" data-toc-modified-id="面试题-12：矩阵中的路径-3.12">面试题 12：矩阵中的路径</a></span></li><li><span><a href="#面试题-13：机器人的运动范围" data-toc-modified-id="面试题-13：机器人的运动范围-3.13">面试题 13：机器人的运动范围</a></span></li><li><span><a href="#面试题-14：剪绳子" data-toc-modified-id="面试题-14：剪绳子-3.14">面试题 14：剪绳子</a></span></li><li><span><a href="#面试题-15：二进制中-1-的个数" data-toc-modified-id="面试题-15：二进制中-1-的个数-3.15">面试题 15：二进制中 1 的个数</a></span></li></ul></li><li><span><a href="#第三章：高质量的代码" data-toc-modified-id="第三章：高质量的代码-4">第三章：高质量的代码</a></span><ul class="toc-item"><li><span><a href="#面试题-16：数值的整数次方" data-toc-modified-id="面试题-16：数值的整数次方-4.1">面试题 16：数值的整数次方</a></span></li><li><span><a href="#面试题-17：打印-1-到最大的-n-位数" data-toc-modified-id="面试题-17：打印-1-到最大的-n-位数-4.2">面试题 17：打印 1 到最大的 n 位数</a></span></li><li><span><a href="#面试题-18（一）：在-O-(1)-时间删除链表节点" data-toc-modified-id="面试题-18（一）：在-O-(1)-时间删除链表节点-4.3">面试题 18（一）：在 O (1) 时间删除链表节点</a></span></li><li><span><a href="#面试题-18（二）：删除链表中重复的节点" data-toc-modified-id="面试题-18（二）：删除链表中重复的节点-4.4">面试题 18（二）：删除链表中重复的节点</a></span></li><li><span><a href="#面试题-19：正则表达式匹配" data-toc-modified-id="面试题-19：正则表达式匹配-4.5">面试题 19：正则表达式匹配</a></span></li><li><span><a href="#面试题-20：表示数值的字符串" data-toc-modified-id="面试题-20：表示数值的字符串-4.6">面试题 20：表示数值的字符串</a></span></li><li><span><a href="#面试题-21：调整数组顺序使奇数位于偶数前面" data-toc-modified-id="面试题-21：调整数组顺序使奇数位于偶数前面-4.7">面试题 21：调整数组顺序使奇数位于偶数前面</a></span></li><li><span><a href="#面试题-22：链表中倒数第-k-个节点" data-toc-modified-id="面试题-22：链表中倒数第-k-个节点-4.8">面试题 22：链表中倒数第 k 个节点</a></span></li><li><span><a href="#面试题-23：链表中环的入口节点" data-toc-modified-id="面试题-23：链表中环的入口节点-4.9">面试题 23：链表中环的入口节点</a></span></li><li><span><a href="#面试题-24：反转链表" data-toc-modified-id="面试题-24：反转链表-4.10">面试题 24：反转链表</a></span></li><li><span><a href="#面试题-25：合并两个排序的链表" data-toc-modified-id="面试题-25：合并两个排序的链表-4.11">面试题 25：合并两个排序的链表</a></span></li><li><span><a href="#面试题-26：树的子结构" data-toc-modified-id="面试题-26：树的子结构-4.12">面试题 26：树的子结构</a></span></li></ul></li><li><span><a href="#第四章：解决面试题的思路" data-toc-modified-id="第四章：解决面试题的思路-5">第四章：解决面试题的思路</a></span><ul class="toc-item"><li><span><a href="#面试题-27：二叉树的镜像" data-toc-modified-id="面试题-27：二叉树的镜像-5.1">面试题 27：二叉树的镜像</a></span></li><li><span><a href="#面试题-28：对称的二叉树" data-toc-modified-id="面试题-28：对称的二叉树-5.2">面试题 28：对称的二叉树</a></span></li><li><span><a href="#面试题-29：顺时针打印矩阵" data-toc-modified-id="面试题-29：顺时针打印矩阵-5.3">面试题 29：顺时针打印矩阵</a></span></li><li><span><a href="#面试题-30：包含-min-函数的栈" data-toc-modified-id="面试题-30：包含-min-函数的栈-5.4">面试题 30：包含 min 函数的栈</a></span></li><li><span><a href="#面试题-31：栈的压入、弹出序列" data-toc-modified-id="面试题-31：栈的压入、弹出序列-5.5">面试题 31：栈的压入、弹出序列</a></span></li><li><span><a href="#面试题-32（一）：不分行从上往下打印二叉树" data-toc-modified-id="面试题-32（一）：不分行从上往下打印二叉树-5.6">面试题 32（一）：不分行从上往下打印二叉树</a></span></li><li><span><a href="#面试题-32（二）：分行从上到下打印二叉树" data-toc-modified-id="面试题-32（二）：分行从上到下打印二叉树-5.7">面试题 32（二）：分行从上到下打印二叉树</a></span></li><li><span><a href="#面试题-32（三）：之字形打印二叉树" data-toc-modified-id="面试题-32（三）：之字形打印二叉树-5.8">面试题 32（三）：之字形打印二叉树</a></span></li><li><span><a href="#面试题-33：二叉搜索树的后序遍历序列" data-toc-modified-id="面试题-33：二叉搜索树的后序遍历序列-5.9">面试题 33：二叉搜索树的后序遍历序列</a></span></li><li><span><a href="#面试题-34：二叉树中和为某一值的路径" data-toc-modified-id="面试题-34：二叉树中和为某一值的路径-5.10">面试题 34：二叉树中和为某一值的路径</a></span></li><li><span><a href="#面试题-35：复杂链表的复制" data-toc-modified-id="面试题-35：复杂链表的复制-5.11">面试题 35：复杂链表的复制</a></span></li><li><span><a href="#面试题-36：二叉搜索树与双向链表" data-toc-modified-id="面试题-36：二叉搜索树与双向链表-5.12">面试题 36：二叉搜索树与双向链表</a></span></li><li><span><a href="#面试题-37：序列化二叉树" data-toc-modified-id="面试题-37：序列化二叉树-5.13">面试题 37：序列化二叉树</a></span></li><li><span><a href="#面试题-38：字符串的排列" data-toc-modified-id="面试题-38：字符串的排列-5.14">面试题 38：字符串的排列</a></span></li></ul></li></ul></div></p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><strong>具体实现和测试代码</strong>：</p><ul><li><a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python" target="_blank" rel="noopener">The-DataStructure-and-Algorithms/CodingInterview2-Python</a></li></ul><p><strong>系列解析</strong>（TBD）：</p><ul><li>Python 单例模式</li><li>好玩儿的 DP</li><li>递归还是递归</li><li>双指针的威力</li><li>双列表的威力</li><li>有趣的排列组合</li></ul><p><strong>特别说明</strong>：下文中的实例代码一般仅包括核心算法（不一定能直接运行），完整的代码可以参考对应的链接。</p><a id="more"></a><h2 id="第一章：面试的流程"><a href="#第一章：面试的流程" class="headerlink" title="第一章：面试的流程"></a>第一章：面试的流程</h2><p>STAR 模型介绍项目：</p><ul><li>Situation：简短的项目背景。如规模、功能、目标用户等。</li><li>Task：自己完成的任务。注意区分负责与参与。</li><li>Action：为完成任务做了哪些工作，怎么做的。</li><li>Result：自己的贡献。量化。</li></ul><p>掌握技能程度：</p><ul><li>了解：上过课或看过书，没做过项目。不建议列出，除非职位需要。</li><li>熟悉：项目开发中用到的技能。</li><li>精通：有能力解决领域内别人解决不了的问题。</li></ul><p>应聘者需具备的素质：</p><ul><li>扎实的基础知识：编程语言、数据结构、算法。</li><li>高质量的代码：正确、完整、鲁棒。</li><li>清晰的思路：能清晰分析，解决复杂问题。三种方法：简单的具体例子；画图；分解成若干子问题。</li><li>优化效率的能力：能从时间、空间两方面优化算法效率。</li><li>优秀的综合能力：具备优秀的沟通能力、学习能力和发散思维能力。</li></ul><h2 id="第二章：面试需要的基础知识"><a href="#第二章：面试需要的基础知识" class="headerlink" title="第二章：面试需要的基础知识"></a>第二章：面试需要的基础知识</h2><p><code>C++</code> 相关书籍：</p><ul><li>《Effective C++》：常见问题与解决技巧。</li><li>《C++ Primer》：全面了解语法。</li><li>《深入探索 C++ 对象模型》：有助于深入了解 C++ 对象的内部。</li><li>《The C++ Programming Language》：全面深入掌握。</li></ul><p><code>C#</code> 相关书籍：</p><ul><li>《Professional C#》：写给有其他语言经验的程序员。</li><li>《CLR Via C#》：全面 + CLR + <code>.NET</code></li></ul><h3 id="面试题-2：实现-Singleton-模式"><a href="#面试题-2：实现-Singleton-模式" class="headerlink" title="面试题 2：实现 Singleton 模式"></a>面试题 2：实现 Singleton 模式</h3><blockquote><p>题目：设计一个类，我们只能生成该类的一个实例。</p></blockquote><p>单例设计模式的意图如下：</p><ul><li>确保类有且只有一个对象被创建。</li><li>为对象提供一个访问点，以使程序可以全局访问该对象。</li><li>控制共享资源的并行访问。</li></ul><p>Python 有以下几种实现方式：</p><ul><li>所有的模块都是单例</li><li>覆盖 <code>__new__</code> 方法</li><li>懒汉式实例化</li><li>使用元类</li><li>Monostate 单例模式</li></ul><p>详细可参考这篇解析：Python 单例模式。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/02_Singleton" target="_blank" rel="noopener">02_Singleton</a></p><h3 id="面试题-3（一）：找出数组中重复的数字"><a href="#面试题-3（一）：找出数组中重复的数字" class="headerlink" title="面试题 3（一）：找出数组中重复的数字"></a>面试题 3（一）：找出数组中重复的数字</h3><blockquote><p>题目：在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字 2 或者 3。</p></blockquote><p>很 Naive 的方法就是创建一个 dict，然后遍历一遍统计每个数字的次数，同时判断次数是否超过 2，如果超过就返回对应的 key。字典也可以换为 list，下标作为 number，值作为次数。或者就是把数组排序后，判断前后两个数字是否相等。</p><p>这些都是常规方法，书中的算法非常精巧，它基于这样的事实：有重复的数字时必然有些位置没数字，而有些位置有多个数字。基本步骤如下：从头到尾扫描数组，扫描到下标为 i 的数字（设为 m），看看 m 和 i 是否相等；如果是则扫描下一个数字；如果不是，则再看是否和 <code>numbers[m]</code> 相等。如果和 <code>numbers[m]</code> 相等，就找到了一个重复数字；如果不是，把 <code>numbers[i]</code> 和 <code>numbers[m]</code> 互换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">    <span class="keyword">while</span> numbers[k] != k:</span><br><span class="line">        <span class="keyword">if</span> numbers[k] == numbers[numbers[k]]:</span><br><span class="line">            <span class="keyword">return</span> numbers[k]</span><br><span class="line">        tmp = numbers[k]</span><br><span class="line">        numbers[k] = numbers[tmp]</span><br><span class="line">        numbers[tmp] = tmp</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/03_01_DuplicationInArray" target="_blank" rel="noopener">03_01_DuplicationInArray</a></p><h3 id="面试题-3（二）：不修改数组找出重复的数字"><a href="#面试题-3（二）：不修改数组找出重复的数字" class="headerlink" title="面试题 3（二）：不修改数组找出重复的数字"></a>面试题 3（二）：不修改数组找出重复的数字</h3><blockquote><p>题目：在一个长度为 n+1 的数组里的所有数字都在 1 到 n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 8 的数组 {2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字 2 或者 3。</p></blockquote><p>Naive 的方法不提了。这里的思路是：统计一定范围内出现的次数，如果有重复，出现次数就会超过范围。比如 1-3 范围内应该有 3 个数字，但统计出来 3 个以上就一定有重复数字。然后我们就可以用二分法来解决了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start, end = <span class="number">1</span>, len(numbers)</span><br><span class="line"><span class="keyword">while</span> end &gt;= start:</span><br><span class="line">    mid = (end - start) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 统计 1-mid 之间数字的次数</span></span><br><span class="line">    count = count_range(numbers, start, mid)</span><br><span class="line">    <span class="keyword">if</span> end == start <span class="keyword">and</span> count &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="comment"># 次数大于范围</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; mid - start + <span class="number">1</span>:</span><br><span class="line">        end = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        start = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个思想的关键是虽然 numbers 无序，但是用了有序的 range 去二分地统计次数。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/03_02_DuplicationInArrayNoEdit" target="_blank" rel="noopener">03_02_DuplicationInArrayNoEdit</a></p><h3 id="面试题-4：二维数组中的查找"><a href="#面试题-4：二维数组中的查找" class="headerlink" title="面试题 4：二维数组中的查找"></a>面试题 4：二维数组中的查找</h3><blockquote><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>关键信息是数组的有序性：从左到右递增、从上到下递增。我们可以选择右上（或左下）的数字开始，如果给定数字大于右上数字，那一定在下面的行，否则，一定在左边的列。注意：左上或右下不行。其实右上或左下正好是信息交叉点，即熵值最大的点，不确定性最大，此时比较后给我们的信息量最大；而左上或右下没有不确定性，我们确信那里是最小值或最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> col &gt; <span class="number">0</span> <span class="keyword">and</span> row &lt; m:</span><br><span class="line">    <span class="keyword">if</span> matrix[row][col] &gt; x:</span><br><span class="line">        col -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> matrix[row][col] &lt; x:</span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/04_FindInPartiallySortedMatrix" target="_blank" rel="noopener">04_FindInPartiallySortedMatrix</a></p><h3 id="面试题-5：替换空格"><a href="#面试题-5：替换空格" class="headerlink" title="面试题 5：替换空格"></a>面试题 5：替换空格</h3><blockquote><p>题目：请实现一个函数，把字符串中的每个空格替换成 “%20”。例如输入 “We are happy.”，则输出 “We%20are%20happy.”。</p></blockquote><p>用 replace 这题就那啥了，不过也不复杂。首先确定空格的数量，然后就确定新字符串的总长度，接着从头到尾复制就好了，碰到空格，就把要替换的内容复制到新的这边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> new_len &gt;= raw_len &gt;<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> s[raw_len<span class="number">-1</span>] == <span class="string">" "</span>:</span><br><span class="line">        new_s[new_len<span class="number">-1</span>] = <span class="string">"0"</span></span><br><span class="line">        new_s[new_len<span class="number">-2</span>] = <span class="string">"2"</span></span><br><span class="line">        new_s[new_len<span class="number">-3</span>] = <span class="string">"%"</span></span><br><span class="line">        new_len -= <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_s[new_len<span class="number">-1</span>] = s[raw_len<span class="number">-1</span>]</span><br><span class="line">        new_len -= <span class="number">1</span></span><br><span class="line">    raw_len -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/05_ReplaceSpaces" target="_blank" rel="noopener">05_ReplaceSpaces</a></p><h3 id="面试题-6：从尾到头打印链表"><a href="#面试题-6：从尾到头打印链表" class="headerlink" title="面试题 6：从尾到头打印链表"></a>面试题 6：从尾到头打印链表</h3><blockquote><p>题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p></blockquote><p>指针翻转会修改链表。链表遍历后翻转类似于正好就是栈的特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack, res = [], []</span><br><span class="line"><span class="keyword">while</span> head:</span><br><span class="line">    stack.append(head.val)</span><br><span class="line">    head = head.next</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">    res.append(stack.pop())</span><br></pre></td></tr></table></figure><p>或者使用递归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_linked_list</span><span class="params">(head, res)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> head:</span><br><span class="line">        res.insert(<span class="number">0</span>, head.val)</span><br><span class="line">        print_linked_list(head.next, res)</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/06_PrintListInReversedOrder" target="_blank" rel="noopener">06_PrintListInReversedOrder</a></p><h3 id="面试题-7：重建二叉树"><a href="#面试题-7：重建二叉树" class="headerlink" title="面试题 7：重建二叉树"></a>面试题 7：重建二叉树</h3><blockquote><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 {1,2, 4, 7, 3, 5, 6, 8} 和中序遍历序列 {4, 7, 2, 1, 5, 3, 8, 6}，则重建出图 2.6 所示的二叉树并输出它的头节点。</p></blockquote><p>二叉树的遍历方法：</p><ul><li>前序遍历：先根节点再左右节点</li><li>中序遍历：先左节点再中右节点</li><li>后序遍历：先左右节点再中节点</li><li>宽度优先遍历：按层遍历</li><li>深度优先遍历：按路径遍历</li></ul><p>二叉树的特例：</p><ul><li>二叉搜索树：左节点小于或等于根节点；右节点大于或等于根节点。</li><li>堆：分为最大堆和最小堆；前者根节点值最大，后者相反。</li><li>红黑树：把树的节点定义为红黑两色，并通过规则确保从根节点到叶节点的最长路径不超过最短路径的两倍。</li></ul><p>前序遍历序列的第一个数字就是根节点；根据中序遍历序列可以得到根节点的位置，根节点左边的数字是左子树（假设为 ltm 个）；右边的是右子树（假设为 rtm 个）。前序遍历序列根节点后面的 ltm 个就是左子树，再往后的 rtm 个就是右子树。简易画图，很直观。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(preorder, inorder)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    root = preorder[<span class="number">0</span>]</span><br><span class="line">    root_index = inorder.index(root)</span><br><span class="line">    tree = TreeNode(root)</span><br><span class="line">    tree.left = construct(preorder[<span class="number">1</span>:root_index+<span class="number">1</span>], inorder[:root_index])</span><br><span class="line">    tree.right = construct(preorder[root_index+<span class="number">1</span>:], inorder[root_index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/07_ConstructBinaryTree" target="_blank" rel="noopener">07_ConstructBinaryTree</a></p><h3 id="面试题-8：二叉树的下一个节点"><a href="#面试题-8：二叉树的下一个节点" class="headerlink" title="面试题 8：二叉树的下一个节点"></a>面试题 8：二叉树的下一个节点</h3><blockquote><p>题目：给定一棵二叉树和其中的一个节点，如何找出中序遍历顺序的下一个节点？树中的节点除了有两个分别指向左右子节点的指针以外，还有一个指向父节点的指针。</p></blockquote><ul><li>如果一个节点有右子树，下一个节点就是右子树的左子节点。</li><li>如果一个节点没有右子树，如果节点是它父节点的左子节点，下一个节点就是父节点。</li><li>如果一个节点既没有右子树，并且还是父节点的右子节点，就只能沿着父节点指针一直向上遍历，直到找到一个是它父节点的左子节点的节点。</li></ul><p>建议画图，会直观些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">    pright = node.right</span><br><span class="line">    <span class="keyword">while</span> pright.left:</span><br><span class="line">        pright = pright.left</span><br><span class="line">    pnext = pright</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    current = node</span><br><span class="line">    parent = node.parent</span><br><span class="line">    <span class="keyword">while</span> parent <span class="keyword">and</span> current == parent.right:</span><br><span class="line">        current = parent</span><br><span class="line">        parent = parent.parent</span><br><span class="line">    pnext = parent</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/08_NextNodeInBinaryTrees" target="_blank" rel="noopener">08_NextNodeInBinaryTrees</a></p><h3 id="面试题-9：用两个栈实现队列"><a href="#面试题-9：用两个栈实现队列" class="headerlink" title="面试题 9：用两个栈实现队列"></a>面试题 9：用两个栈实现队列</h3><blockquote><p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p></blockquote><p>队列是先进先出，而栈是先进后出。append 时可以直接进去，delete 时稍微有些麻烦，必须把栈元素全部挪一遍才能找到最先进栈的元素，然后把它删掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_tail</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_head</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                <span class="comment"># 后进先出</span></span><br><span class="line">                item = self.stack1.pop()</span><br><span class="line">                self.stack2.append(item)</span><br><span class="line">        <span class="comment"># 为空时</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure><p>相应地，用两个队列实现栈也是类似的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue1 = []</span><br><span class="line">        self.queue2 = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.queue1.append(x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.queue2:</span><br><span class="line">            <span class="keyword">while</span> self.queue1:</span><br><span class="line">                <span class="comment"># 先进先出</span></span><br><span class="line">                item = self.queue1.pop(<span class="number">0</span>)</span><br><span class="line">                self.queue2.append(item)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.queue2:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.queue2.pop()</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/09_QueueWithTwoStacks" target="_blank" rel="noopener">09_QueueWithTwoStacks</a></p><h3 id="面试题-10：斐波那契数列"><a href="#面试题-10：斐波那契数列" class="headerlink" title="面试题 10：斐波那契数列"></a>面试题 10：斐波那契数列</h3><blockquote><p>题目：写一个函数，输入 n，求斐波那契（Fibonacci）数列的第 n 项。</p></blockquote><p>递归代码简单，但性能可能不如循环（频繁入栈出栈），还有可能导致栈溢出。实际应用中要根据具体问题具体分析，不能简单地说某个一定好。也可以用递归的思路分析问题，写出循环的代码。</p><p>Naive 的方法不提了，递归很容易写出来，问题就是每次都要重复计算之前计算过的；自然而然，我们想要把计算过的存起来下次直接用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    store = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        res = sum(store)</span><br><span class="line">        store = [store[<span class="number">-1</span>], res]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>书中另外介绍了一种方法，基于一个公式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[f(n), f(n<span class="number">-1</span>)], [f(n<span class="number">-1</span>), f(n<span class="number">-2</span>)]] = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]] ^(n<span class="number">-1</span>)</span><br><span class="line">a^n = a^&#123;n/<span class="number">2</span>&#125; a^&#123;n/<span class="number">2</span>&#125; when n <span class="keyword">is</span> even</span><br><span class="line">a^n = a^&#123;(n<span class="number">-1</span>)/<span class="number">2</span>&#125; a^&#123;(n<span class="number">-1</span>)/<span class="number">2</span>&#125; a when n <span class="keyword">is</span> odd</span><br></pre></td></tr></table></figure><p>简单起见，我们直接用 numpy 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>][n]</span><br><span class="line">    base = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> matrix_multiply(base, n<span class="number">-1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_multiply</span><span class="params">(base, exp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> exp == <span class="number">1</span>:</span><br><span class="line">        res = base</span><br><span class="line">    <span class="keyword">elif</span> exp &gt; <span class="number">1</span> <span class="keyword">and</span> exp % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        res = matrix_multiply(base, exp/<span class="number">2</span>)</span><br><span class="line">        res = np.dot(res, res)</span><br><span class="line">    <span class="keyword">elif</span> exp &gt; <span class="number">1</span> <span class="keyword">and</span> exp % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        res = matrix_multiply(base, (exp<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line">        res = np.dot(res, res).dot(base)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = base</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/10_Fibonacci" target="_blank" rel="noopener">10_Fibonacci</a></p><p>另外，青蛙跳台阶、铺地砖等都是类似的题目。</p><h3 id="面试题-11：旋转数组的最小数字"><a href="#面试题-11：旋转数组的最小数字" class="headerlink" title="面试题 11：旋转数组的最小数字"></a>面试题 11：旋转数组的最小数字</h3><blockquote><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。</p></blockquote><p>旋转数组有几个特性：</p><ul><li>两个数组都是排好序的</li><li>前面的数组元素都大于或等于后面的</li><li>最小的元素正好是两个数组的分界点</li></ul><p>可以尝试用二分查找：如果中间的元素位于前面的数组，那么应该大于或等于第一个元素，最小的在后面的数组。然后把第一个元素的位置移动到中间，继续在后面一半中查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beg, end = <span class="number">0</span>, len(lst) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> lst[end] &lt; lst[beg]:</span><br><span class="line">    <span class="keyword">if</span> end - beg == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst[end]</span><br><span class="line">    mid = (beg + end) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> lst[mid] &gt; lst[beg]:</span><br><span class="line">        beg = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        end = mid</span><br></pre></td></tr></table></figure><p>还需要考虑两种特殊情况：旋转之后首元素比末尾元素小或相等。如果旋转后最后一个元素比第一个元素还大，那就说明没旋转，最小的就是第一个元素；如果旋转后的最后一个元素和第一个元素一样大，这种情况是由于重复元素导致的，我们不清楚重复元素有多少个以及位于何处，所以只能按正常的查找方法查找。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/11_MinNumberInRotatedArray" target="_blank" rel="noopener">11_MinNumberInRotatedArray</a></p><h3 id="面试题-12：矩阵中的路径"><a href="#面试题-12：矩阵中的路径" class="headerlink" title="面试题 12：矩阵中的路径"></a>面试题 12：矩阵中的路径</h3><blockquote><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的 3×4 的矩阵中包含一条字符串 “bfce” 的路径（路径中的字<br>母用下划线标出）。但矩阵中不包含字符串 “abfb” 的路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br>A <u>B</u> T G<br>C <u>F</u> <u>C</u> S<br>J D <u>E</u> H</p></blockquote><p>使用回溯法，依次判断矩阵的每个元素能否形成给定的路径。有几个关键点需要注意：</p><ul><li>顺序找到 string 的每个元素才能结束</li><li>每次记录访问过的元素</li><li>如果没有找到下个元素就回溯一个元素，同时修改对应的访问记录</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_path</span><span class="params">(array, path)</span>:</span></span><br><span class="line">    rows, cols = array.shape</span><br><span class="line">    visited = np.zeros((rows, cols))</span><br><span class="line">    plen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">            <span class="keyword">if</span> has_path_core(array, row, col, rows, cols, path, plen, visited):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_path_core</span><span class="params">(array, row, col, rows, cols, path, plen, visited)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> plen == len(path):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    hasp = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> =&lt; row &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt; cols </span><br><span class="line">        <span class="keyword">and</span> array[row][col] == path[plen] </span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">not</span> visited[row][col]):</span><br><span class="line">        visited[row][col] = <span class="keyword">True</span></span><br><span class="line">        plen += <span class="number">1</span></span><br><span class="line">        hasp = (has_path_core(array, row, col<span class="number">-1</span>, rows, cols, path, plen, visited) <span class="keyword">or</span></span><br><span class="line">                has_path_core(array, row<span class="number">-1</span>, col, rows, cols, path, plen, visited) <span class="keyword">or</span></span><br><span class="line">                has_path_core(array, row, col+<span class="number">1</span>, rows, cols, path, plen, visited) <span class="keyword">or</span></span><br><span class="line">                has_path_core(array, row+<span class="number">1</span>, col, rows, cols, path, plen, visited))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasp:</span><br><span class="line">            plen -= <span class="number">1</span></span><br><span class="line">            visited[row][col] = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> hasp</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/12_StringPathInMatrix" target="_blank" rel="noopener">12_StringPathInMatrix</a></p><h3 id="面试题-13：机器人的运动范围"><a href="#面试题-13：机器人的运动范围" class="headerlink" title="面试题 13：机器人的运动范围"></a>面试题 13：机器人的运动范围</h3><blockquote><p>题目：地上有一个 m 行 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 (35, 37)，因为 3+5+3+7=18。但它不能进入方格 (35, 38)，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？</p></blockquote><p>和上一题类似，不过返回值是格子数。另外，并不需要回溯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moving_count_core</span><span class="params">(row, col, rows, cols, threshold, visited)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= row &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt; cols </span><br><span class="line">        <span class="keyword">and</span> get_digit_num(row) + get_digit(col) &lt;= threshold</span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">not</span> visited[row][col]):</span><br><span class="line">        visited[row][col] = <span class="keyword">True</span></span><br><span class="line">        count = <span class="number">1</span> + (</span><br><span class="line">        moving_count_core(row<span class="number">-1</span>, col, rows, cols, threshold, visited) +</span><br><span class="line">            moving_count_core(row+<span class="number">1</span>, col, rows, cols, threshold, visited) +</span><br><span class="line">            moving_count_core(row, col<span class="number">-1</span>, rows, cols, threshold, visited) +</span><br><span class="line">            moving_count_core(row, col+<span class="number">1</span>, rows, cols, threshold, visited)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/13_RobotMove" target="_blank" rel="noopener">13_RobotMove</a></p><p>感慨下，有时候明明知道怎么做就是写不出代码来；一个朋友说那还是不知道，我觉得也是。这可能就是知道的层次不同吧，总归须知此事要躬行。</p><h3 id="面试题-14：剪绳子"><a href="#面试题-14：剪绳子" class="headerlink" title="面试题 14：剪绳子"></a>面试题 14：剪绳子</h3><blockquote><p>题目：给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，n&gt;1 并且 m≥1）。每段的绳子的长度记为 k [0]、k [1]、……、k [m]。k [0]*k [1]*…*k [m] 可能的最大乘积是多少？例如当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到最大的乘积 18。</p></blockquote><p>动态规划适合于能分解成子问题，并且子问题也有最优解的问题。动态规划求解的问题特点如下：</p><ul><li>求一个问题的最优解</li><li>整体问题最优解依赖子问题最优解</li><li>小问题之间还有相互重叠的更小的子问题</li></ul><p>贪婪算法每一步都做出一个贪婪的选择，但需保证这样的做法能够得到最优解。此例中，n ≥ 5 时，尽可能剪成 3 的段，当剩下的绳子为 4 时，剪成 2 2，这样乘积就能最大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>][n]</span><br><span class="line">    products = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">0</span>] * (n<span class="number">-3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, n+<span class="number">1</span>):</span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            pt = products[j] * products[i-j]</span><br><span class="line">            <span class="keyword">if</span> pt &gt; mx:</span><br><span class="line">                mx = pt</span><br><span class="line">        products[i] = mx</span><br><span class="line">    <span class="keyword">return</span> products[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 贪婪</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>][n]</span><br><span class="line">    n3 = n // <span class="number">3</span></span><br><span class="line">    remain = n - n3 * <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> remain == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> ** (n3<span class="number">-1</span>) * <span class="number">4</span></span><br><span class="line">    <span class="keyword">elif</span> remain == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> ** n3 * <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> ** n3</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/14_CuttingRope" target="_blank" rel="noopener">14_CuttingRope</a></p><h3 id="面试题-15：二进制中-1-的个数"><a href="#面试题-15：二进制中-1-的个数" class="headerlink" title="面试题 15：二进制中 1 的个数"></a>面试题 15：二进制中 1 的个数</h3><blockquote><p>题目：请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如把 9 表示成二进制是 1001，有 2 位是 1。因此如果输入 9，该函数输出 2。</p></blockquote><p>一个数字与 1 做与运算，可以判断最低位是不是 1，因此我们可以不断右移数字或左移 flag 来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 右移数字</span></span><br><span class="line"><span class="keyword">while</span> n:</span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    n = n &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左移 flag</span></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    <span class="keyword">if</span> n &amp; flag:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    flag = flag &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> flag &gt; n:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>书中还介绍了一个更精巧的算法：一个整数减去 1，与原整数做与运算，会把该整数最右边的 1 变为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> n:</span><br><span class="line">    n = n &amp; (n<span class="number">-1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后，注意负数和溢出的情况，Python 中的情况（自动对大数做了处理）和 C 或 CPP 不一样。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/15_NumberOf1InBinary" target="_blank" rel="noopener">15_NumberOf1InBinary</a></p><p>还有两个相关题目：</p><ul><li>判断一个数是不是 2 的整数次方。如果是，二进制中只有一个 1，减去 1 再和自己与运算，就会把唯一的 1 变为 0，所以整个结果为 0。比如 <code>8 &amp; (8-1)  == 0</code></li><li>输入整数 m n，需要改变 m 的二进制多少位能得到 n。第一步求异或；第二步求异或中 1 的个数。</li></ul><h2 id="第三章：高质量的代码"><a href="#第三章：高质量的代码" class="headerlink" title="第三章：高质量的代码"></a>第三章：高质量的代码</h2><ul><li>规范性<ul><li>书写清晰</li><li>布局清晰</li><li>命名合理</li></ul></li><li>完整性<ul><li>完成基本功能</li><li>考虑边界条件</li><li>做好错误处理（错误输入）<ul><li>用返回值告知出错</li><li>设置一个全局变量</li><li>抛一个异常</li></ul></li></ul></li><li>鲁棒性<ul><li>采取防御性编程</li><li>处理无效的输入</li></ul></li></ul><h3 id="面试题-16：数值的整数次方"><a href="#面试题-16：数值的整数次方" class="headerlink" title="面试题 16：数值的整数次方"></a>面试题 16：数值的整数次方</h3><blockquote><p>题目：实现函数 double Power (double base, int exponent)，求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。</p></blockquote><p>不考虑大数问题，但负数问题还是要考虑的。Naive 的方法就是循环相乘 exponent 次。但显然有了之前斐波那契数列的经验，我们自然想用更快速的方法：exponent 是偶数的时候，先算 exponent/2 次方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base_by_exp</span><span class="params">(base, exp)</span>:</span></span><br><span class="line">    <span class="comment"># 不要直接用 == 0</span></span><br><span class="line">    <span class="keyword">if</span> exp &lt; <span class="number">0</span> <span class="keyword">and</span> is_equal_zero(base):</span><br><span class="line">        print(<span class="string">"Invalid input."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> exp &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/calc(base, -exp)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> calc(base, exp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(base, exp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> exp == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> exp == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    res = calc(base, exp//<span class="number">2</span>)</span><br><span class="line">    res *= res</span><br><span class="line">    <span class="keyword">if</span> exp % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        res = res * base</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/16_Power" target="_blank" rel="noopener">16_Power</a></p><h3 id="面试题-17：打印-1-到最大的-n-位数"><a href="#面试题-17：打印-1-到最大的-n-位数" class="headerlink" title="面试题 17：打印 1 到最大的 n 位数"></a>面试题 17：打印 1 到最大的 n 位数</h3><blockquote><p>题目：输入数字 n，按顺序打印出从 1 最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p></blockquote><p>Naive 的做法当然是求出这个最大的数：<code>10 ** (n-1) - 1</code>，然后挨个打印出来就行了。但这没有考虑大数问题，虽然 Python 对大数做了处理，但其他语言可能并没有，所以一般使用字符串来模拟。显然需要模拟字符串上的加法，我们把每位用一个字符表示，创建一个表示各位的 list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_1ton</span><span class="params">(n)</span>:</span></span><br><span class="line">    str_num = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 如果最高位没有进一</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> str_num[<span class="number">0</span>]:</span><br><span class="line">        print(str_num)</span><br><span class="line">        str_num = increase(str_num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(str_num)</span>:</span></span><br><span class="line">    over = <span class="number">0</span></span><br><span class="line">    nlen = len(str_num)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nlen<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        addn = str_num[i] + over</span><br><span class="line">        <span class="keyword">if</span> i == nlen - <span class="number">1</span>:</span><br><span class="line">            addn += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> addn &gt;= <span class="number">10</span>:</span><br><span class="line">            addn -= <span class="number">10</span></span><br><span class="line">            str_num[i] = addn</span><br><span class="line">            over = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            str_num[i] = addn</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> str_num</span><br></pre></td></tr></table></figure><p>书中还介绍了使用全排列的方法，貌似更简单：全排列的基本思想是，每一位都是 0-9 的一个数，然后继续设置下一位，直到最后一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_1ton</span><span class="params">(n)</span>:</span></span><br><span class="line">    nums = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> increase(nums, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(nums, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> index == len(nums) - <span class="number">1</span>:</span><br><span class="line">        print(nums)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        nums[index+<span class="number">1</span>] = i</span><br><span class="line">        increase(nums, index+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>稍稍解释下，这里 index 从 0 开始，所以一开始不会打印，直到 index 等于 n 时，这时候就是个位数开始（前面的每位都是 0）依次打印到高位的过程。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/17_Print1ToMaxOfNDigits" target="_blank" rel="noopener">17_Print1ToMaxOfNDigits</a></p><h3 id="面试题-18（一）：在-O-1-时间删除链表节点"><a href="#面试题-18（一）：在-O-1-时间删除链表节点" class="headerlink" title="面试题 18（一）：在 O (1) 时间删除链表节点"></a>面试题 18（一）：在 O (1) 时间删除链表节点</h3><blockquote><p>题目：给定单向链表的头指针和一个节点指针，定义一个函数在 O (1) 时间删除该节点。</p></blockquote><p>正常的做法是从头开始遍历，找到那个节点然后删除。但这样的复杂度是 O(N)，书中使用了一种巧妙的方法：将该节点的下一个节点复制过来，然后将该节点指向下一个节点的下一节点。这就相当于把该节点删除了。不过有个前提是节点在链表中。另外，如果要删除的节点是尾节点，那就只能顺序遍历到结尾删除了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_node</span><span class="params">(head, tobe_delete)</span>:</span></span><br><span class="line">    <span class="comment"># 有下一个节点时</span></span><br><span class="line">    <span class="keyword">if</span> tobe_delete.next:</span><br><span class="line">        nxt = tobe_delete.next</span><br><span class="line">        tobe_delete.val = nxt.val</span><br><span class="line">        tobe_delete.next = nxt.next</span><br><span class="line">    <span class="comment"># 只有一个节点</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> tobe_delete.next <span class="keyword">and</span> head == tobe_delete:</span><br><span class="line">        head = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node.next != tobe_delete:</span><br><span class="line">            node = node.next</span><br><span class="line">        node.next = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/18_01_DeleteNodeInList" target="_blank" rel="noopener">18_01_DeleteNodeInList</a></p><h3 id="面试题-18（二）：删除链表中重复的节点"><a href="#面试题-18（二）：删除链表中重复的节点" class="headerlink" title="面试题 18（二）：删除链表中重复的节点"></a>面试题 18（二）：删除链表中重复的节点</h3><p>&gt;</p><blockquote><p>题目：在一个排序的链表中，如何删除重复的节点？例如，在图 3.4（a）中重复节点被删除之后，链表如图 3.4（b）所示。</p></blockquote><p>需要注意两件事情：头节点也可能被删除；删除之后链表依然是连着的。另外，链表是排序的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_duplication</span><span class="params">(head)</span>:</span></span><br><span class="line">    prev = <span class="keyword">None</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        nxt = node.next</span><br><span class="line">        need_delete = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 删除条件：如果下一个和当前一样就需要删除</span></span><br><span class="line">        <span class="keyword">if</span> nxt <span class="keyword">and</span> nxt.val == node.val:</span><br><span class="line">            need_delete = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不需要删除</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> need_delete:</span><br><span class="line">            prev = node</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="comment"># 如果需要删除</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            val = node.val</span><br><span class="line">            tobe_del = node</span><br><span class="line">            <span class="keyword">while</span> tobe_del <span class="keyword">and</span> tobe_del.val == val:</span><br><span class="line">                tobe_del = tobe_del.next</span><br><span class="line">            <span class="comment"># 保证无论怎么删除链表依然是连着的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prev:</span><br><span class="line">                head = tobe_del</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.next = tobe_del</span><br><span class="line">            <span class="comment"># 从最新位置开始继续循环</span></span><br><span class="line">            node = tobe_del</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/18_02_DeleteDuplicatedNode" target="_blank" rel="noopener">18_02_DeleteDuplicatedNode</a></p><h3 id="面试题-19：正则表达式匹配"><a href="#面试题-19：正则表达式匹配" class="headerlink" title="面试题 19：正则表达式匹配"></a>面试题 19：正则表达式匹配</h3><blockquote><p>题目：请实现一个函数用来匹配包含 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式。模式中的字符 <code>&#39;.&#39;</code> 表示任意一个字符，而 <code>&#39;*&#39;</code> 表示它前面的字符可以出现任意次（含 0 次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 <code>&quot;aaa&quot;</code> 与模式 <code>&quot;a.a&quot;</code> 和 <code>&quot;ab*ac*a&quot;</code> 匹配，但与 <code>&quot;aa.a&quot;</code> 及 <code>&quot;ab*a&quot;</code> 均不匹配。</p></blockquote><p>输入是 string 和 pattern，典型的 DP 解法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(s, p)</span>:</span></span><br><span class="line">    T = [[<span class="number">0</span>] * (len(p)+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)+<span class="number">1</span>)]</span><br><span class="line">    T[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(p)):</span><br><span class="line">        <span class="keyword">if</span> p[j] == <span class="string">"*"</span>:</span><br><span class="line">            T[<span class="number">0</span>][j+<span class="number">1</span>] = T[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(p)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">"."</span>:</span><br><span class="line">                T[i+<span class="number">1</span>][j+<span class="number">1</span>] = T[i][j]</span><br><span class="line">            <span class="keyword">elif</span> p[j] == <span class="string">"*"</span>:</span><br><span class="line">                T[i+<span class="number">1</span>][j+<span class="number">1</span>] = T[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> T[i+<span class="number">1</span>][j+<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">"."</span> <span class="keyword">or</span> p[j<span class="number">-1</span>] == s[i]:</span><br><span class="line">                        T[i+<span class="number">1</span>][j+<span class="number">1</span>] = T[i][j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> T[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>画个表格这个代码就很容易写出来了。还可以使用递归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(s, p)</span>:</span></span><br><span class="line">    first_match = s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">"."</span></span><br><span class="line">    <span class="keyword">if</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">if</span> first_match:</span><br><span class="line">            <span class="comment"># 0 time, 1 time, 2 times</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> dp(s[<span class="number">1</span>:], p[<span class="number">2</span>:]) <span class="keyword">or</span> dp(s[<span class="number">1</span>:], p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 0 time</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, p[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">if</span> first_match:</span><br><span class="line">        <span class="keyword">return</span> dp(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>递归代码看起来就是简单清晰。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/19_RegularExpressionsMatching" target="_blank" rel="noopener">19_RegularExpressionsMatching</a></p><h3 id="面试题-20：表示数值的字符串"><a href="#面试题-20：表示数值的字符串" class="headerlink" title="面试题 20：表示数值的字符串"></a>面试题 20：表示数值的字符串</h3><blockquote><p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 “+100”、“5e2”、“-123”、“3.1416” 及 “-1E-16” 都表示数值，但 “12e”、“1a3.14”、“1.2.3”、“+-5” 及 “12e+5.4” 都不是。</p></blockquote><p>书中给出数字的表示方法：<code>A[.[B]][e|EC]</code> 或 <code>.B[e|EC]</code>，A 是整数部分，B 是小数部分，C 是指数部分。A 和 C 可以带正负号，B 不可以。所以，可以首先定义扫描数字部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_integer</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">and</span> (s[<span class="number">0</span>] == <span class="string">"+"</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">"-"</span>):</span><br><span class="line">        s = s[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> scan_unsigned_integer(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_unsigned_integer</span><span class="params">(s)</span>:</span></span><br><span class="line">    checked = []</span><br><span class="line">    nums = <span class="string">"0 1 2 3 4 5 6 7 8 9"</span>.split()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> s[i] <span class="keyword">in</span> nums:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s[i:]</span><br></pre></td></tr></table></figure><p>这里不考虑类似 <code>+++2</code> 这种情况，Python 中没问题，不过 Java 或 C++ 中这并不是有效的数字。但是 <code>0000</code> 和 <code>0001.1</code> 是有效的，具体情况根据需要设计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_num</span><span class="params">(s)</span>:</span></span><br><span class="line">    remain = scan_integer(s)</span><br><span class="line">    <span class="comment"># 正常整数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> remain:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">elif</span> remain[<span class="number">0</span>] == <span class="string">"."</span>:</span><br><span class="line">        remain = scan_unsigned_integer(remain[<span class="number">1</span>:])</span><br><span class="line">        <span class="comment"># 正常的小数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> remain:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">elif</span> remain[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"e"</span>, <span class="string">"E"</span>]:</span><br><span class="line">        remain = scan_integer(remain[<span class="number">1</span>:])</span><br><span class="line">        <span class="comment"># 带 e 的数字</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> remain:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/20_NumericStrings" target="_blank" rel="noopener">20_NumericStrings</a></p><h3 id="面试题-21：调整数组顺序使奇数位于偶数前面"><a href="#面试题-21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题 21：调整数组顺序使奇数位于偶数前面"></a>面试题 21：调整数组顺序使奇数位于偶数前面</h3><blockquote><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p></blockquote><p>Python 可以直接用排序搞定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(nums, key=<span class="keyword">lambda</span> x: x%<span class="number">2</span>, reverse=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>否则，就需要维护两个指针，一个在开头，一个在结尾，因为不需要排序，所以只需要交换位置即可，类似归并排序的第一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> x: x%<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorder</span><span class="params">(nums, func)</span>:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> func(nums[left]):</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> func(nums[right]):</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/21_ReorderArray" target="_blank" rel="noopener">21_ReorderArray</a></p><h3 id="面试题-22：链表中倒数第-k-个节点"><a href="#面试题-22：链表中倒数第-k-个节点" class="headerlink" title="面试题 22：链表中倒数第 k 个节点"></a>面试题 22：链表中倒数第 k 个节点</h3><blockquote><p>题目：输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。例如一个链表有 6 个节点，从头节点开始它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p></blockquote><p>如果知道长度，用长度减去 k 从头开始遍历就能找到节点，但知道长度需要首先遍历一遍链表。如果要只遍历一次，我们可以使用双指针。很多类似的场景都可以用这个方法。不过这里特别注意边界和 k 的取值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_from_end</span><span class="params">(head, k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    front = head</span><br><span class="line">    behind = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> front.next:</span><br><span class="line">            front = front.next</span><br><span class="line">        <span class="comment"># 防止 k 超过链表长度</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> front.next:</span><br><span class="line">        front = front.next</span><br><span class="line">        behind = behind.next</span><br><span class="line">    <span class="keyword">return</span> behind</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/22_KthNodeFromEnd" target="_blank" rel="noopener">22_KthNodeFromEnd</a></p><h3 id="面试题-23：链表中环的入口节点"><a href="#面试题-23：链表中环的入口节点" class="headerlink" title="面试题 23：链表中环的入口节点"></a>面试题 23：链表中环的入口节点</h3><blockquote><p>题目：一个链表中包含环，如何找出环的入口节点？例如，在图 3.8 的链表中，环的入口节点是节点 3。</p></blockquote><p>与上一题一样，可以用两个指针来解决。首先确定链表中是否包括环，如果是，那么长度是多少；如果不是返回 0。然后根据环的长度 n，第一个指针先走 n 步，第二个指针和第一个指针相遇的地方就是入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_there_a_loop</span><span class="params">(head)</span>:</span></span><br><span class="line">    front, behind = head, head</span><br><span class="line">    lenth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> front.next <span class="keyword">and</span> behind.next.next:</span><br><span class="line">        front = front.next</span><br><span class="line">        behind = behind.next.next</span><br><span class="line">        <span class="comment"># 有环</span></span><br><span class="line">        <span class="keyword">if</span> front.val == behind.val:</span><br><span class="line">            tag = front.val</span><br><span class="line">            <span class="keyword">while</span> front.next:</span><br><span class="line">                front = front.next</span><br><span class="line">                lenth += <span class="number">1</span></span><br><span class="line">                <span class="comment"># Return 条件</span></span><br><span class="line">                <span class="keyword">if</span> front.val == tag:</span><br><span class="line">                    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entry_of_loop</span><span class="params">(head)</span>:</span></span><br><span class="line">    loop_len = is_there_a_loop(head)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> loop_len:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    first, second = head, head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(loop_len):</span><br><span class="line">        first = first.next</span><br><span class="line">    <span class="keyword">while</span> first:</span><br><span class="line">        <span class="keyword">if</span> first.val == second.val:</span><br><span class="line">            <span class="keyword">return</span> first</span><br><span class="line">        first = first.next</span><br><span class="line">        second = second.next</span><br></pre></td></tr></table></figure><p>或者可以先找到两个指针相遇的节点，然后根据这个节点可以确定 loop 长度（再次相遇时）；剩下的就和上面方法一样了。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/23_EntryNodeInListLoop" target="_blank" rel="noopener">23_EntryNodeInListLoop</a></p><h3 id="面试题-24：反转链表"><a href="#面试题-24：反转链表" class="headerlink" title="面试题 24：反转链表"></a>面试题 24：反转链表</h3><blockquote><p>题目：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p></blockquote><p>这道题属于常规操作，没有太多要说的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head)</span>:</span></span><br><span class="line">    preverse = <span class="keyword">None</span></span><br><span class="line">    node = head</span><br><span class="line">    prev = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        nxt = node.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nxt:</span><br><span class="line">            preverse = node</span><br><span class="line">        node.next = prev</span><br><span class="line">        prev = node</span><br><span class="line">        node = nxt</span><br><span class="line">    <span class="keyword">return</span> preverse</span><br></pre></td></tr></table></figure><p>需要注意防止链表最后一个节点断掉的问题，不过我感觉可以直接把 prev 返回去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head)</span>:</span></span><br><span class="line">    node = head</span><br><span class="line">    prev = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        nxt = node.next</span><br><span class="line">        node.next = prev</span><br><span class="line">        prev = node</span><br><span class="line">        node = nxt</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p>不知道这样是不是我忽略了哪个地方，如果有知道的童鞋请帮忙指正。此外，还可以使用递归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    p = reverse(head.next)</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/24_ReverseList" target="_blank" rel="noopener">24_ReverseList</a></p><h3 id="面试题-25：合并两个排序的链表"><a href="#面试题-25：合并两个排序的链表" class="headerlink" title="面试题 25：合并两个排序的链表"></a>面试题 25：合并两个排序的链表</h3><blockquote><p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是按照递增排序的。例如输入图 3.11 中的链表 1 和链表 2，则合并之后的升序链表如链表 3 所示。</p></blockquote><p>这道题和归并排序的归并步骤类似，因为两个链表本来就是排好序的，所以挨个比较元素，自然就按顺序排好了。递归和循环都可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(head1, head2)</span>:</span></span><br><span class="line">    link = Node(<span class="keyword">None</span>)</span><br><span class="line">    ptr = link</span><br><span class="line">    <span class="keyword">while</span> head1 <span class="keyword">and</span> head2:</span><br><span class="line">        <span class="keyword">if</span> head1.val &lt;= head2.val:</span><br><span class="line">            ptr.next = head1</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">            head1 = head1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ptr.next = head2</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">            head2 = head2.next</span><br><span class="line">    <span class="keyword">if</span> head1:</span><br><span class="line">        ptr.next = head1</span><br><span class="line">    <span class="keyword">if</span> head2:</span><br><span class="line">        ptr.next = head2</span><br><span class="line">    <span class="keyword">return</span> link.next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_recurision</span><span class="params">(head1, head2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head1:</span><br><span class="line">        <span class="keyword">return</span> head2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head2:</span><br><span class="line">        <span class="keyword">return</span> head1</span><br><span class="line">    <span class="keyword">if</span> head1.val &lt; head2.val:</span><br><span class="line">        link = head1</span><br><span class="line">        link.next = merge_recurision(head1.next, head2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        link = head2</span><br><span class="line">        link.next = merge_recurision(head1, head2.next)</span><br><span class="line">    <span class="keyword">return</span> link</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/25_MergeSortedLists" target="_blank" rel="noopener">25_MergeSortedLists</a></p><h3 id="面试题-26：树的子结构"><a href="#面试题-26：树的子结构" class="headerlink" title="面试题 26：树的子结构"></a>面试题 26：树的子结构</h3><blockquote><p>题目：输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。</p></blockquote><p>首先在 A 中找到 B 的根节点，然后判断 A 中以该节点为根节点的子树是否包含 B。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_subtree</span><span class="params">(tree, sub)</span>:</span></span><br><span class="line">    res = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> tree <span class="keyword">and</span> sub:</span><br><span class="line">        <span class="comment"># step1</span></span><br><span class="line">        <span class="keyword">if</span> equal(tree.val, sub.val):</span><br><span class="line">            <span class="comment"># step2</span></span><br><span class="line">            res = tree_has_sub(tree, sub)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            res = has_subtree(tree.left, sub)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            res = has_subtree(tree.right, sub)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_has_sub</span><span class="params">(tree, sub)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sub:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tree:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> equal(tree.val, sub.val):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> tree_has_sub(tree.left, sub.left) <span class="keyword">and</span> tree_has_sub(tree.right, sub.right)</span><br></pre></td></tr></table></figure><p>Step2 时，因为根节点已经一致了，所以我们继续判断左右节点是否一致（同时满足一致）。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/26_SubstructureInTree" target="_blank" rel="noopener">26_SubstructureInTree</a></p><h2 id="第四章：解决面试题的思路"><a href="#第四章：解决面试题的思路" class="headerlink" title="第四章：解决面试题的思路"></a>第四章：解决面试题的思路</h2><ul><li>画图让抽象问题形象化</li><li>举例让抽象问题具体化</li><li>把复杂问题分解成若干小问题，再递归解决小问题</li></ul><h3 id="面试题-27：二叉树的镜像"><a href="#面试题-27：二叉树的镜像" class="headerlink" title="面试题 27：二叉树的镜像"></a>面试题 27：二叉树的镜像</h3><blockquote><p>题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p></blockquote><p>镜像就是左右子树互换的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirror</span><span class="params">(tree)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tree:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    tree.left, tree.right = tree.right, tree.left</span><br><span class="line">    <span class="keyword">if</span> tree.left:</span><br><span class="line">        mirror(tree.left)</span><br><span class="line">    <span class="keyword">if</span> tree.right:</span><br><span class="line">        mirror(tree.right)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><p>或者用循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirror</span><span class="params">(tree)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tree:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = [tree]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/27_MirrorOfBinaryTree" target="_blank" rel="noopener">27_MirrorOfBinaryTree</a></p><h3 id="面试题-28：对称的二叉树"><a href="#面试题-28：对称的二叉树" class="headerlink" title="面试题 28：对称的二叉树"></a>面试题 28：对称的二叉树</h3><blockquote><p>题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p></blockquote><p>可以定义一种先右节点再左节点的遍历方法，如果遍历结果与正常的遍历结果一样，说明是对称的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_symmetrical</span><span class="params">(tree)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> is_symmetrical_core(tree, tree)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_symmetrical_core</span><span class="params">(t1, t2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">or</span> <span class="keyword">not</span> t2:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> t1.val != t2.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> is_symmetrical_core(t1.left, t2.right) <span class="keyword">and</span> </span><br><span class="line">           is_symmetrical_core(t1.right, t2.left)</span><br></pre></td></tr></table></figure><p>下面的 core 函数其实就是同时按不同顺序做遍历。三叉树也是类似的操作，要注意的是 mid 也要比较，因为 mid  也有子树。</p><p>二叉树的具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/28_01_SymmetricalBinaryTree" target="_blank" rel="noopener">28_01_SymmetricalBinaryTree</a></p><p>三叉树的具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/28_02_SymmetricalTernaryTree" target="_blank" rel="noopener">28_02_SymmetricalTernaryTree</a></p><h3 id="面试题-29：顺时针打印矩阵"><a href="#面试题-29：顺时针打印矩阵" class="headerlink" title="面试题 29：顺时针打印矩阵"></a>面试题 29：顺时针打印矩阵</h3><blockquote><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p></blockquote><p>这道题看似简单，却很容易出错，尤其是一圈一圈打印矩阵时，涉及到很多边界条件的判断。比如一开始就很容易写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_matrix</span><span class="params">(mx)</span>:</span></span><br><span class="line">    rows, cols = mx.shape</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> rows &gt; <span class="number">2</span> * start <span class="keyword">and</span> cols &gt; <span class="number">2</span> * start:</span><br><span class="line">        print_circle(mx, rows, cols, start)</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_circle</span><span class="params">(mx, rows, cols, start)</span>:</span></span><br><span class="line">    cend = cols - <span class="number">1</span> - start</span><br><span class="line">    rend = rows - <span class="number">1</span> - start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, cend+<span class="number">1</span>):</span><br><span class="line">        print(mx[start][i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>, rend+<span class="number">1</span>):</span><br><span class="line">        print(mx[i][cend])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(start, cend)):</span><br><span class="line">        print(mx[rend][i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(start+<span class="number">1</span>, rend)):</span><br><span class="line">        print(mx[i][start])</span><br></pre></td></tr></table></figure><p>从左到右和从上到下时应该没问题，可是最后两步的从右到左和从下到上就需要判断边界了。对于前者，要保证 start &lt; rend，否则只有一行的矩阵就会有问题，因为 rend 和 start 都是 0，会重复打印；反之，后面这种情况则在只有一列的矩阵时有问题。修改后如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_circle</span><span class="params">(mx, rows, cols, start)</span>:</span></span><br><span class="line">    cend = cols - <span class="number">1</span> - start</span><br><span class="line">    rend = rows - <span class="number">1</span> - start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, cend+<span class="number">1</span>):</span><br><span class="line">        print(mx[start][i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>, rend+<span class="number">1</span>):</span><br><span class="line">        print(mx[i][cend])</span><br><span class="line">    <span class="comment"># 防止只有一行时打印</span></span><br><span class="line">    <span class="keyword">if</span> rend &gt; start:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(start, cend)):</span><br><span class="line">            print(mx[rend][i])</span><br><span class="line">    <span class="comment"># 防止只有一列时打印</span></span><br><span class="line">    <span class="keyword">if</span> cend &gt; start:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(start+<span class="number">1</span>, rend)):</span><br><span class="line">            print(mx[i][start])</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/29_PrintMatrix" target="_blank" rel="noopener">29_PrintMatrix</a></p><h3 id="面试题-30：包含-min-函数的栈"><a href="#面试题-30：包含-min-函数的栈" class="headerlink" title="面试题 30：包含 min 函数的栈"></a>面试题 30：包含 min 函数的栈</h3><blockquote><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是 O (1)。</p></blockquote><p>基本思路使用两个栈，一个存储数据，一个存储最小值，新元素如果小于最小值栈内的元素，就需要同时压入两个栈，否则只压入数据栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data_stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.min_stack:</span><br><span class="line">            <span class="keyword">return</span> self.min_stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.data_stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> x &lt; self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">            self.min_stack.append(x)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.data_stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = self.data_stack.pop()</span><br><span class="line">        <span class="keyword">if</span> x == self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">            self.min_stack.pop()</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/30_MinInStack" target="_blank" rel="noopener">30_MinInStack</a></p><h3 id="面试题-31：栈的压入、弹出序列"><a href="#面试题-31：栈的压入、弹出序列" class="headerlink" title="面试题 31：栈的压入、弹出序列"></a>面试题 31：栈的压入、弹出序列</h3><blockquote><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1、2、3、4、5 是某栈的压栈序列，序列 4、5、3、2、1 是该压栈序列对应的一个弹出序列，但 4、3、5、1、2 就不可能是该压栈序列的弹出序列。</p></blockquote><p>建立一个辅助栈，记录入栈出栈过程，遍历弹出序列，逐个验证：如果下一个弹出的数字正好是栈顶元素，直接弹出；否则把没有入栈的数字压入栈，直到下个弹出的元素是栈顶元素为止。如果所有数字都入栈了，依然没有找到下一个弹出的数字，该序列就肯定不是弹出序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_pop_order</span><span class="params">(push_order, pop_order)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pop_order:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == i:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> push_order <span class="keyword">and</span> push_order[<span class="number">0</span>] != i:</span><br><span class="line">                x = push_order.pop(<span class="number">0</span>)</span><br><span class="line">                stack.append(x)</span><br><span class="line">            <span class="keyword">if</span> push_order:</span><br><span class="line">                push_order.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>只要知道了思路，代码写起来就比较容易了。其实基本思想就是根据入栈序列复现弹出序列。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/31_StackPushPopOrder" target="_blank" rel="noopener">31_StackPushPopOrder</a></p><h3 id="面试题-32（一）：不分行从上往下打印二叉树"><a href="#面试题-32（一）：不分行从上往下打印二叉树" class="headerlink" title="面试题 32（一）：不分行从上往下打印二叉树"></a>面试题 32（一）：不分行从上往下打印二叉树</h3><blockquote><p>题目：从上往下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p></blockquote><p>这个是常规题目，广度优先即可，需要维护一个 queue。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tree</span><span class="params">(tree)</span>:</span></span><br><span class="line">    queue = [tree]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        print(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right: queue.append(node.right)</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/32_01_PrintTreeFromTopToBottom" target="_blank" rel="noopener">32_01_PrintTreeFromTopToBottom</a></p><h3 id="面试题-32（二）：分行从上到下打印二叉树"><a href="#面试题-32（二）：分行从上到下打印二叉树" class="headerlink" title="面试题 32（二）：分行从上到下打印二叉树"></a>面试题 32（二）：分行从上到下打印二叉树</h3><blockquote><p>题目：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p></blockquote><p>这道题有很多种解法，最简单的就是在刚刚的基础上，添加层级标记。还可以直接单独打印一层，或者使用双队列。这里我们直接打印即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tree</span><span class="params">(tree)</span>:</span></span><br><span class="line">    queue = [tree]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/32_02_PrintTreesInLines" target="_blank" rel="noopener">32_02_PrintTreesInLines</a></p><h3 id="面试题-32（三）：之字形打印二叉树"><a href="#面试题-32（三）：之字形打印二叉树" class="headerlink" title="面试题 32（三）：之字形打印二叉树"></a>面试题 32（三）：之字形打印二叉树</h3><blockquote><p>题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p></blockquote><p>有了上面的代码这个就很容易了，只需要隔层 reverse 一下即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tree</span><span class="params">(tree)</span>:</span></span><br><span class="line">    queue = [tree]</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            tmp.reverse() <span class="comment"># or tmp = reversed(tmp)</span></span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">            print(<span class="string">" "</span>.join(tmp))</span><br><span class="line">            print(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/32_03_PrintTreesInZigzag" target="_blank" rel="noopener">32_03_PrintTreesInZigzag</a></p><h3 id="面试题-33：二叉搜索树的后序遍历序列"><a href="#面试题-33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题 33：二叉搜索树的后序遍历序列"></a>面试题 33：二叉搜索树的后序遍历序列</h3><blockquote><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p>二叉搜索树的左节点小于根节点，右节点大于根节点。后序遍历是指先遍历左右节点，然后遍历根节点。而且后序遍历的最后一个节点是根节点。相应地，前序遍历的第一个节点是根节点，中序遍历左右两边分别是左右子树。</p><p>因此，我们可以将前 n 个比根节点小的当做左子树，后面的自然就是右子树。左右子树又可以用同样的方法确定。典型的递归操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_postorder</span><span class="params">(lst)</span>:</span></span><br><span class="line">    root = lst[<span class="number">-1</span>]</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">        <span class="keyword">if</span> lst[i] &gt; root:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    j = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(lst)):</span><br><span class="line">        <span class="keyword">if</span> lst[j] &lt; root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    left, right = <span class="keyword">True</span>, <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        left = is_postorder(lst[:i])</span><br><span class="line">    <span class="keyword">if</span> j &lt; len(lst) - <span class="number">1</span>:</span><br><span class="line">        right = is_postorder(lst[j:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><p>有几个地方需要注意下：</p><ul><li>边界，包括遍历的边界和递归左右子树 list 的边界</li><li><p>i, j 的条件判断</p></li><li><p>left, right 的初始值</p></li></ul><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/33_SquenceOfBST" target="_blank" rel="noopener">33_SquenceOfBST</a></p><h3 id="面试题-34：二叉树中和为某一值的路径"><a href="#面试题-34：二叉树中和为某一值的路径" class="headerlink" title="面试题 34：二叉树中和为某一值的路径"></a>面试题 34：二叉树中和为某一值的路径</h3><blockquote><p>题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p></blockquote><p>很直接的想法是遍历所有的路径判断路径和。遍历路径自然想到前中后序遍历，由于从根节点开始，所以我们选择前序遍历。为了减少重复遍历，自然想到类似回溯法的思想。具体思路如下：</p><ul><li>前序遍历访问节点，节点添加到路径，累加节点值</li><li>如果节点没有左右子树，判断累加和是否与输入的整数相等，相等则打印</li><li>如果有左右子树，则继续访问左右子节点；退出时则要删除当前节点，并减掉该节点的值，保证下个遍历不会包含叶节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span><span class="params">(tree, k)</span>:</span></span><br><span class="line">    curr_sum = <span class="number">0</span></span><br><span class="line">    path = []</span><br><span class="line">    find_path_core(tree, curr_sum, k, path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_core</span><span class="params">(tree, curr_sum, need_sum, path)</span>:</span></span><br><span class="line">    curr_sum += tree.val</span><br><span class="line">    path.append(tree.val)</span><br><span class="line">    <span class="keyword">if</span> curr_sum == need_sum <span class="keyword">and</span> <span class="keyword">not</span> tree.left <span class="keyword">and</span> <span class="keyword">not</span> tree.right:</span><br><span class="line">        print(path)</span><br><span class="line">    <span class="keyword">if</span> tree.left:</span><br><span class="line">        find_path_core(tree.left, curr_sum, need_sum, path)</span><br><span class="line">    <span class="keyword">if</span> tree.right:</span><br><span class="line">        find_path_core(tree.right, curr_sum, need_sum, path)</span><br><span class="line">    <span class="keyword">if</span> path:</span><br><span class="line">        curr_sum -= path.pop()</span><br></pre></td></tr></table></figure><p>最关键的不要忘记每次的 pop。具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/34_PathInTree" target="_blank" rel="noopener">34_PathInTree</a></p><h3 id="面试题-35：复杂链表的复制"><a href="#面试题-35：复杂链表的复制" class="headerlink" title="面试题 35：复杂链表的复制"></a>面试题 35：复杂链表的复制</h3><blockquote><p>题目：请实现函数 ComplexListNode<em> Clone (ComplexListNode</em> pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个 m_pNext 指针指向下一个结点外，还有一个 m_pSibling 指向链表中的任意结点或者 nullptr。</p></blockquote><p>该链表的特殊性体现在每一个节点都有一个指向任意节点的指针。最直接的想法就是把指向任意节点的那个节点存起来，这样两趟遍历即可。书中提供了另外一种思路：</p><ul><li>每个节点后面跟一个复制的自己</li><li>节点指向任意节点的指针，下一节点也指向该任意节点的下一节点</li><li>将链表拆开即得到两份一样的链表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.sibling = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clone_nodes</span><span class="params">(head)</span>:</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        new = ComplexNode(node.val)</span><br><span class="line">        new.next = node.next</span><br><span class="line">        node.next = new</span><br><span class="line">        node = new.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_sibling_nodes</span><span class="params">(head)</span>:</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        clone = node.next</span><br><span class="line">        <span class="keyword">if</span> node.sibling:</span><br><span class="line">            clone.sibling = node.sibling.next</span><br><span class="line">        node = clone.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_nodes</span><span class="params">(head)</span>:</span></span><br><span class="line">    node = head</span><br><span class="line">    clone_head, clone_node = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> node:</span><br><span class="line">        clone_head = clone_node = node.next</span><br><span class="line">        node.next = clone_node.next</span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        clone_node.next = node.next</span><br><span class="line">        clone_node = clone_node.next</span><br><span class="line">        node.next = clone_node.next</span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">return</span> clone_head</span><br></pre></td></tr></table></figure><p>画个图会很直观（无论用手还是用脑子）。具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/35_CopyComplexList" target="_blank" rel="noopener">35_CopyComplexList</a></p><h3 id="面试题-36：二叉搜索树与双向链表"><a href="#面试题-36：二叉搜索树与双向链表" class="headerlink" title="面试题 36：二叉搜索树与双向链表"></a>面试题 36：二叉搜索树与双向链表</h3><blockquote><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p></blockquote><p>这道题的意思就是把二叉搜索树变成一个链表，原来的 left 和 right 就相当于链表的 parent 和 next。可以将二叉树看成三部分：左右子树和根节点，如果左右子树都排好了，用根节点连接起来自然就是需要的链表了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_bst_to_dll</span><span class="params">(tree)</span>:</span></span><br><span class="line">    head = convert(tree, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">and</span> head.next:</span><br><span class="line">        head = head.left</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(head, last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">if</span> curr.left:</span><br><span class="line">        last = convert(curr.left, last)</span><br><span class="line">    </span><br><span class="line">    curr.left = last</span><br><span class="line">    <span class="keyword">if</span> last:</span><br><span class="line">        last.right = curr</span><br><span class="line">    last = curr</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> curr.right:</span><br><span class="line">        last = convert(curr.right, last)</span><br><span class="line">    <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure><p>有几个点需要特别注意：</p><ul><li>要记得从 right 的 last 回到 left，判断条件也要留心，既要 head 存在，也要 next 存在</li><li>因为要的是双向链表，所以递归时务必要回指，即：<code>last.right = curr</code></li><li>记得右移 last</li></ul><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/36_ConvertBinarySearchTree☆" target="_blank" rel="noopener">36_ConvertBinarySearchTree☆</a></p><h3 id="面试题-37：序列化二叉树"><a href="#面试题-37：序列化二叉树" class="headerlink" title="面试题 37：序列化二叉树"></a>面试题 37：序列化二叉树</h3><blockquote><p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。</p></blockquote><p>序列化从根节点开始，所以可以使用前序遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(tree, res)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tree:</span><br><span class="line">        res.append(<span class="string">"$"</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    tree.append(tree.val)</span><br><span class="line">    serialize(tree.left, res)</span><br><span class="line">    serialize(tree.right, res)</span><br></pre></td></tr></table></figure><p>接下来按照相反的方式反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(res)</span>:</span></span><br><span class="line">    head = <span class="keyword">None</span></span><br><span class="line">    val = res.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> val != <span class="string">"$"</span>:</span><br><span class="line">        head = BSN(val)</span><br><span class="line">        head.left = deserialize(res)</span><br><span class="line">        head.right = deserialize(res)</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>只要记住，反序列化正好是序列化的逆过程就好。具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/37_SerializeBinaryTrees" target="_blank" rel="noopener">37_SerializeBinaryTrees</a></p><h3 id="面试题-38：字符串的排列"><a href="#面试题-38：字符串的排列" class="headerlink" title="面试题 38：字符串的排列"></a>面试题 38：字符串的排列</h3><blockquote><p>题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a、b、c 所能排列出来的所有字符串 abc、acb、bac、bca、cab 和 cba。</p></blockquote><p>这道题有几种解法，相对简单些的就是递归了：假设字符串分成两组，第一组是第一个元素，剩余的一组。然后分成两步：</p><ul><li>所有可能出现在第一个位置的字符，即把第一个字符和后面的交换</li><li>固定第一个字符，求后面字符的排列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出处：https://www.youtube.com/watch?v=KBHFyg2AcZ4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutate</span><span class="params">(s, l, r, res)</span> -&gt; list:</span></span><br><span class="line">    <span class="keyword">if</span> l == r - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(s)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">            lst = list(s)</span><br><span class="line">            lst[i], lst[l] = lst[l], lst[i]</span><br><span class="line">            permutate(<span class="string">""</span>.join(lst), l+<span class="number">1</span>, r, res)</span><br><span class="line">            lst[l], lst[i] = lst[i], lst[l]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这里有一篇文章的图挺清楚的：<a href="https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/" target="_blank" rel="noopener">Write a program to print all permutations of a given string</a>，我就是看了这个图才彻底搞清楚的，果然是一图胜千言。还有一种类似的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutate</span><span class="params">(s: str, moves: list, res: list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        remain = s[<span class="number">0</span>:i] + s[i+<span class="number">1</span>:]</span><br><span class="line">        moves.append(s[i])</span><br><span class="line">        <span class="keyword">if</span> remain:</span><br><span class="line">            permutate(remain, moves, res)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(<span class="string">""</span>.join(moves))</span><br><span class="line">        moves.pop()</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>此外还可以先生成所有的组合，然后剔除包含重复元素的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(s, repeat)</span>:</span></span><br><span class="line">    pools = [tuple(s)] * repeat</span><br><span class="line">    result = [<span class="string">""</span>]</span><br><span class="line">    <span class="keyword">for</span> pool <span class="keyword">in</span> pools:</span><br><span class="line">        result = [x+y <span class="keyword">for</span> x <span class="keyword">in</span> result <span class="keyword">for</span> y <span class="keyword">in</span> pool]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>不过最简洁的方式当属下面这种，思想和上面的都差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出处：https://www.youtube.com/watch?v=IPWmrjE1_MU</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutate</span><span class="params">(prefix, suffix, res)</span> -&gt; list:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> suffix:</span><br><span class="line">        res.append(prefix)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(suffix)):</span><br><span class="line">            permutate(prefix+suffix[i], suffix[:i]+suffix[i+<span class="number">1</span>:], res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>最后再介绍一种相对容易理解的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出处：https://www.youtube.com/watch?v=hqijNdQTBH8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutate6</span><span class="params">(s: str)</span> -&gt; list:</span></span><br><span class="line">    lst = list(s)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lst:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">elif</span> len(lst) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [lst]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">            head = lst[i]</span><br><span class="line">            remain = lst[:i] + lst[i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> permutate6(remain):</span><br><span class="line">                res.append([head] + p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>递归的思路比较简单，关键点就两个：</p><ul><li>第一个位置的元素</li><li>第一个位置固定后递归</li></ul><p>用循环也可以做，itertools 中实现了这个算法，不过有点复杂，这里不再赘述了。</p><p>具体实现和测试代码可参考：<a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python/38_StringPermutation☆" target="_blank" rel="noopener">38_StringPermutation☆</a>，一共提供了 7 种方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;toc&quot;&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#总览&quot; data-toc-modified-id=&quot;总览-1&quot;&gt;总览&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#第一章：面试的流程&quot; data-toc-modified-id=&quot;第一章：面试的流程-2&quot;&gt;第一章：面试的流程&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#第二章：面试需要的基础知识&quot; data-toc-modified-id=&quot;第二章：面试需要的基础知识-3&quot;&gt;第二章：面试需要的基础知识&lt;/a&gt;&lt;/span&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-2：实现-Singleton-模式&quot; data-toc-modified-id=&quot;面试题-2：实现-Singleton-模式-3.1&quot;&gt;面试题 2：实现 Singleton 模式&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-3（一）：找出数组中重复的数字&quot; data-toc-modified-id=&quot;面试题-3（一）：找出数组中重复的数字-3.2&quot;&gt;面试题 3（一）：找出数组中重复的数字&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-3（二）：不修改数组找出重复的数字&quot; data-toc-modified-id=&quot;面试题-3（二）：不修改数组找出重复的数字-3.3&quot;&gt;面试题 3（二）：不修改数组找出重复的数字&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-4：二维数组中的查找&quot; data-toc-modified-id=&quot;面试题-4：二维数组中的查找-3.4&quot;&gt;面试题 4：二维数组中的查找&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-5：替换空格&quot; data-toc-modified-id=&quot;面试题-5：替换空格-3.5&quot;&gt;面试题 5：替换空格&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-6：从尾到头打印链表&quot; data-toc-modified-id=&quot;面试题-6：从尾到头打印链表-3.6&quot;&gt;面试题 6：从尾到头打印链表&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-7：重建二叉树&quot; data-toc-modified-id=&quot;面试题-7：重建二叉树-3.7&quot;&gt;面试题 7：重建二叉树&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-8：二叉树的下一个节点&quot; data-toc-modified-id=&quot;面试题-8：二叉树的下一个节点-3.8&quot;&gt;面试题 8：二叉树的下一个节点&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-9：用两个栈实现队列&quot; data-toc-modified-id=&quot;面试题-9：用两个栈实现队列-3.9&quot;&gt;面试题 9：用两个栈实现队列&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-10：斐波那契数列&quot; data-toc-modified-id=&quot;面试题-10：斐波那契数列-3.10&quot;&gt;面试题 10：斐波那契数列&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-11：旋转数组的最小数字&quot; data-toc-modified-id=&quot;面试题-11：旋转数组的最小数字-3.11&quot;&gt;面试题 11：旋转数组的最小数字&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-12：矩阵中的路径&quot; data-toc-modified-id=&quot;面试题-12：矩阵中的路径-3.12&quot;&gt;面试题 12：矩阵中的路径&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-13：机器人的运动范围&quot; data-toc-modified-id=&quot;面试题-13：机器人的运动范围-3.13&quot;&gt;面试题 13：机器人的运动范围&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-14：剪绳子&quot; data-toc-modified-id=&quot;面试题-14：剪绳子-3.14&quot;&gt;面试题 14：剪绳子&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-15：二进制中-1-的个数&quot; data-toc-modified-id=&quot;面试题-15：二进制中-1-的个数-3.15&quot;&gt;面试题 15：二进制中 1 的个数&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#第三章：高质量的代码&quot; data-toc-modified-id=&quot;第三章：高质量的代码-4&quot;&gt;第三章：高质量的代码&lt;/a&gt;&lt;/span&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-16：数值的整数次方&quot; data-toc-modified-id=&quot;面试题-16：数值的整数次方-4.1&quot;&gt;面试题 16：数值的整数次方&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-17：打印-1-到最大的-n-位数&quot; data-toc-modified-id=&quot;面试题-17：打印-1-到最大的-n-位数-4.2&quot;&gt;面试题 17：打印 1 到最大的 n 位数&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-18（一）：在-O-(1)-时间删除链表节点&quot; data-toc-modified-id=&quot;面试题-18（一）：在-O-(1)-时间删除链表节点-4.3&quot;&gt;面试题 18（一）：在 O (1) 时间删除链表节点&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-18（二）：删除链表中重复的节点&quot; data-toc-modified-id=&quot;面试题-18（二）：删除链表中重复的节点-4.4&quot;&gt;面试题 18（二）：删除链表中重复的节点&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-19：正则表达式匹配&quot; data-toc-modified-id=&quot;面试题-19：正则表达式匹配-4.5&quot;&gt;面试题 19：正则表达式匹配&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-20：表示数值的字符串&quot; data-toc-modified-id=&quot;面试题-20：表示数值的字符串-4.6&quot;&gt;面试题 20：表示数值的字符串&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-21：调整数组顺序使奇数位于偶数前面&quot; data-toc-modified-id=&quot;面试题-21：调整数组顺序使奇数位于偶数前面-4.7&quot;&gt;面试题 21：调整数组顺序使奇数位于偶数前面&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-22：链表中倒数第-k-个节点&quot; data-toc-modified-id=&quot;面试题-22：链表中倒数第-k-个节点-4.8&quot;&gt;面试题 22：链表中倒数第 k 个节点&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-23：链表中环的入口节点&quot; data-toc-modified-id=&quot;面试题-23：链表中环的入口节点-4.9&quot;&gt;面试题 23：链表中环的入口节点&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-24：反转链表&quot; data-toc-modified-id=&quot;面试题-24：反转链表-4.10&quot;&gt;面试题 24：反转链表&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-25：合并两个排序的链表&quot; data-toc-modified-id=&quot;面试题-25：合并两个排序的链表-4.11&quot;&gt;面试题 25：合并两个排序的链表&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-26：树的子结构&quot; data-toc-modified-id=&quot;面试题-26：树的子结构-4.12&quot;&gt;面试题 26：树的子结构&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#第四章：解决面试题的思路&quot; data-toc-modified-id=&quot;第四章：解决面试题的思路-5&quot;&gt;第四章：解决面试题的思路&lt;/a&gt;&lt;/span&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-27：二叉树的镜像&quot; data-toc-modified-id=&quot;面试题-27：二叉树的镜像-5.1&quot;&gt;面试题 27：二叉树的镜像&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-28：对称的二叉树&quot; data-toc-modified-id=&quot;面试题-28：对称的二叉树-5.2&quot;&gt;面试题 28：对称的二叉树&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-29：顺时针打印矩阵&quot; data-toc-modified-id=&quot;面试题-29：顺时针打印矩阵-5.3&quot;&gt;面试题 29：顺时针打印矩阵&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-30：包含-min-函数的栈&quot; data-toc-modified-id=&quot;面试题-30：包含-min-函数的栈-5.4&quot;&gt;面试题 30：包含 min 函数的栈&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-31：栈的压入、弹出序列&quot; data-toc-modified-id=&quot;面试题-31：栈的压入、弹出序列-5.5&quot;&gt;面试题 31：栈的压入、弹出序列&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-32（一）：不分行从上往下打印二叉树&quot; data-toc-modified-id=&quot;面试题-32（一）：不分行从上往下打印二叉树-5.6&quot;&gt;面试题 32（一）：不分行从上往下打印二叉树&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-32（二）：分行从上到下打印二叉树&quot; data-toc-modified-id=&quot;面试题-32（二）：分行从上到下打印二叉树-5.7&quot;&gt;面试题 32（二）：分行从上到下打印二叉树&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-32（三）：之字形打印二叉树&quot; data-toc-modified-id=&quot;面试题-32（三）：之字形打印二叉树-5.8&quot;&gt;面试题 32（三）：之字形打印二叉树&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-33：二叉搜索树的后序遍历序列&quot; data-toc-modified-id=&quot;面试题-33：二叉搜索树的后序遍历序列-5.9&quot;&gt;面试题 33：二叉搜索树的后序遍历序列&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-34：二叉树中和为某一值的路径&quot; data-toc-modified-id=&quot;面试题-34：二叉树中和为某一值的路径-5.10&quot;&gt;面试题 34：二叉树中和为某一值的路径&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-35：复杂链表的复制&quot; data-toc-modified-id=&quot;面试题-35：复杂链表的复制-5.11&quot;&gt;面试题 35：复杂链表的复制&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-36：二叉搜索树与双向链表&quot; data-toc-modified-id=&quot;面试题-36：二叉搜索树与双向链表-5.12&quot;&gt;面试题 36：二叉搜索树与双向链表&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-37：序列化二叉树&quot; data-toc-modified-id=&quot;面试题-37：序列化二叉树-5.13&quot;&gt;面试题 37：序列化二叉树&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#面试题-38：字符串的排列&quot; data-toc-modified-id=&quot;面试题-38：字符串的排列-5.14&quot;&gt;面试题 38：字符串的排列&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;具体实现和测试代码&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hscspring/The-DataStructure-and-Algorithms/tree/master/CodingInterview2-Python&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The-DataStructure-and-Algorithms/CodingInterview2-Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;系列解析&lt;/strong&gt;（TBD）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 单例模式&lt;/li&gt;
&lt;li&gt;好玩儿的 DP&lt;/li&gt;
&lt;li&gt;递归还是递归&lt;/li&gt;
&lt;li&gt;双指针的威力&lt;/li&gt;
&lt;li&gt;双列表的威力&lt;/li&gt;
&lt;li&gt;有趣的排列组合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特别说明&lt;/strong&gt;：下文中的实例代码一般仅包括核心算法（不一定能直接运行），完整的代码可以参考对应的链接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
      <category term="Data Structure" scheme="https://www.yam.gift/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://www.yam.gift/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Few-Shot Charge Prediction with Discriminative Legal Attributes Note</title>
    <link href="https://www.yam.gift/2019/12/15/Paper/2019-12-15-Few-Shot-Charge-Prediction-with-Discriminative-Legal-Attributes/"/>
    <id>https://www.yam.gift/2019/12/15/Paper/2019-12-15-Few-Shot-Charge-Prediction-with-Discriminative-Legal-Attributes/</id>
    <published>2019-12-15T11:00:00.000Z</published>
    <updated>2019-12-15T11:16:03.324Z</updated>
    
    <content type="html"><![CDATA[<p>Paper: <a href="http://nlp.csai.tsinghua.edu.cn/~tcc/publications/coling2018_attribute.pdf" target="_blank" rel="noopener">coling2018_attribute.pdf</a></p><p>code: <a href="https://github.com/thunlp/attribute_charge" target="_blank" rel="noopener">thunlp/attribute_charge</a></p><p>核心思想：基于类别属性的注意力机制共同学习属性感知和无属性的文本表示。</p><p>这是 COLING2018 上的一篇老论文了，最近因为一些事情正好遇上，当时大概看了一下就发现这篇文章正好解决了我之前在做多分类<a href="https://github.com/hscspring/Multi-Label-Text-Classification-for-Chinese#others" target="_blank" rel="noopener">任务</a>时没有解决的问题。所以拿来记录一下，顺便研究下代码。</p><a id="more"></a><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文主要解决罪名预测（根据刑事法律文书中的案情描述和事实部分，预测被告人被判的罪名）中的两个问题：</p><ul><li>数据不平衡问题：有些罪名的 case 太少</li><li>标签相似的问题：有些罪名意思过于接近</li></ul><p>文章通过提取罪名相关属性作为额外特征，不仅为 case 少的罪名类别提供了信息，同时还可以作为鉴别相似标签的有效信号。结果在 few-shot 场景下比 baseline 取得 50% 的提升。</p><p>看到这里当时就有两个反应：卧槽，为啥这么简单我没想到？卧槽，为啥这么简单的方法效果居然这么好？</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>传统的做法是人工设计特征，包括文本相关（字、词、短语）和属性特征相关（日期，位置，条款，类型），目前基本都是用深度学习的方法在做了。</p><p>不过依然有两个主要挑战：</p><ul><li>Few-Shot Charges：实际场景中，最多的 10 种罪名占了 78.1%，最少的 50 种罪名仅占不到 0.5% 而且大部分就 10 个左右的案例。传统的方法一般忽略少的，深度学习需要一定量的训练样本。所以，这个问题成为决定一个系统鲁棒性和有效性的关键。</li><li>Confusing Charges：比如（盗窃，抢劫），（挪用资金，挪用公款），它们的定义仅在验证特定行为时有所不同，对应案例中的条件常常非常相似。</li></ul><p>为了解决这两个问题，本文建议考虑具有区别罪名的法律属性，并将这些属性作为犯罪事实描述和罪名之间的映射。具体而言，选中 10 个有代表属性的罪名，然后进行低成本类别级构建：对每个罪名，注释每个属性的值（是，否或不可用）。</p><p>有了属性注释后，本文提出一个多任务学习框架来同时预测每个案例的属性和罪名。在模型中，使用属性注意力机制来捕获与特定属性相关的关键事实信息。之后，将这些属性感知与无属性事实表征（文本表征）结合起来，预测最终的罪名。</p><p>这样做的两个原因：</p><ul><li>这些属性可以提供有关如何区分相似罪名的明确知识。</li><li>所有罪名共享这些属性，知识可以从高频罪名转向低频罪名。</li></ul><p>本文的三个主要贡献：</p><ul><li>首先专注于 Few-Shot Charges 和 Confusing Charges。</li><li>提出了一种新颖的多任务学习框架，以共同推断案件的属性和指控。采用注意力机制学习属性感知的事实表示。</li><li>在真实数据集上结果优于其他基准，在 few-short 罪名上的提升超过 50%。</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Zero-Shot-Classification"><a href="#Zero-Shot-Classification" class="headerlink" title="Zero-Shot Classification"></a>Zero-Shot Classification</h3><p>与计算视觉中的 Zero-Shot 相关。有许多基于属性的模型，属性在不同类别间共享并提供中间表示。</p><ul><li>Lampert et al. (2014) 提出了 direct attribute prediction 和 indirect attribute prediction，并提出可以预训练，当需要寻找新的合适的对象类别时就不用再训练的属性分类器。</li><li>Akata et al. (2013) 提出将基于属性的分类任务转为标签 embedding 任务。</li><li>Jayaraman, Grauman (2014) 引入随机森林方法，强调了未知类别属性预测的不可靠性。</li></ul><p>除了属性外，还可以引入其他信息：</p><ul><li>Elhoseiny et al. (2014) 使用标签的文本描述在文本特征和视觉特征之间传递知识。</li><li>Zero-Shot 除了用在 object recognition 外，还被用于 activity recognition 和 event recognition</li></ul><h3 id="Charge-Prediction"><a href="#Charge-Prediction" class="headerlink" title="Charge Prediction"></a>Charge Prediction</h3><p>法律领域一直致力于自动裁决。</p><ul><li>Kort (1957) 使用定量方法计算事实元素的数值预测。</li><li>Nagel (1963) 利用相关性分析对重新分配案件进行预测。</li><li>Keown (1980) 引入数学模型，如线性模型和最近邻。</li></ul><p>这些模型通常限于标签少的小型数据集。</p><p>在机器学习兴起时，问题转化为文本分类，通常需要从案例中提取特征。</p><ul><li>Lin 等 (2012) 提取 21 个法律因素标签分类。</li><li>Mackaay 和 Robillard (1974) 提取了 Ngram 和通过语义相似 Ngram 聚类得到的主题作为特征。</li><li>Sulea 等 (2017) 提出了基于 SVM 继承的系统，使用案例描述，案例的裁定和时间跨度作为输入。</li></ul><p>不过这些方法只能提取在大数据集上难以收集的浅层语义表征或手动标签，而且，常规模型无法捕捉相似犯罪之间的细微差别。</p><p>随着深度学习的兴起，Luo et al. (2017) 提出了一个分层注意力网络同时预测罪名并提取相关文章。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Discriminative-Charge-Attributes"><a href="#Discriminative-Charge-Attributes" class="headerlink" title="Discriminative Charge Attributes"></a>Discriminative Charge Attributes</h3><p>为所有罪名引入了 10 个判别属性，对每个（罪名，属性）对，可以标记为是，否或不可用）。比如，故意杀人罪的指控在故意犯罪上标记为 “否”，在死亡时标记为 “是”，在国家机关标记为 “不适用”。对特定属性，特定案件的标签和相应罪名的标签应相同或不冲突。在实践中，手动标记了 149 种不同罪名的属性，然后为每个案例分配与其相应罪名相同的属性。<img src="http://qnimg.lovevivian.cn/paper-few-shot-charge-prediction-1.jpeg" alt=""></p><h3 id="Formalizations"><a href="#Formalizations" class="headerlink" title="Formalizations"></a>Formalizations</h3><p><img src="http://qnimg.lovevivian.cn/paper-few-shot-charge-prediction-2.jpeg" alt=""></p><h4 id="Charge-Prediction-1"><a href="#Charge-Prediction-1" class="headerlink" title="Charge Prediction"></a>Charge Prediction</h4><p>给定犯罪事实文本，预测一个罪名</p><h4 id="Attributes-Prediction"><a href="#Attributes-Prediction" class="headerlink" title="Attributes Prediction"></a>Attributes Prediction</h4><p>二分类任务，给定犯罪事实文本，预测每个属性的分类</p><h4 id="Fact-Encoder"><a href="#Fact-Encoder" class="headerlink" title="Fact Encoder"></a>Fact Encoder</h4><p>LSTM + Max-Pooling 获得无属性文本表征</p><script type="math/tex; mode=display">e_{i}=\max \left(\mathbf{h}_{1, i}, \cdots, \mathbf{h}_{n, i}\right), \forall i \in[1, s]</script><p>s 是 hidden states 的维度。n 是 time step。也就是取了每个 hidden state 中的最大值提出来重新组成一个向量作为句子的表征。</p><h4 id="Attentive-Attribute-Predictor"><a href="#Attentive-Attribute-Predictor" class="headerlink" title="Attentive Attribute Predictor"></a>Attentive Attribute Predictor</h4><p>采用注意力机制从犯罪事实文本中选择相关信息并生成属性感知的事实表示。</p><p>Step1: 输入为 hidden states 序列：<code>h = {h1, ..., hn}</code></p><p>Step 2: 然后计算所有属性的 attention weights <code>a = {a1, ..., ak}</code>，<code>ai = [ai1,...ain]</code>：</p><script type="math/tex; mode=display">a_{i, j}=\frac{\exp \left(\tanh \left(\mathbf{W}^{a} \mathbf{h}_{j}\right)^{T} \mathbf{u}_{i}\right)}{\sum_{t} \exp \left(\tanh \left(\mathbf{W}^{a} \mathbf{h}_{t}\right)^{T} \mathbf{u}_{i}\right)}</script><p>ui 是第 i 个属性的上下文向量，用于计算元素对属性的信息程度。Wα 是所有属性共享的权重矩阵。</p><p>Step3: 然后得到属性感知的表示：<code>g = {g1, ..., gk}</code>，<code>gi = Σt ait ht</code></p><p>Step4: 最后用 g + softmax 获得 p 的预测结果：</p><script type="math/tex; mode=display">\begin{array}{l}{\mathbf{z}_{i}=\operatorname{softmax}\left(\mathbf{W}_{i}^{p} \mathbf{g}_{i}+\mathbf{b}_{i}^{p}\right)} \\ {p_{i}=\arg \max \left(\mathbf{z}_{i}\right)}\end{array}</script><h4 id="Output-Layer"><a href="#Output-Layer" class="headerlink" title="Output Layer"></a>Output Layer</h4><p>属性无关 + 属性感知表示预测最终的罪名:</p><script type="math/tex; mode=display">\begin{aligned} \mathbf{r} &=\frac{\sum_{i} \mathbf{g}_{\mathbf{i}}}{k} \\ \mathbf{v} &=\mathbf{e} \oplus \mathbf{r} \\ y &=\operatorname{softmax}\left(\mathbf{W}^{y} \mathbf{v}+\mathbf{b}^{y}\right) \end{aligned}</script><h4 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h4><p>包括两部分</p><p>Part1: 最小化预测罪名和真实罪名分布的交叉熵（C 是罪名总数）</p><script type="math/tex; mode=display">\mathcal{L}_{\text {charge}}=-\sum_{i=1}^{C} y_{i} \cdot \log \left(\hat{y}_{i}\right)</script><p>Part2: 最小化每个属性预测分布和真实分布的交叉熵（求和是或否的 loss）</p><script type="math/tex; mode=display">\mathcal{L}_{a t t r}=-\sum_{i=1}^{k} I_{i} \sum_{j=1}^{2} z_{i j} \cdot \log \left(\hat{z}_{i j}\right)</script><p><code>Ii</code> 指示 label 是 <code>yes/no (Ii=1)</code> 还是 NA（<code>Ii=0</code>)</p><p>最终的 loss function（α 是超参数）：</p><script type="math/tex; mode=display">\mathcal{L}=\mathcal{L}_{c h a r g e}+\alpha \cdot \mathcal{L}_{a t t r}</script><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Dataset-Construction"><a href="#Dataset-Construction" class="headerlink" title="Dataset Construction"></a>Dataset Construction</h3><p>数据来源：<a href="http://wenshu.court.gov.cn/" target="_blank" rel="noopener">中国判决文书网</a></p><p>简单起见，将多个罪名的调整为一个罪名；同时为了检查模型在 few-shot 任务中的表现，将罪名调成为 149 个完全不同的（每个罪名至少包含 10 个案例）。</p><p>随机选择了 40 万案例构建了三个不同量级的数据集，它们包含的罪名相同，只是数量不同。</p><h3 id="Attribute-Selection-and-Annotation"><a href="#Attribute-Selection-and-Annotation" class="headerlink" title="Attribute Selection and Annotation"></a>Attribute Selection and Annotation</h3><p>如何选择属性呢？</p><ul><li>训练一个基于 LSTM 的罪名预测模型，在验证集上得到预测结果的混淆矩阵。</li><li>筛选出相似罪名（标签相似）对，专家从中定义出 10 个能狗区分这些相似罪名的、有代表性的属性。</li><li>使用这 10 个属性对所有的罪名低成本标注，所谓的低成本意思是只对 149 个罪名手动标注，而不是对所有的案例进行标注。</li></ul><blockquote><p>全文最经典的部分了。很聪明、优雅的做法。</p></blockquote><h3 id="Baselines"><a href="#Baselines" class="headerlink" title="Baselines"></a>Baselines</h3><p>多个文本分类模型 + 一个罪名预测模型：</p><ul><li>TFIDF + SVM：TFIDF 提取特征</li><li>CNN</li><li>LSTM</li><li>Fact-Law Attention Model: Luo et al. (2017)</li></ul><h3 id="Experiment-Settings-and-Evaluation-Metrics"><a href="#Experiment-Settings-and-Evaluation-Metrics" class="headerlink" title="Experiment Settings and Evaluation Metrics"></a>Experiment Settings and Evaluation Metrics</h3><ul><li>max sequence length: 500</li><li>TFIDF feature size: 2000</li><li>Skip-Gram pre-train word embeddings (size 100)</li><li>LSTM hidden state size: 100</li><li>CNN filter (2, 3, 4, 5), filter size 25</li><li>α = 1</li><li>Adam</li><li>lr = 0.001</li><li>dropout = 0.5</li><li>batch size 64</li><li>Macro-F1</li></ul><h3 id="Results-and-Analysis"><a href="#Results-and-Analysis" class="headerlink" title="Results and Analysis"></a>Results and Analysis</h3><p><img src="http://qnimg.lovevivian.cn/paper-few-shot-charge-prediction-3.jpeg" alt=""></p><p>Few-Shot 任务的结果：（Low，≤ 10；High，&gt; 100）</p><p><img src="http://qnimg.lovevivian.cn/paper-few-shot-charge-prediction-4.jpeg" alt=""></p><h3 id="Ablation-Test"><a href="#Ablation-Test" class="headerlink" title="Ablation Test"></a>Ablation Test</h3><ul><li>取消注意力机制时，对每个属性，将注意力机制替换为全连接层。</li><li>取消属性感知表示时，退化为基于 LSTM 的典型多任务学习。</li></ul><p><img src="http://qnimg.lovevivian.cn/paper-few-shot-charge-prediction-5.jpeg" alt=""></p><h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><blockquote><p>江苏省南京市江宁区人民检察院指控，2013年4月2109时许， 被告人朱某在南京市江宁区横溪街道UNK社区美尚家具厂门前 ,因驾车问题与于某甲发生争执，后朱某纠集他人至美尚家 具厂车间内，持铁棍、斧子等工具对于某甲实施<strong>殴打，被害 人尤某在帮助于</strong>某甲抵挡时被砍伤，UNK某右侧顶骨骨折等 损伤经南京市公安局江宁分局法医鉴定，被害人尤某的损伤程度为轻伤</p></blockquote><p>这个案件被判为故意伤害罪，故意伤害罪和骚扰是一对相似类别，都和暴力有关。一个重要的区别就是故意伤害罪有 “身体伤害” 的特征。</p><p>所以 Physical Injury 这个属性在这里一定是非常重要的，事实上模型也正确预测了 Physical Injury 的 label 是 yes，最终的罪名也预测为 “故意伤害罪”，相反，LSTM-200 则把结果预测为 “骚扰”。</p><p>从下面的注意力热力图也可以看出，注意力机制能够捕获当前属性相关的关键模式和语义。</p><p><img src="http://qnimg.lovevivian.cn/paper-shot-charge-prediction-6.jpeg" alt=""></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>为解决 Few-Shot 和标签相似问题，引入了判别法律属性，提出了基于属性的多任务学习模型。具体来说，模型通过利用基于属性的注意力机制来共同学习无属性和属性感知的事实表示。进一步的探索方向包括：更复杂的案件判断（如多标签）和更复杂的罪名属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Paper: &lt;a href=&quot;http://nlp.csai.tsinghua.edu.cn/~tcc/publications/coling2018_attribute.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;coling2018_attribute.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;code: &lt;a href=&quot;https://github.com/thunlp/attribute_charge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;thunlp/attribute_charge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心思想：基于类别属性的注意力机制共同学习属性感知和无属性的文本表示。&lt;/p&gt;
&lt;p&gt;这是 COLING2018 上的一篇老论文了，最近因为一些事情正好遇上，当时大概看了一下就发现这篇文章正好解决了我之前在做多分类&lt;a href=&quot;https://github.com/hscspring/Multi-Label-Text-Classification-for-Chinese#others&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;任务&lt;/a&gt;时没有解决的问题。所以拿来记录一下，顺便研究下代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Feeling" scheme="https://www.yam.gift/categories/Feeling/"/>
    
    
      <category term="NLP" scheme="https://www.yam.gift/tags/NLP/"/>
    
      <category term="Few-Shot" scheme="https://www.yam.gift/tags/Few-Shot/"/>
    
      <category term="Imbalance Data" scheme="https://www.yam.gift/tags/Imbalance-Data/"/>
    
      <category term="Confusing Labels" scheme="https://www.yam.gift/tags/Confusing-Labels/"/>
    
  </entry>
  
  <entry>
    <title>关系提取简述</title>
    <link href="https://www.yam.gift/2019/12/11/KG/2019-12-11-Relationship-Extraction/"/>
    <id>https://www.yam.gift/2019/12/11/KG/2019-12-11-Relationship-Extraction/</id>
    <published>2019-12-11T15:00:00.000Z</published>
    <updated>2019-12-23T02:01:43.308Z</updated>
    
    <content type="html"><![CDATA[<p>之前整理过一篇关于信息提取的笔记，也是基于大名鼎鼎的 <a href="https://web.stanford.edu/~jurafsky/slp3/" target="_blank" rel="noopener">SLP</a> 第 18 章的内容，最近在做一个 chatbot 的 <a href="https://yam.gift/2019/12/02/2019-12-02-NLM/" target="_blank" rel="noopener">NLMLayer</a> 时涉及到了不少知识图谱有关的技术，由于 NLMLayer 默认的输入是 NLU 的 output，所以实体识别（包括实体和类别）已经自动完成了。接下来最重要的就是实体属性和关系提取了，所以这里就针对这块内容做一个整理。</p><p>属性一般的形式是（实体，属性，属性值），关系的一般形式是（实体，关系，实体）。简单来区分的话，关系涉及到两个实体，而属性只有一个实体。属性提取的文章比较少，关系提取方面倒是比较成熟，不过这两者之间其实可以借鉴的。具体的一些方法其实<a href="https://yam.gift/2019/04/09/SLP/2019-04-09-Information-Extraction/" target="_blank" rel="noopener">这里</a>已经提到不少了，这里单独提出来再梳理一遍。</p><a id="more"></a><h2 id="关系提取方法"><a href="#关系提取方法" class="headerlink" title="关系提取方法"></a>关系提取方法</h2><h3 id="基于模板"><a href="#基于模板" class="headerlink" title="基于模板"></a>基于模板</h3><p>这种方法比较简单，一般都是根据先验知识设计一些模式，然后在语料中匹配这些模式。举几个例子：</p><ul><li>马云作为企业家，对应的模式是：<code>XX (?:作为|是) YY</code></li><li>刘强东是京东的创始人，对应的模式是：<code>XX (?:作为|是) YY 的? ZZ</code></li></ul><p>这里的 XX YY 和 ZZ 自然就是前一步识别出来的实体了。</p><p>相关资源包括：</p><ul><li><a href="https://meta-guide.com/software-meta-guide/100-best-github-expert-system" target="_blank" rel="noopener">100 Best GitHub: Expert System | Meta-Guide.com</a></li></ul><h3 id="基于句法分析"><a href="#基于句法分析" class="headerlink" title="基于句法分析"></a>基于句法分析</h3><p>主要是找到主谓宾，一般都是在句法分析的基础上进行的。举几个例子：</p><ul><li>感冒是一种病，对应的句法结构为：感冒（SBV），是（Root），病（VOB）。</li><li>王思聪是王健林的儿子，对应的句法结构为：王思聪（SBV），是（Root），王健林（ATT），儿子（VOB）</li></ul><p>其中，SBV 是主谓关系，VOB 是动宾关系，ATT 是定中关系。</p><p>相关资源包括：</p><ul><li><a href="https://github.com/lemonhu/open-entity-relation-extraction" target="_blank" rel="noopener">lemonhu/open-entity-relation-extraction: Knowledge triples extraction and knowledge base construction based on dependency syntax for open domain text.</a></li><li><a href="https://github.com/aoldoni/tetre" target="_blank" rel="noopener">aoldoni/tetre: TETRE: a Toolkit for Exploring Text for Relation Extraction</a></li><li><a href="https://github.com/gabrielStanovsky/template-oie" target="_blank" rel="noopener">gabrielStanovsky/template-oie: Extract templated Open Information Extraction</a></li></ul><h3 id="基于机器学习"><a href="#基于机器学习" class="headerlink" title="基于机器学习"></a>基于机器学习</h3><p>使用基本步骤如下：</p><ul><li>（通常在一个句子中）寻找实体对</li><li>判断实体对之间是否存在关系</li><li>送到分类器判断关系的类别（预先定义好的）是什么</li></ul><p>标准流程：</p><ul><li>预先定义好类别集合</li><li>选择相关实体集合</li><li>标注</li><li>设计特征</li><li>训练分类器</li><li>评估结果</li></ul><p>特征：</p><ul><li>词相关</li><li>词法相关</li><li>句法相关</li><li>实体相关</li></ul><p>之前那篇笔记里涉及的比较全面，而且现在几乎都是结合深度学习模型做了，这块就不再赘述了。</p><p>相关资源：</p><ul><li><a href="https://github.com/machinalis/iepy" target="_blank" rel="noopener">machinalis/iepy: Information Extraction in Python</a></li><li><a href="https://github.com/marcolagi/quantulum" target="_blank" rel="noopener">marcolagi/quantulum: Python library for information extraction of quantities from unstructured text</a></li></ul><h3 id="基于深度学习"><a href="#基于深度学习" class="headerlink" title="基于深度学习"></a>基于深度学习</h3><p>一般包括两种做法：Pipeline 和 Joint model，前者就是把实体识别和关系分类分开；后者一起做。</p><p>特征一般是基于 Word embedding，Position embedding，POS，NER，WordNet；模型一般都是基于 CNN，RNN。</p><ul><li>端到端目前最好的是基于 Bert 的，在此之前，最好的是 Wang et al. 2016 的 Multi-Attention CNN。</li><li>关系分类最好的是 (Cai et al., 2016) 的 BRCNN（Bidirectional Recurrent Convolutional Neural Network）。</li></ul><p>从论文的趋势看，端到端相对主流一些，不过对于我们的需求来说，关系分类更适合些。更多相关论文和模型可以进一步阅读 <a href="https://github.com/sebastianruder/NLP-progress/blob/master/english/relationship_extraction.md" target="_blank" rel="noopener">NLP-progress/relationship_extraction</a>，这里就不贴那些论文的东西了。</p><h3 id="基于半监督"><a href="#基于半监督" class="headerlink" title="基于半监督"></a>基于半监督</h3><p>半监督是利用少量高精度的 pattern 种子或种子 tuple 来 bootstrap 一个分类器。具体而言，在大规模语料中查找包含已有 pattern 实体对的句子，然后提取和归纳实体的上下文来学习新的 pattern。</p><p>还是举个栗子，比如我们有一个种子 tuple：（Queen，创作了，波西米亚狂想曲），然后可能找到了这些句子：</p><ul><li>波西米亚狂想曲是由 Queen 演唱的歌曲。</li><li>波西米亚狂想曲是 Queen 最伟大的作品之一。</li><li>Queen 这首将近 6 分钟的波西米亚狂想曲包括四个部分。</li></ul><p>进而可以提取出类似这样的一些 pattern：</p><ul><li>（艺人，演唱，歌曲）</li><li>（歌曲，是，艺人，作品）</li><li>（艺人，作品，包括）</li></ul><p>这些 pattern 又可以进一步寻找新的 pattern（把艺人和歌曲替换掉）。最终算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function BOOTSTRAP(Relation R) returns new relation tuples</span><br><span class="line">tuples←Gather a set of seed tuples that have relation R</span><br><span class="line">iterate</span><br><span class="line">sentences←find sentences that contain entities <span class="keyword">in</span> tuples</span><br><span class="line">patterns←generalize the context between <span class="keyword">and</span> around entities <span class="keyword">in</span> sentences</span><br><span class="line">newpairs←use patterns to grep <span class="keyword">for</span> more tuples</span><br><span class="line">newpairs←newpairs <span class="keyword">with</span> high confidence</span><br><span class="line">tuples←tuples + newpairs</span><br><span class="line"><span class="keyword">return</span> tuples</span><br></pre></td></tr></table></figure><p>Bootstrapping 系统会给新的 pattern 一个置信度以避免语义飘移。比如 “在演唱会现场粉丝的要求下，周杰伦不得不演唱了一首网络歌曲《学猫叫》”，（周杰伦，演唱，学猫叫）显然不是我们想要的。关于置信度的计算可以参考上面提到的笔记，对一个 pattern 主要考量两方面因素：pattern 在现有 tuple 上的 hits 和在整个 Documents 上的 finds。</p><h3 id="基于远程监督"><a href="#基于远程监督" class="headerlink" title="基于远程监督"></a>基于远程监督</h3><p>远程监督从大规模数据库中获取的大量种子中产生出许多带噪声的 pattern features，然后用一个分类器组合这些 pattern。</p><p>举个栗子，比如要学习 “出生地-出生日期” 关系，半监督的方法中，我们可能只有少量几个启动的种子，但是现在我们可以在 Wikipedia-based 数据库（比如 DBPedia 或 Freebase） 中获取大量包含 “出生地-出生日期” 的 tuple，比如（<code>&lt;Albert Einstein, Ulm&gt;, &lt;Hubble, Marshfield&gt;</code> 等等）。然后用命名实体工具提取包含两个实体并 match 给定 tuple 的句子：</p><ul><li>Hubble 出生于 Marshfield</li><li>Einstein，生于 1879，Ulm</li><li>Hubble 的出生地是 Marshfield</li></ul><p>可以从中提取训练集，一个训练实例对应一个（关系，实体1，实体2）。</p><ul><li><code>&lt;出生地, Edwin Hubble, Marshfield&gt;</code></li><li><code>&lt;出生地, Albert Einstein, Ulm&gt;</code></li><li><code>&lt;出生日期, Albert Einstein, 1879&gt;</code></li></ul><p>接下来可以用基于特征的分类器或直接使用神经网络分类器（不需要构建特征）。对于前者，可以从多个方面构建特征，比如实体 label，实体间单词、路径，相邻词等。每个 tuple 包括多个训练实例的特征，每个实例又可以从多个句子中获取词法和句法特征。最终的算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function DISTANT SUPERVISION(Database D, Text T) returns relation classifier C</span><br><span class="line">foreach relation R</span><br><span class="line">foreach tuple (e1,e2) of entities <span class="keyword">with</span> relation R <span class="keyword">in</span> D</span><br><span class="line">sentences←Sentences <span class="keyword">in</span> T that contain e1 <span class="keyword">and</span> e2</span><br><span class="line">f←Frequent features <span class="keyword">in</span> sentences</span><br><span class="line">observations←observations + new training tuple (e1, e2, f, R)</span><br><span class="line">C←Train supervised classifier on observations</span><br><span class="line"><span class="keyword">return</span> C</span><br></pre></td></tr></table></figure><p>最终的分类器将会根据特征发现关系。</p><h3 id="基于无监督"><a href="#基于无监督" class="headerlink" title="基于无监督"></a>基于无监督</h3><p>无监督关系提取的目的就是在没有标注数据，甚至没有任何关系列表的情况下从 Web 或大规模语料中提取关系。这个任务一般叫 open information extraction 或 Open IE，关系通常都是几个单词（常以动词开头）。</p><p><a href="http://reverb.cs.washington.edu/" target="_blank" rel="noopener">ReVerb</a> 系统（类似项目：<a href="https://openie.allenai.org/" target="_blank" rel="noopener">Open Information Extraction</a>）从一个句子中提取关系一般包括四步：</p><ul><li>在句子上进行 POS 和实体识别。</li><li>对句中每个动词，找到以动词开头并满足句法和词汇约束（合并相邻匹配项）的最长单词序列 w。</li><li>对每个短语 w，找到最左边的名词短语 x（不是相对代词，wh-单词或 “there”），在右边找到最近的名词短语 y。</li><li>使用置信度分类器（一个逻辑回归分类器）给关系 r=x, w, y) 一个置信度。</li></ul><p>分类器是在 1000 个随机选择的句子上训练所得，首先提取关系，然后人工标注是否正确，最后训练分类器。使用到的一些特征如下（将提取到的关系及周围的词作为特征）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(x,r,y) covers all words in s</span><br><span class="line">the last preposition in r is for</span><br><span class="line">the last preposition in r is on</span><br><span class="line">len(s) ≤ 10</span><br><span class="line">there is a coordinating conjunction to the left of r in s</span><br><span class="line">r matches a lone V in the syntactic constraints</span><br><span class="line">there is preposition to the left of x in s</span><br><span class="line">there is an NP to the right of y in s</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><div class="table-container"><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>模板</td><td>精准高，领域内可定制</td><td>召回低，耗时耗力</td></tr><tr><td>句法分析</td><td>构建简单</td><td>召回低，与句法结果相关</td></tr><tr><td>机器学习</td><td>数据相关时精准较高</td><td>特征工程较复杂，数据标注成本较高，训练数据敏感</td></tr><tr><td>深度学习</td><td>数据相关时精准高，泛化能力较好</td><td>数据标注成本很高，训练数据敏感</td></tr><tr><td>半监督 Bootstrapping</td><td>成本低，可以发现新关系</td><td>对初始种子敏感，语义飘移，准确率低</td></tr><tr><td>远程监督</td><td>精准高，训练数据不敏感，无语义飘移</td><td>依赖已有数据库</td></tr><tr><td>无监督</td><td>成本很低，容易实现</td><td>需转为权威格式存储，动词为中心的局限性</td></tr></tbody></table></div><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><p>比赛最有名的大概就是 <a href="https://competitions.codalab.org/competitions/17326" target="_blank" rel="noopener">SemEval 2018 Task 10</a> 和 <a href="https://www.aclweb.org/anthology/S10-1006.pdf" target="_blank" rel="noopener">SemEval-2010 Task 8</a> 了。前者是一个二分类任务，目的是识别给定属性能否区分两个给定的概念。</p><div class="table-container"><table><thead><tr><th>Attribute</th><th>concept1</th><th>concept2</th><th>label</th></tr></thead><tbody><tr><td>bookcase</td><td>fridge</td><td>wood</td><td>1</td></tr><tr><td>bucket</td><td>mug</td><td>round</td><td>0</td></tr><tr><td>angle</td><td>curve</td><td>sharp</td><td>1</td></tr><tr><td>pelican</td><td>turtle</td><td>water</td><td>0</td></tr><tr><td>wire</td><td>coil</td><td>metal</td><td>0</td></tr></tbody></table></div><p>后者是关系分类任务，给定两个标记的 nominals，预测它们的关系和关系的方向。</p><blockquote><p>There were apples, <strong>pears</strong> and oranges in the <strong>bowl</strong>.</p></blockquote><p><code>(content-container, pears, bowl)</code></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>除了上面的两个比赛的数据集，还有以下一些数据集：</p><ul><li><a href="http://www.zhuhao.me/fewrel/" target="_blank" rel="noopener">FewRel: A Large-Scale Supervised Few-shot Relation Classification Dataset with State-of-the-Art Evaluation</a><ul><li>70K sentences</li><li>100 relations</li><li>Wikipedia corpus</li></ul></li><li><a href="https://catalog.ldc.upenn.edu/LDC2008T19" target="_blank" rel="noopener">The New York Times Annotated Corpus - Linguistic Data Consortium</a><ul><li>Stanford NER 提取实体</li><li>自动与 Freebase knowledge base 中的实体关联</li><li>关系也是基于 Freebase knowledge base 中的事实</li></ul></li><li><a href="https://nlp.stanford.edu/projects/tacred/" target="_blank" rel="noopener">Stanford TACRED Homepage</a><ul><li>106,264 examples</li><li>newswire and web text from <a href="https://catalog.ldc.upenn.edu/LDC2018T03" target="_blank" rel="noopener">TAC KBP Comprehensive English Source Corpora 2009-2014 - Linguistic Data Consortium</a></li><li>41 relation types as used in the <a href="https://tac.nist.gov/2017/KBP/index.html" target="_blank" rel="noopener">TAC KBP challenges</a></li></ul></li></ul><h2 id="评价方法"><a href="#评价方法" class="headerlink" title="评价方法"></a>评价方法</h2><p>评价指标还是以 F1 为主：</p><ul><li>属性判别是二分类任务，直接用 F1 评估。</li><li>关系分类使用 Macro-averaged F1（9 个关系，不包括 OTHER，考虑关系方向）。</li><li>FewRel 主要是在 5-way-1-shot，5-way-5-shot，10-way-1-shot 和 10-way-5-shot 几个任务上的准确率。</li><li>NYT 主要使用 N 个结果的精准率或 PR 图。</li><li>TACRED 使用 Micro-averaged F1（不包括 no_relation type）。</li></ul><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p>CrowdTruth Corpus 相关：</p><ul><li><a href="https://github.com/CrowdTruth/CrowdTruth-core" target="_blank" rel="noopener">CrowdTruth/CrowdTruth-core: CrowdTruth framework for crowdsourcing ground truth for training &amp; evaluation of AI systems</a></li><li><a href="https://github.com/CrowdTruth/Open-Domain-Relation-Extraction" target="_blank" rel="noopener">CrowdTruth/Open-Domain-Relation-Extraction: Crowdsourced data for open domain relation classification from sentences</a></li><li><a href="https://github.com/CrowdTruth/Medical-Relation-Extraction" target="_blank" rel="noopener">CrowdTruth/Medical-Relation-Extraction: Crowdsourced ground truth for medical relation extraction.</a></li></ul><p>其他资源：</p><ul><li><a href="https://github.com/roomylee/awesome-relation-extraction" target="_blank" rel="noopener">roomylee/awesome-relation-extraction: 📖 A curated list of awesome resources dedicated to Relation Extraction, one of the most important tasks in Natural Language Processing (NLP).</a></li><li><a href="https://github.com/sebastianruder/NLP-progress/blob/master/english/relationship_extraction.md" target="_blank" rel="noopener">NLP-progress/relationship_extraction.md at master · sebastianruder/NLP-progress</a></li></ul><p>参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/44772023" target="_blank" rel="noopener">知识抽取-实体及关系抽取 - 知乎</a></li><li><a href="https://blog.csdn.net/pelhans/article/details/80020309" target="_blank" rel="noopener">知识图谱入门 (三) 知识抽取 - pelhans 的博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前整理过一篇关于信息提取的笔记，也是基于大名鼎鼎的 &lt;a href=&quot;https://web.stanford.edu/~jurafsky/slp3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SLP&lt;/a&gt; 第 18 章的内容，最近在做一个 chatbot 的 &lt;a href=&quot;https://yam.gift/2019/12/02/2019-12-02-NLM/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NLMLayer&lt;/a&gt; 时涉及到了不少知识图谱有关的技术，由于 NLMLayer 默认的输入是 NLU 的 output，所以实体识别（包括实体和类别）已经自动完成了。接下来最重要的就是实体属性和关系提取了，所以这里就针对这块内容做一个整理。&lt;/p&gt;
&lt;p&gt;属性一般的形式是（实体，属性，属性值），关系的一般形式是（实体，关系，实体）。简单来区分的话，关系涉及到两个实体，而属性只有一个实体。属性提取的文章比较少，关系提取方面倒是比较成熟，不过这两者之间其实可以借鉴的。具体的一些方法其实&lt;a href=&quot;https://yam.gift/2019/04/09/SLP/2019-04-09-Information-Extraction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;已经提到不少了，这里单独提出来再梳理一遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="NLP" scheme="https://www.yam.gift/tags/NLP/"/>
    
      <category term="Knowledge Graph" scheme="https://www.yam.gift/tags/Knowledge-Graph/"/>
    
      <category term="Relationship Extraction" scheme="https://www.yam.gift/tags/Relationship-Extraction/"/>
    
  </entry>
  
  <entry>
    <title>AINLP GPU 使用体验指南</title>
    <link href="https://www.yam.gift/2019/12/09/2019-12-09-AINLP-GPU-Guide/"/>
    <id>https://www.yam.gift/2019/12/09/2019-12-09-AINLP-GPU-Guide/</id>
    <published>2019-12-09T13:00:00.000Z</published>
    <updated>2019-12-09T12:49:20.106Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gpu.ainlp.cn/home" target="_blank" rel="noopener">AINLP-DBC GPU</a> 是一个 GPU 算力服务平台，采用 DBC TOKEN 进行结算。在这里可以租用 GPU，也可以将自己的 GPU 出租出去。</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>第一步：<a href="https://gpu.ainlp.cn/gpu/myWallet" target="_blank" rel="noopener">创建钱包</a></p><p>这里需要输入密码，之后会产生一个加密后的私钥文件，下载继续后会产生你真正的私钥。一定要记住你的密码并在物理介质上保存好加密后的私钥文件以及你的私钥。只有通过密码+加密的私钥文件，或者私钥才能打开你的钱包，如果都丢了，就等于你的钱包没了。</p><p>第二步：充值 DBC</p><p>点击 “如何购买 DBC” 链接，选择自己喜欢的方式充值即可，推荐使用支付宝，点击 “继续” 后，充值一定金额（比如 1块或者 0.1 块）就好了。这步其实就是给你的钱包地址充值一定数额的 DBC。大概等个几十秒就能在 “我的钱包” 里看到你购买金额对应的 DBC 数量了。</p><p>第三步：<a href="https://gpu.ainlp.cn/gpu/myMachineUnlock" target="_blank" rel="noopener">绑定邮箱</a></p><p>点击 “绑定邮箱” 后，输入邮箱地址，会给你发送一个类似 <code>请输入如下数量dbc:0.7311,验证有效期为30分钟</code> 内容的邮件，将对应的额度（比如这里的 0.7311）输入 “验证的 DBC 数量” 框即可完成绑定。</p><p>第四步：<a href="https://gpu.ainlp.cn/gpu/list" target="_blank" rel="noopener">选择机器</a></p><p>在列表中选择一台符合自己要求的机器，点击 “租用” 后，填写租用时长（最短 1 小时），等待大约 1 分钟左右（验证机器环境），确认支付后就可以正式使用了。</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在使用之前有一点必须先特别强调下：当你所用的机子过了租用时间后，你是【<strong>没办法再登陆的</strong>】。所以一定要及时做好相关文件的保存、传输（后面会说到具体方法，邮件中也有这块内容），别训练了半天最后啥都没了。</p><p>当支付成功后，会有一封邮件发送到你的邮箱，这封邮件里包含了很多信息，主要包括：</p><ul><li>机器的 SSH 登陆信息</li><li>环境配置信息</li><li>注意事项</li><li>常见问题汇总</li></ul><blockquote><p>需要说明下，下面所有 <strong>“本地机器”</strong> 的操作都是在 Mac 下执行的，Linux 应该类似，Windows 可能会稍微不同，大家注意按需调整。</p></blockquote><h3 id="登陆-ssh"><a href="#登陆-ssh" class="headerlink" title="登陆 ssh"></a>登陆 ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 52909 root@110.80.33.140</span><br><span class="line">The authenticity of host <span class="string">'[110.80.33.140]:52909 ([110.80.33.140]:52909)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:Nsub+uKd2LK7XmjB/n91gRXNk2sJOAX7PnXF7vZkhWU.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>[110.80.33.140]:52909<span class="string">' (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">root@110.80.33.140'</span>s password:</span><br></pre></td></tr></table></figure><p>这里先输入 yes，然后输入邮件中的密码，就可以直接登陆到远程机器里面了。接下来，这台机子就是你的了。你可以把它当做自己的本地电脑一样使用。</p><p>如果你租用的时间不长，那密码改不改问题不大，否则你需要修改一下登陆密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><p>然后输入你的新密码即可。<code>exit</code> 退出后，应该可以用你的新密码重新登陆了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 52909 root@110.80.33.140</span><br></pre></td></tr></table></figure><p>如果你租用的时间非常非常长，那你可能需要把你自己本地的公钥添加到远程机器，这样每回也不用输入密码了。首先你看自己的 <code>~/.ssh/</code> 目录下面有没有类似 <code>id_rsa.pub</code> 这样的文件，如果有的话，这个文件就是你的公钥了。如果没有，你需要生成一下自己的公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure><p>按提示就可以生成了。默认会在刚刚提到的目录下面生成一个 <code>id_rsa.pub</code> 的文件，把文件内容复制粘贴到服务器的 <code>~/.ssh/authorized_keys</code> 里面即可，复制完成后，该文件看起来是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlIDJhabMAPo2Gxxx..... xxxxx@gmail.com</span><br><span class="line">ssh-rsa</span><br></pre></td></tr></table></figure><p>这里可以添加多个 key，你要是有多台需要登录的本地机子，可以把它们的 public key 都放到这里，每个一行。此时你就可以不用密码直接登录了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 52909 root@110.80.33.140</span><br></pre></td></tr></table></figure><p>如果你还觉得输入的东西太长，可以给远程机器配置一个别名，具体来说，在本地的 <code>~/.ssh</code> 目录下新建一个 <code>config</code> 文件，然后输入下面的内容保存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host remote <span class="comment"># 随便起个什么名字都可以，我这里起了个 remote</span></span><br><span class="line">HostName 110.80.33.140</span><br><span class="line">User root</span><br><span class="line">Port 52909</span><br></pre></td></tr></table></figure><p>这时候，你就可以用你起得名字登陆了，效果就是下面这个样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh remote</span><br><span class="line">Welcome to Ubuntu 16.04.4 LTS (GNU/Linux 4.4.0-169-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line">Last login: Mon Dec  9 19:22:05 2019 from 125.119.237.196</span><br><span class="line">(base) root@7977d9bc0881:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>首先，我们讲一下 Screen，这里有一份教程可以了解下：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-screen/index.html" target="_blank" rel="noopener">linux 技巧：使用 screen 管理你的远程会话</a>，如果觉得教程太长，那只要记住下面几个命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建：screen -S name（随便输一个名字）</span></span><br><span class="line"><span class="comment"># 查看：screen -ls</span></span><br><span class="line"><span class="comment"># 进入：screen -r name（随便输的那个名字）</span></span><br><span class="line"><span class="comment"># 退回到命令行，让程序在 screen 后台自动运行：Control + a + d</span></span><br></pre></td></tr></table></figure><p>先查看一下，就会发现已经有一个在运行的 screen 了，这个可以理解，其实就是邮件中给的那个 jupyter notebook。这里我们可以创建很多个 screen，比如创建两个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ screen -ls</span><br><span class="line">There are screens on:</span><br><span class="line">6541.another    (12/09/19 19:33:02)(Detached)</span><br><span class="line">5939.new(12/09/19 19:32:29)(Detached)</span><br></pre></td></tr></table></figure><p>然后我们可以进入自己创建的 screen，注意如果用 <code>exit</code> 退出的话就彻底退出这个 screen 了。</p><p>当然，我们还可以再创建一个 jupyter notebook：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ screen - S jp</span><br><span class="line">$ jupyter-notebook password <span class="comment"># 设置一个密码</span></span><br><span class="line">$ nohup jupyter notebook --ip 0.0.0.0 --port 8889 --no-browser --allow-root &gt; jupyter.log 2&gt;&amp;1 &amp; <span class="comment"># 注意换一个端口</span></span><br></pre></td></tr></table></figure><p>然后在邮箱中给的那个 jupyter notebook 的端口上加 1，输入刚刚设置的密码，就可以登录新的 jupyter notebook 了：</p><p><img src="http://qnimg.lovevivian.cn/jupyter-notebook-screen-snapshot-1.jpeg" alt=""></p><p>接下来看一下 GPU 的配置，有个最基本的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br><span class="line"></span><br><span class="line">Mon Dec  9 19:35:02 2019</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 430.50       Driver Version: 430.50       CUDA Version: 10.1     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  P102-100            On   | 00000000:02:00.0 Off |                  N/A |</span><br><span class="line">| 71%   35C    P8     8W / 250W |      0MiB / 10156MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>然后是机器的监控信息，我们一般使用 <a href="https://github.com/hishamhm/htop" target="_blank" rel="noopener">htop</a>，不过需要安装一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install htop</span><br><span class="line">$ htop</span><br></pre></td></tr></table></figure><p>大概就长这个样子（退出按 q 即可）：<img src="http://qnimg.lovevivian.cn/htop-screen-snap-1.jpeg" alt=""></p><p>Linux 下面还有很多工具，这块不是重点，如果对相关的内容感兴趣，可以看<a href="https://github.com/hscspring/AIToolBox" target="_blank" rel="noopener">这里</a>。</p><p>其他一些配置相关的查看可以查看邮件中的【常见问题汇总】。</p><h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><p>推荐使用 <a href="https://github.com/libfuse/sshfs" target="_blank" rel="noopener">libfuse/sshfs: A network filesystem client to connect to SSH servers</a>，直接把远程机器上的文件夹挂载到本地，当然首先你需要根据 README 在本地机器上安装好，然后就很简单了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># remote_gpu 是我随便建的一个文件夹，你可以挂载到任意文件夹</span></span><br><span class="line">$ sshfs -p 52909 root@110.80.33.140:/root/code ~/Documents/remote_gpu</span><br></pre></td></tr></table></figure><p>这样你就把远程机器的 <code>/root/code/</code> 目录挂载到本地机器的 <code>~/Documents/remote_gpu</code> 下了。如果你想取消挂载也很简单（注意不能在该目录执行，随便换个其他目录即可）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umount ~/Documents/remote_gpu</span><br></pre></td></tr></table></figure><p>一旦你挂载好了，这两台机器的文件夹就可以看做同一个文件夹了，无论你在哪边操作，另外一边都会发生相同的变更。比如我在本地把一个文件复制到 <code>~/Documents/remote_gpu</code> 里面，实际上相当于直接传输到远程机器的 <code>/root/code</code> 下面。</p><p>这里需要注意三点：</p><ul><li>操作会有延时，肯定没有你本地复制文件夹那么快。</li><li>如果文件很大，强烈建议<code>压缩后</code>传输同步。也就是说，你可以只把训练完成后需要的文件压缩后，放到这个同步目录，这样可以省时间。</li><li>远程机器到时间后会强制自动退出，此时本地机器的文件也会丢失（因为它本质还在远程），所以记得及时把文件复制到本地。最简单的方法是用 <a href="https://tecadmin.net/crontab-in-linux-with-20-examples-of-cron-schedule/" target="_blank" rel="noopener">Crontab</a> 创建个定时复制任务（如果碰到创建不成功的情况，可以看看<a href="https://stackoverflow.com/questions/22743548/cronjob-not-running" target="_blank" rel="noopener">这个</a>）。</li></ul><p>当然，如果你觉得很麻烦的话，也可以直接用 scp，这个更简单，可以参考这里：<a href="https://www.vpser.net/manage/scp.html" target="_blank" rel="noopener">Linux SSH 远程文件传输命令 scp - VPS 侦探</a>。如果想同步到云盘的，可以参考邮件中的【常见问题汇总】。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这是一个远程服务器使用的小小指南，主要针对那些对类 Unix 操作系统不太熟悉的同学，这些内容也只能算是非常基础的入门知识了。<a href="https://gpu.ainlp.cn/home" target="_blank" rel="noopener">AINLP</a> 推出的这个服务无论使用还是性价比都是值得推荐的：对前者，在你购买时长期间内，这台机器等于完全是你独占的，你可以随意 DIY 这台机子；对后者，大部分机器的价格都是 1.5 元/小时 的样子，配置低一些的只要 0.5元/小时 左右，这个价格在目前是相当有竞争力的，说实话电费可能都不止这个价。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://gpu.ainlp.cn/home&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AINLP-DBC GPU&lt;/a&gt; 是一个 GPU 算力服务平台，采用 DBC TOKEN 进行结算。在这里可以租用 GPU，也可以将自己的 GPU 出租出去。&lt;/p&gt;
&lt;h2 id=&quot;注册&quot;&gt;&lt;a href=&quot;#注册&quot; class=&quot;headerlink&quot; title=&quot;注册&quot;&gt;&lt;/a&gt;注册&lt;/h2&gt;&lt;p&gt;第一步：&lt;a href=&quot;https://gpu.ainlp.cn/gpu/myWallet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;创建钱包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里需要输入密码，之后会产生一个加密后的私钥文件，下载继续后会产生你真正的私钥。一定要记住你的密码并在物理介质上保存好加密后的私钥文件以及你的私钥。只有通过密码+加密的私钥文件，或者私钥才能打开你的钱包，如果都丢了，就等于你的钱包没了。&lt;/p&gt;
&lt;p&gt;第二步：充值 DBC&lt;/p&gt;
&lt;p&gt;点击 “如何购买 DBC” 链接，选择自己喜欢的方式充值即可，推荐使用支付宝，点击 “继续” 后，充值一定金额（比如 1块或者 0.1 块）就好了。这步其实就是给你的钱包地址充值一定数额的 DBC。大概等个几十秒就能在 “我的钱包” 里看到你购买金额对应的 DBC 数量了。&lt;/p&gt;
&lt;p&gt;第三步：&lt;a href=&quot;https://gpu.ainlp.cn/gpu/myMachineUnlock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;绑定邮箱&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击 “绑定邮箱” 后，输入邮箱地址，会给你发送一个类似 &lt;code&gt;请输入如下数量dbc:0.7311,验证有效期为30分钟&lt;/code&gt; 内容的邮件，将对应的额度（比如这里的 0.7311）输入 “验证的 DBC 数量” 框即可完成绑定。&lt;/p&gt;
&lt;p&gt;第四步：&lt;a href=&quot;https://gpu.ainlp.cn/gpu/list&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;选择机器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在列表中选择一台符合自己要求的机器，点击 “租用” 后，填写租用时长（最短 1 小时），等待大约 1 分钟左右（验证机器环境），确认支付后就可以正式使用了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Feeling" scheme="https://www.yam.gift/categories/Feeling/"/>
    
    
      <category term="Computer" scheme="https://www.yam.gift/tags/Computer/"/>
    
      <category term="ssh" scheme="https://www.yam.gift/tags/ssh/"/>
    
      <category term="GPU" scheme="https://www.yam.gift/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>ELECTRA, Pre-Training Text Encoders as Discriminators Rather Than Generators Note</title>
    <link href="https://www.yam.gift/2019/12/08/Paper/2019-12-08-ELECTRA-Paper/"/>
    <id>https://www.yam.gift/2019/12/08/Paper/2019-12-08-ELECTRA-Paper/</id>
    <published>2019-12-08T14:00:00.000Z</published>
    <updated>2019-12-08T13:48:06.706Z</updated>
    
    <content type="html"><![CDATA[<p>Paper: <a href="https://openreview.net/pdf?id=r1xMH1BtvB" target="_blank" rel="noopener">ELECTRA: PRE-TRAINING TEXT ENCODERS AS DISCRIMINATORS RATHER THAN GENERATORS</a></p><p>本来代码还没出来不想看的，不过前段时间确实太火了，先偷偷瞄一眼，看看到底是什么个情况。</p><p>核心思想：Replaced token detection Task + Transformer。</p><a id="more"></a><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>相比 MLM（Masked Language Modeling）的改进是：将 Mask 改为一个生成器生成的 token（看起来似乎是真的），然后用一个判别器识别每个 token 是否是生成器生成的。</p><blockquote><p>这想法不就是 GAN 么，能想到这种骚操作也是够机智的。</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Bert 使用了 Masked LM，XLNet 使用了 PermutationLM。本文使用了替换 token 检测，这些替换的 token 生成自一个 MLM 模型，解决了 Bert 预训练与精调由于人工 Mask 带来的效果差异；同时由于判别器是针对每一个 token 的，比起 MLM 的 15% 在计算上更有效率。作者这里也提到了，虽然很像 GAN，但其实并不是，他们的生成器是用极大似然训练的。</p><p>本文的模型被称为：ELECTRA，即 Efficiently Learning an Encoder that Classifies Token Replacements Accurately，结果无论是计算还是参数方面都比现有模型更有效率。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="http://qnimg.lovevivian.cn/paper-electra-1.jpeg" alt=""></p><p>训练了两个网络：生成器 G 和判别器 D，均包含了一个 Transformer 的 encoder（将 input 的序列表示成隐向量表示）。给定位置 t，G 接 softmax 生成 xt：</p><script type="math/tex; mode=display">p_{G}\left(x_{t} | \boldsymbol{x}\right)=\exp \left(e\left(x_{t}\right)^{T} h_{G}(\boldsymbol{x})_{t}\right) / \sum_{x^{\prime}} \exp \left(e\left(x^{\prime}\right)^{T} h_{G}(\boldsymbol{x})_{t}\right)</script><p>e 表示 token embedding。</p><p>对给定位置 t，D 判断 xt 来自 G 还是原始的数据分布：</p><script type="math/tex; mode=display">D(\boldsymbol{x}, t)=\operatorname{sigmoid}\left(w^{T} h_{D}(\boldsymbol{x})_{t}\right)</script><p>G 用来执行 MLM，给定输入序列 X（x1…xn），首先随机选择一组（15%）mask 的位置，这些位置的 token 被替换为 <code>[MASK]</code>，G 要学习最大化 masked-out tokens 的似然，D 要区分被 G 生成的 sample 替换的 token。具体而言，通过替换 masked-out tokens 为 generator samples 创建损坏的 X 序列，然后训练判别器来识别 X 中的 tokens 和原始的 input 序列是否匹配。</p><p>形式上看：</p><script type="math/tex; mode=display">m_{i} \sim \text { unif }\{1, n\} \text { for } i=1 \text { to } k</script><script type="math/tex; mode=display">\boldsymbol{x}^{\mathrm{masked}}=\operatorname{REPLACE}(\boldsymbol{x}, \boldsymbol{m},[\mathrm{MASK}])</script><script type="math/tex; mode=display">\hat{x}_{i} \sim p_{G}\left(x_{i} | \boldsymbol{x}^{\text {masked }}\right) \text { for } i \in \boldsymbol{m}</script><script type="math/tex; mode=display">\boldsymbol{x}^{\text {corrupt }}=\operatorname{REPLACE}(\boldsymbol{x}, \boldsymbol{m}, \hat{\boldsymbol{x}})</script><script type="math/tex; mode=display">\mathcal{L}_{\mathrm{MLM}}\left(\boldsymbol{x}, \theta_{G}\right)=\mathbb{E}\left(\sum_{i \in m}-\log p_{G}\left(x_{i} | \boldsymbol{x}^{\mathrm{masked}}\right)\right)</script><script type="math/tex; mode=display">\mathcal{L}_{\mathrm{Disc}}\left(\boldsymbol{x}, \theta_{D}\right)=\mathbb{E}\left(\sum_{t=1}^{n} \mathbb{1}\left(x_{t}^{\mathrm{corrupt}}=x_{t}\right) \log D\left(\boldsymbol{x}^{\mathrm{corrupt}}, t\right)+\mathbb{1}\left(x_{t}^{\mathrm{corrupt}} \neq x_{t}\right) \log \left(1-D\left(\boldsymbol{x}^{\mathrm{corrupt}}, t\right)\right)\right)</script><script type="math/tex; mode=display">\min _{\theta_{G}, \theta_{D}} \sum_{\boldsymbol{x} \in \mathcal{X}} \mathcal{L}_{\mathrm{MLM}}\left(\boldsymbol{x}, \theta_{G}\right)+\lambda \mathcal{L}_{\mathrm{Disc}}\left(\boldsymbol{x}, \theta_{D}\right)</script><p>与 GAN 的不同点：</p><ul><li>如果 G 生成的 sample 是原始的 token，这个 token 将被看作 “real” 而不是 “fake”</li><li>G 用极大似然法训练而不是对抗方法去迷惑 D</li><li>G 的 input 不是 GAN 中的噪声向量</li></ul><p>另外：</p><ul><li>D 的 loss 没有反向传播到 G</li><li>预训练后丢掉 G，在下游任务上精调 D</li></ul><p>不熟悉 GAN 的可以看<a href="https://nbviewer.jupyter.org/github/hscspring/AI-Methods/blob/master/Gan-Tutorial/Gan.ipynb" target="_blank" rel="noopener">这里</a>。</p><blockquote><p>近很长一段时间以来看论文都发现 Method 篇幅越来越小，实验导向很明显。不过作为工程师，我们只关注思想和最后的应用，实验还是交给这些研究机构吧。</p></blockquote><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>所以这块我们记录一下关键点，过一下就行了。</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>Dataset: GLUE, SQuAD</p><p>Training Data: Bert (most), XLNet (Large)</p><p>Model architecture and most hyper-parameters: Bert</p><p>Small evaluation dataset with the median of 10 fine-tuning runs</p><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p><strong>Weight Sharing</strong>: 小的 Generator 更有效，因此只共享了 D 和 G 的 embeddings（token + position）。</p><p><strong>Smaller Generators</strong>: 主要通过减少 layer size 缩小模型，G 的 size 是 D size 的 1/4-1/2 时效果最好，作者猜测太强的 G 会阻止 D 进行有效地学习，具体而言就是 D 的大量参数用来给 G 建模，而不是真实的数据分布。</p><p><strong>Training Algorithms</strong>: 推荐联合训练 G 和 D，但作者还尝试了其他的训练方法：</p><ul><li>两步训练：训练 n 步 G，用 G 的参数初始化 D（G 和 D 大小一样），固定 G 的参数，训练 n 步 D。这种方法有时候甚至无法学习，作者猜测可能是 G 超过 D 太多。</li><li>像 GAN 一样训练 G：使用强化学习适应离散的采样。效果不如采用极大似然，作者猜想主要是以下原因（也是 GAN 在文本训练中已经观察到的问题）：<ul><li>对抗训练的 G 在 MLM 上更差，主要是强化学习在文本生成的大的操作空间下采样效率太低。</li><li>对抗训练的 G 会产生多峰低熵分布（大部分概率聚集在单个 token 上），意味着 G 的 sample 缺乏多样性。</li></ul></li></ul><h3 id="Small"><a href="#Small" class="headerlink" title="Small"></a>Small</h3><p>sequence length: 512 -&gt; 128</p><p>batch size: 256 -&gt; 128</p><p>model hidden dimension: 768 -&gt; 256</p><p>embeddings: 768 -&gt; 128</p><h3 id="Large"><a href="#Large" class="headerlink" title="Large"></a>Large</h3><p>400k steps with batch size 2048 on the XLNet data</p><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><ul><li>ELECTRA 15%: D 的 loss 只来自 15% 的 masked tokens</li><li>Replace MLM: 与 MLM 一致，除了将 masked-out tokens 替换为 G 的 samples</li><li>All-Tokens MLM: 除了与 Replace MLM 一致外，预测 inputs 中的所有 tokens，而不只是 masked tokens</li></ul><p><img src="http://qnimg.lovevivian.cn/paper-electra-2.jpeg" alt=""></p><p>All-Tokens MLM 造成了与 Bert 相比的大部分 gap。另外，模型越小，ELECTRA 超过 Bert 越多。</p><h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>Related</h2><p><strong>Self-Supervised Pre-training for NLP</strong></p><ul><li>Word2Vec: 词表示，CBOW，Skip-gram</li><li>ELMO: 双向 LM（Bi-LSTM）+ 下游任务（首次两阶段）</li><li>GPT: 单向 LM + Transformer + 下游任务（首次 Transformer）</li><li>Bert: 双向 LM（MLM） + Transformer + 多任务 + 下游任务<ul><li>MASS and UniLM extend BERT to generation tasks by adding auto-regressive generative training objectives</li><li>ERNIE 和 SpanBERT mask 连续的 token</li><li>RoBERTa 剔除了 NSP 任务，使用了动态 Mask</li><li>DistilBERT 是蒸馏版本</li></ul></li><li>XLNet: 双向 LM（PLM）+ Transformer + 下游任务<ul><li>XLNet masks attention weights such that the input sequence is auto-regressively generated in a random order</li></ul></li><li>ELECTRA: 双向 LM（Replaced token detection）+ Transformer + 下游任务</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>为语言表示学习提出一种新的 self-supervised 任务：replaced token detection，核心思想是训练一个 text encoder 来区别 input 的 token 和一个小的 Generator 生成的高质量的 negative sample。相比 MLM 训练效率更高，且在下游任务取得更好的表现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Paper: &lt;a href=&quot;https://openreview.net/pdf?id=r1xMH1BtvB&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ELECTRA: PRE-TRAINING TEXT ENCODERS AS DISCRIMINATORS RATHER THAN GENERATORS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来代码还没出来不想看的，不过前段时间确实太火了，先偷偷瞄一眼，看看到底是什么个情况。&lt;/p&gt;
&lt;p&gt;核心思想：Replaced token detection Task + Transformer。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Feeling" scheme="https://www.yam.gift/categories/Feeling/"/>
    
    
      <category term="NLP" scheme="https://www.yam.gift/tags/NLP/"/>
    
      <category term="Transformer" scheme="https://www.yam.gift/tags/Transformer/"/>
    
      <category term="Pre-training" scheme="https://www.yam.gift/tags/Pre-training/"/>
    
      <category term="Electra" scheme="https://www.yam.gift/tags/Electra/"/>
    
  </entry>
  
  <entry>
    <title>自然语言记忆模块（NLM）</title>
    <link href="https://www.yam.gift/2019/12/02/2019-12-02-NLM/"/>
    <id>https://www.yam.gift/2019/12/02/2019-12-02-NLM/</id>
    <published>2019-12-02T14:00:00.000Z</published>
    <updated>2019-12-10T07:34:13.088Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍自然语言的记忆（存储与查询）模块，初衷是作为 chatbot 的 Layer 之一，主要功能是记忆（存储）从对话或训练数据学到的 “知识”，然后在需要时唤起（查询） 。目前成熟的方法是以图数据库作为载体，将知识存储为一系列的 ”节点“ 和 ”关系“。之后再基于这些存储的 ”节点“ 和 ”关系“ 进行相关查询。也可以理解为构建 Data Model 的问题。</p><p>项目地址：<a href="https://github.com/hscspring/NLM" target="_blank" rel="noopener">https://github.com/hscspring/NLM</a></p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>图数据库的典型代表是 <a href="http://neo4j.com/" target="_blank" rel="noopener">Neo4j</a>，Neo4j 中有几个很重要的概念：标签、节点和关系。标签是一类节点，可以看作是节点的类别，节点一般是某一个实体；关系存在于两个实体间，可以有多种不同的关系。节点和关系可以有多个属性。实践来看，Python 语言可以使用社区的 <a href="https://github.com/technige/py2neo" target="_blank" rel="noopener">technige/py2neo</a>，当然还可以使用官方的 <a href="https://github.com/neo4j/neo4j-python-driver" target="_blank" rel="noopener">neo4j/neo4j-python-driver: Neo4j Bolt driver for Python</a>，两者的目的都是将数据 import 进 database 并进行相应的查询。</p><p>Neo4j 的特点要求导入的数据尽量是结构化的，也就是我们要事先有实体和它的类别（实体的属性可有可无），实体与实体间的关系（关系的属性可有可无）。我们期待能从对话或无监督的语料中自动提取实体和关系，然后自动 import 进 Neo4j。为了避免导入数据的混乱，自然最好能有先验的 “类别”，比如节点类别 Person，Movie 等，关系类别 LOVES，ACTS 等。所以，对于文本输入，我们需要一个信息提取器，将文本中的符合先验类别的节点和关系提取出来。如果输入是 NLU 模块输出的 ”意图和实体“ ，则需要一个分类器，将意图分类到对应的 Relation 类别，将实体分类到 Node 类别。</p><a id="more"></a><p>接下来的问题是：“我们如何确定先验的类别？”设想当然是能包括所有可能的类别，比如我们可以在大规模语料上使用 LDA 之类的模型自动获取 topic，每个 topic 作为一个类别标签。对话中的句子使用该模型预测 topic 并在 query 无结果时加入 Database。但这样可能导致知识图谱比较泛，无法 “专注” 在特定领域。因此实际可能还是需要针对垂直领域手动设计好 Node 和 Relation 的类别。</p><p>综上所述，我们的 NLM 模块需要具备以下基本功能：</p><ul><li>批量导入结构化数据，根据设计好的 Node 和 Relation（统一在 scheme 中设计）自动创建实体和关系</li><li>自动根据文本或 NLU 的输出存储或查询实体和关系（无论是否有事先设计的实体和关系类别）<ul><li>对于商业应用，建议事先设计好，实际就变成：<ul><li>将 NLU 的结果（实体和意图）自动分类到知识图谱已有的 Node 和 Relation</li><li>从文本中自动提取事先设计好类别的 Node 和 Relation</li></ul></li><li>对于闲聊机器人，不妨让它自由进化，看看最后能成什么样子</li></ul></li><li>自动根据文本或 NLU 的输出 Query</li><li>对 Query 结果进行解析，输出为 NLG 或 NLI 模块需要的结构</li><li>模块高内聚，可以作为独立的 Layer 对外提供服务；低耦合，分类器、提取器、解析器均可以自由更换</li></ul><p>基本流程如下：</p><p>NLU Output/TEXT =&gt; Classifier/Extractor =&gt; Graph Input =&gt; Query/Add/Update =&gt; Parser =&gt; NLG (NLI) Input</p><h2 id="批量导入"><a href="#批量导入" class="headerlink" title="批量导入"></a>批量导入</h2><p>主要是明确一下规范，这个规范是看过几个项目后的感悟，暂时没有想到更好的，等有了更好的再来调整吧。最好 Input 不依赖某个具体的数据库（如 Neo4j）。核心思想是这样的：</p><ul><li>首先假设每次导入的数据是某一个类别，而这些数据每条对应一个不重复的 item name。比如类别 “电影” 每条 item 的 name 是电影名；再比如类别 “疾病” 每条 item 的 name 是疾病名。</li><li>item name 相关的其他信息均作为该 item 的属性。比如某个电影的属性可能包括：上映时间、导演、演员、类别，甚至豆瓣评分都可以。</li><li>每个 item name 就是一个 Node，label 自然就是类别，item 的属性是 Node 的属性，这个可以动态调整。Relation 除了两个 Node 和它的 name 外还可以有自己的属性。比如演员 Y 是一个 Person，“演员 Y act A 电影” 这是一个关系，它同时可以有一个 “角色” 的属性（即在电影里演了谁）。</li><li>Node 和 Relation 均通过 scheme 创建。</li></ul><p>举个栗子，首先是数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 结构化的 data</span><br><span class="line">[</span><br><span class="line">    &#123;<span class="attr">"id"</span>: <span class="string">"1"</span>, <span class="attr">"title"</span>: <span class="string">"Wall Streat"</span>, <span class="attr">"year"</span>: <span class="string">"1987"</span>, <span class="attr">"actors"</span>: [<span class="string">"Charlie-&gt;Bud"</span>, <span class="string">"Martin-&gt;Gordon"</span>], <span class="attr">"director"</span>: <span class="string">"Robot"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"id"</span>: <span class="string">"2"</span>, <span class="attr">"title"</span>: <span class="string">"The Matrix"</span>, <span class="attr">"year"</span>: <span class="string">"1997"</span>, <span class="attr">"actors"</span>: [<span class="string">"Keanu-&gt;Neo"</span>, <span class="string">"Tom-&gt;Forrest"</span>], <span class="attr">"director"</span>: <span class="string">"Robot"</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着是 scheme ，可以使用 <code>GraphObject</code> 来直接创建 Graph scheme 对象，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># batch scheme</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span><span class="params">(GraphObject)</span>:</span></span><br><span class="line">    __primarykey__ = <span class="string">"title"</span></span><br><span class="line"></span><br><span class="line">    title = Property()</span><br><span class="line">    released = Property(<span class="string">"year"</span>)</span><br><span class="line"></span><br><span class="line">    actors = RelatedFrom(Person, <span class="string">"ACTED_IN"</span>)</span><br><span class="line">    directors = RelatedFrom(Person, <span class="string">"DIRECTED"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(GraphObject)</span>:</span></span><br><span class="line">    __primarykey__ = <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">    name = Property()</span><br></pre></td></tr></table></figure><p>然后将结构化的数据处理后批量导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># execute</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        movie = Movie()</span><br><span class="line">        movie.title=item[<span class="string">"title"</span>]</span><br><span class="line">        movie.released=item[<span class="string">"year"</span>]</span><br><span class="line">        director = Person()</span><br><span class="line">        director.name = item[<span class="string">"director"</span>]</span><br><span class="line">        movie.directors.add(director, &#123;<span class="string">"name"</span>: <span class="string">"执导了"</span>&#125;)</span><br><span class="line">        <span class="keyword">for</span> iitem <span class="keyword">in</span> item[<span class="string">"actors"</span>]:</span><br><span class="line">            actor = Person()</span><br><span class="line">            actor.name, role = iitem.split(<span class="string">"-&gt;"</span>)</span><br><span class="line">            movie.actors.add(actor, &#123;<span class="string">"role"</span>: role, <span class="string">"name"</span>: <span class="string">"扮演了"</span>&#125;)</span><br><span class="line">        graph.push(movie)</span><br></pre></td></tr></table></figure><p>具体可参考<a href="https://github.com/hscspring/NLM/tree/master/batch_example" target="_blank" rel="noopener">这里</a>的例子。</p><h2 id="实时处理"><a href="#实时处理" class="headerlink" title="实时处理"></a>实时处理</h2><p>从 NLU Output 或文本到 Graph Input 这步一般就是深度学习模型 + 传统的信息提取方法 + Naive 的兜底（比如类别字符串匹配）。如果看过《思考，快与慢》的话，这个 NLM 记忆层相当于系统 2，进到这里后出去是需要做一系列推理和判断的。至于系统 1，则直接从历史对话中得到，这方面可以借鉴这个<a href="https://github.com/gunthercox/ChatterBot" target="_blank" rel="noopener">项目</a>，这时候就不需要图数据库了。</p><p>目前从 Graph Input 到存储、Query 这步已经完成了，并且两步自动合并为一步，即 NLM 会根据输入的 Node 或 Relation 的部分信息找到存储的对应的完整信息，同时它会自动判断（可以全局配置或在 Query 时配置）是不是要添加或更新。项目主页在<a href="https://github.com/hscspring/NLM" target="_blank" rel="noopener">这里</a>，<strong>需要说明的是</strong>：属性不作为 Query 信息，仅作为对 Query 结果排序的依据。NLM 可以作为Python 模块使用，也可以作为 RPC 服务使用。在使用前需要做一些配置和操作，具体如下：</p><p><strong>第一步：安装依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 pipenv</span></span><br><span class="line">$ pipenv install --dev</span><br><span class="line"><span class="comment"># 没有 pipenv</span></span><br><span class="line">$ python3 -m venv env</span><br><span class="line">$ <span class="built_in">source</span> env/bin/activate</span><br><span class="line">$ pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><strong>第二步：启动一个 Neo4j 实例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it -p 7475:7474 -p 7688:7687 neo4j</span><br></pre></td></tr></table></figure><p>这里我们使用 7475 和 7688 两个端口，和正式环境区分开，并且也不持久化存储数据。启动 docker 后，在浏览器中打开 <code>http://localhost:7475/browser/</code>，端口改成 7688，密码输入 <code>neo4j</code>，然后将密码改为 <code>password</code>。</p><p>如果你是在正式的环境下使用，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span><br><span class="line">    --p=7474:7474 --p=7687:7687 \</span><br><span class="line">    --v=/your/persist/path/to/neo4j/data:/data \</span><br><span class="line">    neo4j</span><br></pre></td></tr></table></figure><p>同时你需要创建环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEO_SCHE:scheme</span><br><span class="line">NEO_HOST:host</span><br><span class="line">NEO_PORT:port</span><br><span class="line">NEO_USER:username</span><br><span class="line">NEO_PASS:password</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEO_SCHE:bolt</span><br><span class="line">NEO_HOST:localhost</span><br><span class="line">NEO_PORT:7687</span><br><span class="line">NEO_USER:neo4j</span><br><span class="line">NEO_PASS:complex_password_<span class="keyword">for</span>_neo4j</span><br></pre></td></tr></table></figure><p>如果你不是通过配置文件，那建议使用 <a href="https://github.com/inishchith/autoenv" target="_blank" rel="noopener">inishchith/autoenv: Directory-based environments.</a>，将配置写到 <code>.env</code> 文件下，切换目录会自动加载目录下 <code>.env</code> 中的环境变量。<strong>注意</strong>，不要把 <code>.env</code> 文件提交到代码仓库。</p><p>测试环境下不需要配置环境变量，用的都是上面的默认值，比如端口用 7688，密码用 <code>password</code> 等。</p><p><strong>第三步：运行测试</strong></p><p>这步的主要目的是生产一点数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pytest</span><br></pre></td></tr></table></figure><p>运行完后打开 <code>http://localhost:7475/browser/</code>，在 Query 框中输入查询语句就能看到节点和关系信息了，一共 8 个节点和 8 个关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (_) RETURN _</span><br></pre></td></tr></table></figure><h3 id="作为模块使用"><a href="#作为模块使用" class="headerlink" title="作为模块使用"></a>作为模块使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> py2neo.database <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> nlm <span class="keyword">import</span> NLMLayer, GraphNode, GraphRelation</span><br><span class="line"><span class="comment"># 这里的配置可以在具体运行时覆盖</span></span><br><span class="line">mem = NLMLayer(graph=Graph(port=<span class="number">7688</span>), </span><br><span class="line">               fuzzy_node=<span class="keyword">False</span>,</span><br><span class="line">               add_inexistence=<span class="keyword">False</span>,</span><br><span class="line">               update_props=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 节点 ##########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本查询</span></span><br><span class="line">node = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>)</span><br><span class="line">mem(node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个新节点，如果不是新节点，就会返回查到的那个节点</span></span><br><span class="line">new = GraphNode(<span class="string">"Person"</span>, <span class="string">"Bob"</span>)</span><br><span class="line">mem(new, add_inexistence=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模糊查询，只支持 name 上的模糊</span></span><br><span class="line">node = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceT"</span>)</span><br><span class="line">mem(node, fuzzy_node=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新属性，Node 的属性会同步返回更改后的</span></span><br><span class="line">node = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>, props=&#123;<span class="string">"age"</span>: <span class="number">24</span>&#125;)</span><br><span class="line">mem(node, update_props=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个节点，辅助功能</span></span><br><span class="line">node = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceT"</span>)</span><br><span class="line">mem(node, fuzzy_node=<span class="keyword">True</span>, topn=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 关系 ##########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本查询</span></span><br><span class="line">start = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>)</span><br><span class="line">end = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceOne"</span>)</span><br><span class="line">relation = GraphRelation(start, end, <span class="string">"LOVES"</span>)</span><br><span class="line">mem(relation)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新关系</span></span><br><span class="line">start = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>)</span><br><span class="line">end = GraphNode(<span class="string">"Person"</span>, <span class="string">"Bob"</span>)</span><br><span class="line">relation = GraphRelation(start, end, <span class="string">"KNOWS"</span>)</span><br><span class="line">mem(relation, add_inexistence=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模糊查询</span></span><br><span class="line">start = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceTh"</span>)</span><br><span class="line">end = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceO"</span>)</span><br><span class="line">relation = GraphRelation(start, end, <span class="string">"LOVES"</span>)</span><br><span class="line">mem(relation, fuzzy_node=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个关系</span></span><br><span class="line">start = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>)</span><br><span class="line">end = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceOne"</span>)</span><br><span class="line">relation = GraphRelation(start, end)</span><br><span class="line">mem(relation, topn=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新属性，Relation 属性不会同步返回，需再次调用后返回</span></span><br><span class="line">start = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>)</span><br><span class="line">end = GraphNode(<span class="string">"Person"</span>, <span class="string">"Bob"</span>)</span><br><span class="line">relation = GraphRelation(start, end, <span class="string">"KNOWS"</span>, &#123;<span class="string">"roles"</span>: <span class="string">"classmate"</span>&#125;)</span><br><span class="line">mem(relation, update_props=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时更新 Node 和 Relation 的属性</span></span><br><span class="line">start = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>)</span><br><span class="line">end = GraphNode(<span class="string">"Person"</span>, <span class="string">"Bob"</span>, &#123;<span class="string">"sex"</span>: <span class="string">"male"</span>&#125;)</span><br><span class="line">relation = GraphRelation(start, end, <span class="string">"KNOWS"</span>, &#123;<span class="string">"roles"</span>: <span class="string">"friend"</span>&#125;)</span><br><span class="line">mem(relation, update_props=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有关系类别的查询</span></span><br><span class="line">start = GraphNode(<span class="string">"Person"</span>, <span class="string">"AliceThree"</span>)</span><br><span class="line">end = GraphNode(<span class="string">"Person"</span>, <span class="string">"Bob"</span>)</span><br><span class="line">mem(GraphRelation(start, end), topn=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">############ 数据库 ############</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的 label，即实体类别</span></span><br><span class="line">mem.labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的关系类别</span></span><br><span class="line">mem.relationship_types</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实体数量</span></span><br><span class="line">mem.nodes_num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关系数量</span></span><br><span class="line">mem.relationships_num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的实体，是一个 generator</span></span><br><span class="line">mem.nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的关系，是一个 generator</span></span><br><span class="line">mem.relationships</span><br><span class="line"></span><br><span class="line"><span class="comment"># CQL 查询</span></span><br><span class="line">mem.query(<span class="string">"MATCH (a:Person) RETURN a.age, a.name LIMIT 5"</span>)</span><br><span class="line">[&#123;<span class="string">'a.age'</span>: <span class="number">21</span>, <span class="string">'a.name'</span>: <span class="string">'AliceTwo'</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'a.age'</span>: <span class="number">23</span>, <span class="string">'a.name'</span>: <span class="string">'AliceFour'</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'a.age'</span>: <span class="number">22</span>, <span class="string">'a.name'</span>: <span class="string">'AliceOne'</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'a.age'</span>: <span class="number">24</span>, <span class="string">'a.name'</span>: <span class="string">'AliceFive'</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'a.age'</span>: <span class="keyword">None</span>, <span class="string">'a.name'</span>: <span class="string">'Bob'</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># CQL 执行</span></span><br><span class="line">mem.excute(<span class="string">"MATCH (a:Person) RETURN a.age, a.name LIMIT 5"</span>)</span><br></pre></td></tr></table></figure><p>NLMLayer 本质上是继承了 <code>py2neo.Graph</code>，所有 <code>py2neo.Graph</code> 的函数和方法，mem 都可以使用，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个 Node Matcher</span></span><br><span class="line">mem.nmatcher</span><br></pre></td></tr></table></figure><p>详细可参考：<a href="https://py2neo.org/v4/matching.html" target="_blank" rel="noopener">3. py2neo.matching – Entity matching — The Py2neo v4 Handbook</a>。</p><p>另外，如果模糊查询开启，则不会自动更新属性（即便配置了也不会），因为不确定模糊查到的节点是不是具备这些属性。但会自动添加节点，因为模糊查询都找不到的话，自动添加肯定是没问题的。</p><h3 id="作为服务使用"><a href="#作为服务使用" class="headerlink" title="作为服务使用"></a>作为服务使用</h3><p>作为 RPC 服务，必须在启动时将 NLMLayer 的参数给配置好（当然不配置的话默认都是 False），因为你不能像模块那样在实际调用时覆盖。这样设计的目的是让接口简单、清晰，客户端不用（也不需要）考虑这些东西。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python server.py [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-fn fuzzy_node</span><br><span class="line">-ai add_inexistence</span><br><span class="line">-up update_props</span><br></pre></td></tr></table></figure><p>客户端可以使用任何编程语言，详细情况可以阅读 <a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a> 相关知识。</p><p>目前只有四个接口，但其实后两个并不能提供真正的服务：</p><ul><li>NodeRecall</li><li>RelationRecall</li><li>StrRecall</li><li>NLURecall</li></ul><p>仓库里有一个 Python 版本的客户端使用代码：<code>client.py</code>。</p><h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p>如果考虑到初衷，项目其实是个半成品，之所以发布出来是想听听更多人的建议，看看实际中到底有哪些应用场景，然后再做针对性地开发。这个毕竟是比较新的领域，我自己也没有很多实践经验。</p><p>对返回的结果数量，最开始的想法是只返回一个，后来给留了个 topn 的参数。这个功能在 RPC 中给取消了，主要还是因为后续没有完成，还有是考虑到最终其实只要一个结果，并不需要返回多个，以及 proto 写起来稍微清晰一些。设计的出发点是尽量让使用傻瓜式，比如模块主要功能的入口只有一个。</p><p>由于考虑到 Query 中可能有 props，而 props 实际上是 key value 都不确定的字典，这在 proto 中定义起来比较麻烦，一直没找到很合适的方法。所以干脆统一将 props 给序列化了，这样的做法导致 RPC Server 处理起来有一点点复杂。</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul><li><a href="https://py2neo.org/v4/index.html" target="_blank" rel="noopener">The Py2neo v4 Handbook — The Py2neo v4 Handbook</a></li><li><a href="https://github.com/liuhuanyong/CrimeKgAssitant" target="_blank" rel="noopener">liuhuanyong/CrimeKgAssitant</a></li><li><a href="https://github.com/gunthercox/ChatterBot" target="_blank" rel="noopener">gunthercox/ChatterBot</a></li><li><a href="https://github.com/liuhuanyong/QASystemOnMedicalKG" target="_blank" rel="noopener">liuhuanyong/QASystemOnMedicalKG</a></li><li><a href="https://github.com/machinalis/iepy" target="_blank" rel="noopener">machinalis/iepy: Information Extraction in Python</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍自然语言的记忆（存储与查询）模块，初衷是作为 chatbot 的 Layer 之一，主要功能是记忆（存储）从对话或训练数据学到的 “知识”，然后在需要时唤起（查询） 。目前成熟的方法是以图数据库作为载体，将知识存储为一系列的 ”节点“ 和 ”关系“。之后再基于这些存储的 ”节点“ 和 ”关系“ 进行相关查询。也可以理解为构建 Data Model 的问题。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/hscspring/NLM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/hscspring/NLM&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;设计思想&quot;&gt;&lt;a href=&quot;#设计思想&quot; class=&quot;headerlink&quot; title=&quot;设计思想&quot;&gt;&lt;/a&gt;设计思想&lt;/h2&gt;&lt;p&gt;图数据库的典型代表是 &lt;a href=&quot;http://neo4j.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Neo4j&lt;/a&gt;，Neo4j 中有几个很重要的概念：标签、节点和关系。标签是一类节点，可以看作是节点的类别，节点一般是某一个实体；关系存在于两个实体间，可以有多种不同的关系。节点和关系可以有多个属性。实践来看，Python 语言可以使用社区的 &lt;a href=&quot;https://github.com/technige/py2neo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;technige/py2neo&lt;/a&gt;，当然还可以使用官方的 &lt;a href=&quot;https://github.com/neo4j/neo4j-python-driver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;neo4j/neo4j-python-driver: Neo4j Bolt driver for Python&lt;/a&gt;，两者的目的都是将数据 import 进 database 并进行相应的查询。&lt;/p&gt;
&lt;p&gt;Neo4j 的特点要求导入的数据尽量是结构化的，也就是我们要事先有实体和它的类别（实体的属性可有可无），实体与实体间的关系（关系的属性可有可无）。我们期待能从对话或无监督的语料中自动提取实体和关系，然后自动 import 进 Neo4j。为了避免导入数据的混乱，自然最好能有先验的 “类别”，比如节点类别 Person，Movie 等，关系类别 LOVES，ACTS 等。所以，对于文本输入，我们需要一个信息提取器，将文本中的符合先验类别的节点和关系提取出来。如果输入是 NLU 模块输出的 ”意图和实体“ ，则需要一个分类器，将意图分类到对应的 Relation 类别，将实体分类到 Node 类别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thinking" scheme="https://www.yam.gift/categories/Thinking/"/>
    
    
      <category term="NLP" scheme="https://www.yam.gift/tags/NLP/"/>
    
      <category term="NLM" scheme="https://www.yam.gift/tags/NLM/"/>
    
      <category term="Neo4j" scheme="https://www.yam.gift/tags/Neo4j/"/>
    
      <category term="Knowledge Graph" scheme="https://www.yam.gift/tags/Knowledge-Graph/"/>
    
  </entry>
  
  <entry>
    <title>Sort Based on Multiway Tree</title>
    <link href="https://www.yam.gift/2019/11/03/DS/2019-11-03-Multiway-Tree-Sort/"/>
    <id>https://www.yam.gift/2019/11/03/DS/2019-11-03-Multiway-Tree-Sort/</id>
    <published>2019-11-03T15:00:00.000Z</published>
    <updated>2019-11-04T04:15:13.421Z</updated>
    
    <content type="html"><![CDATA[<p>Several weeks ago, we met a sort problem in our program of web app. We tried kinds of methods and finally have gotten a nearly 10 times performance improvement. The problem is very interesting and worth recording.</p><a id="more"></a><h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h2><p>Given a list of items, each item with a directory and a create_time, we need to sort those items by two rules:</p><ul><li>first rule: a given index_dict, only contains part of the items.</li><li>second rule: when the first rule is not exist, use create_time.</li></ul><p>Here is an example.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The given items</span></span><br><span class="line">items = [</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-03-01"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder1/folder1-folder1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-03-02"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder1/folder1-folder1/file1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-03-10"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder1/folder1-folder1/file2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-03-02"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder1/folder1-folder1/file3"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-03-04"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder1/folder1-folder1/file4"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-03-03"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-01-01"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder2/folder2-folder1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-01-20"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder2/folder2-folder1/file1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-01-22"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder2/folder2-folder1/file2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-01-21"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder2/folder2-folder2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-01-10"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder2/folder2-folder2/file1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-01-11"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder2/folder2-folder2/file2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-01-12"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-01"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-10"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder1/file1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-12"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder1/file2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-11"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-01"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder2/file1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-03"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder2/file2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-04"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder3"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-03"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder3/file1"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-05"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder3/file2"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-04"</span> &#125;,</span><br><span class="line">  %&#123; <span class="string">"location"</span> =&gt; <span class="string">"/folder3/folder3-folder4"</span>, <span class="string">"create_time"</span> =&gt; <span class="string">"2019-02-02"</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The given index dict</span></span><br><span class="line">%&#123;</span><br><span class="line">  <span class="string">"/folder1/folder1-folder1"</span> =&gt; [</span><br><span class="line">      <span class="string">"/folder1/folder1-folder1/file1"</span>,</span><br><span class="line">      <span class="string">"/folder1/folder1-folder1/file2"</span></span><br><span class="line">   ],</span><br><span class="line">  <span class="string">"/folder2/folder2-folder1"</span> =&gt; [</span><br><span class="line">      <span class="string">"/folder2/folder2-folder1/file1"</span>,</span><br><span class="line">      <span class="string">"/folder2/folder2-folder1/file2"</span>,</span><br><span class="line">   ],</span><br><span class="line">  <span class="string">"/folder2/folder2-folder2"</span> =&gt; [</span><br><span class="line">      <span class="string">"/folder2/folder2-folder2/file1"</span>,</span><br><span class="line">      <span class="string">"/folder2/folder2-folder2/file2"</span></span><br><span class="line">   ],</span><br><span class="line">  <span class="string">"/folder3"</span> =&gt; [</span><br><span class="line">      <span class="string">"/folder3/folder3-folder1"</span>,</span><br><span class="line">      <span class="string">"/folder3/folder3-folder2"</span></span><br><span class="line">   ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PAY attention, the given index dict might have different levels, and the map keys are out of order, the index order we need is actually the values.</p><p>What we want is like:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'/'</span>,</span><br><span class="line"> <span class="string">'/folder2'</span>,</span><br><span class="line"> <span class="string">'/folder2/folder2-folder2'</span>,</span><br><span class="line"> <span class="string">'/folder2/folder2-folder2/file1'</span>,</span><br><span class="line"> <span class="string">'/folder2/folder2-folder2/file2'</span>,</span><br><span class="line"> <span class="string">'/folder2/folder2-folder1'</span>,</span><br><span class="line"> <span class="string">'/folder2/folder2-folder1/file1'</span>,</span><br><span class="line"> <span class="string">'/folder2/folder2-folder1/file2'</span>,</span><br><span class="line"> <span class="string">'/folder3'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder1'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder1/file2'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder1/file1'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder2'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder2/file1'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder2/file2'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder4'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder3'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder3/file2'</span>,</span><br><span class="line"> <span class="string">'/folder3/folder3-folder3/file1'</span>,</span><br><span class="line"> <span class="string">'/folder1'</span>,</span><br><span class="line"> <span class="string">'/folder1/folder1-folder1'</span>,</span><br><span class="line"> <span class="string">'/folder1/folder1-folder1/file1'</span>,</span><br><span class="line"> <span class="string">'/folder1/folder1-folder1/file2'</span>,</span><br><span class="line"> <span class="string">'/folder1/folder1-folder1/file4'</span>,</span><br><span class="line"> <span class="string">'/folder1/folder1-folder1/file3'</span>]</span><br></pre></td></tr></table></figure><p>Let me explain:</p><ul><li>“/folder1”, “/folder2” and “/folder3” are not in the index_dict, so they are sorted by create_time: “/folder2” &gt; “/folder3” &gt; “/folder1”</li><li><p>then, Let’s loot at the subfolders of folder2. “/folder2/folder2-folder1” and “/folder2/folder2-folder2” are also not in the index_dict (values), so they are sorted by create_time: “/folder2/folder2-folder2” &gt; “/folder2/folder2-folder1”</p></li><li><p>then, their subdirectories (here are files), although “/folder2/folder2-folder1/file2” &gt; “/folder2/folder2-folder1/file1” by create_time, in the index_dict, “file1” &gt; “file2”, so the result is ‘/folder2/folder2-folder1/file1’ &gt; ‘/folder2/folder2-folder1/file2’.</p></li><li><p>Another example, let’s look at folder3, they have sub folders in the index_dict, so sub folders need to be sorted like that: ‘/folder3/folder3-folder1’ &gt; ‘/folder3/folder3-folder2’, then ‘/folder3/folder3-folder4’ &gt; ‘/folder3/folder3-folder3’, by their create_time.</p></li></ul><p>We need to remind you several points again:</p><ul><li>the directory locations might be multi-levels</li><li>the index keys might be any parent directory location, and they are out of order (dict)</li><li>the each index values are not one-to-one with the items (may be more or less)</li><li>sub folder or sub files must be created after their parent</li></ul><h2 id="First-Naive-Solution"><a href="#First-Naive-Solution" class="headerlink" title="First Naive Solution"></a>First Naive Solution</h2><p>It was my first time to use Elixir, so I quickly got an easy solution: sort by levels. Here is a small example:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="string">"/c/3"</span>, <span class="string">"/a/3"</span>, <span class="string">"/b/2"</span>, <span class="string">"/a/1"</span>, <span class="string">"c/1"</span>, <span class="string">"/a/2"</span>, <span class="string">"/b/1"</span>]</span><br><span class="line">standard = [<span class="string">"/b"</span>, <span class="string">"/a"</span>, <span class="string">"/c"</span>]</span><br><span class="line">Enum.sort_by(items, &amp;Enum.find_index(standard, <span class="keyword">fn</span> x-&gt; x == get_parent_loc(&amp;<span class="number">1</span>) <span class="keyword">end</span>))</span><br></pre></td></tr></table></figure><p>First of all, we sort all the items by their create_time. Then, at each level, we first check if there is an index in the index dict. If is, that’s just the standard for the sub directories. If is not, we  do nothing.</p><p>So the solution may like the following (we only list the key code).</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sorter</span></span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build_item_level</span></span>(item_list) <span class="keyword">do</span></span><br><span class="line">    item_list </span><br><span class="line">    |&gt; Enum.sort_by(&amp;Map.get(&amp;<span class="number">1</span>, <span class="string">"create_time"</span>))</span><br><span class="line">    |&gt; Enum.map(<span class="keyword">fn</span> x -&gt; Map.get(x, <span class="string">"location"</span>) <span class="keyword">end</span>)</span><br><span class="line">    |&gt; build_location_level()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build_index_level</span></span>(index_dict) <span class="keyword">do</span></span><br><span class="line">    index_dict</span><br><span class="line">    |&gt; Enum.reduce([], <span class="keyword">fn</span> &#123;<span class="number">_</span>, children&#125;, index_list -&gt;</span><br><span class="line">      [children | index_list]</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    |&gt; Enum.reverse()</span><br><span class="line">    |&gt; List.flatten()</span><br><span class="line">    |&gt; build_location_level()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">combine_item_index_level</span></span>(item_level, index_level) <span class="keyword">do</span></span><br><span class="line">    Enum.reduce(item_level, %&#123;&#125;, <span class="keyword">fn</span> &#123;level, items&#125;, combined_level -&gt;</span><br><span class="line">    index = Map.get(index_level, level, [])</span><br><span class="line">    not_in_index = Enum.filter(items, <span class="keyword">fn</span> x -&gt;</span><br><span class="line">      Enum.member?(index, x) == <span class="keyword">false</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    combined = index ++ not_in_index</span><br><span class="line">    Map.put(combined_level, level, combined)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sort_level_items</span></span>(combined_level) <span class="keyword">do</span></span><br><span class="line">    combined_level</span><br><span class="line">    |&gt; Enum.reduce(%&#123;&#125;, <span class="keyword">fn</span> &#123;level, items&#125;, sorted_items -&gt;</span><br><span class="line">    standard = Map.get(sorted_items, level-<span class="number">1</span>, [])</span><br><span class="line">    sorted = Enum.sort_by(items, &amp;Enum.find_index(standard, <span class="keyword">fn</span> x -&gt;</span><br><span class="line">      x == get_parent_location(&amp;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span>))</span><br><span class="line">    Map.put(sorted_items, level , sorted)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">combine_sorted_items</span></span>(sorted_items) <span class="keyword">do</span></span><br><span class="line">    locs_dict = %&#123;<span class="string">"/"</span> =&gt; <span class="string">"00000"</span>&#125;</span><br><span class="line">    sorted_items</span><br><span class="line">    |&gt; Enum.reduce([], <span class="keyword">fn</span> &#123;<span class="number">_</span>, items&#125;, level_list -&gt;</span><br><span class="line">      [items | level_list]</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    |&gt; Enum.reverse()</span><br><span class="line">    |&gt; add_tag_to_location(locs_dict)</span><br><span class="line">    |&gt; Enum.sort_by(<span class="keyword">fn</span> &#123;<span class="number">_</span>, tag&#125; -&gt; tag <span class="keyword">end</span>)</span><br><span class="line">    |&gt; Enum.map(<span class="keyword">fn</span> &#123;loc, <span class="number">_</span>&#125; -&gt; loc <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(item_list, index_dict) <span class="keyword">do</span></span><br><span class="line">    index_level = build_index_level(index_dict)</span><br><span class="line">    item_list</span><br><span class="line">    |&gt; build_item_level()</span><br><span class="line">    |&gt; combine_item_index_level(index_level)</span><br><span class="line">    |&gt; sort_level_items()</span><br><span class="line">    |&gt; combine_sorted_items() </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>That seems a little complex, but easy to understand:</p><ul><li>First, we build levels from both items and indexes, the result is a map (dict) with location (directory) level as key and location as value.</li><li>Then, we combine each level locations, make sure that index level locations are ahead of item level locations.</li><li>After that, we just sort the combined level locations by their parent location from the top level to the last level, just like what we’ve mentioned in the above simple example.</li><li>At last, we need to adjust the locations, make sure the children locations are following their parent location instead of grouped by levels.</li></ul><p>For the whole code, please go <a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/blob/master/Tree/MultiwayTree/sort_by_level.ex" target="_blank" rel="noopener">here</a>.</p><h2 id="A-Normal-One"><a href="#A-Normal-One" class="headerlink" title="A Normal One"></a>A Normal One</h2><p>The problem is obviously a tree problem, so we tried a tree solution with the help of <a href="https://elixirforum.com/" target="_blank" rel="noopener">Elixir Forum</a>. Thanks to those enthusiastic guys, we found a way to build the tree, and we sorted the items in Depth-First traversal. The solution main code is here.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sorter</span></span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span></span>(paths) <span class="keyword">do</span></span><br><span class="line">    paths</span><br><span class="line">    |&gt; Enum.map(&amp;path_to_tree/<span class="number">1</span>)</span><br><span class="line">    |&gt; Enum.reduce(%&#123;&#125;, &amp;deep_merge/<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">path_to_tree</span></span>(path) <span class="keyword">do</span></span><br><span class="line">    pdict = path</span><br><span class="line">    |&gt; String.split(<span class="string">"/"</span>)</span><br><span class="line">    |&gt; Enum.drop(<span class="number">1</span>)</span><br><span class="line">    |&gt; Enum.reduce([], <span class="keyword">fn</span> x, paths -&gt;</span><br><span class="line">      parent = Enum.at(paths, <span class="number">0</span>) || <span class="string">" "</span> <span class="comment"># actually is ""</span></span><br><span class="line">      [parent &lt;&gt; <span class="string">"/"</span> &lt;&gt; x  | paths]</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    |&gt; Enum.reduce(%&#123;&#125;, <span class="keyword">fn</span> segment, inner_tree -&gt;</span><br><span class="line">      %&#123;segment =&gt; inner_tree&#125;</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    %&#123;<span class="string">"/"</span> =&gt; pdict&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deep_merge</span></span>(map1, map2) <span class="keyword">do</span></span><br><span class="line">    Map.merge(map1, map2, <span class="keyword">fn</span> <span class="number">_</span>, val1 = %&#123;&#125;, val2 = %&#123;&#125; -&gt;</span><br><span class="line">      deep_merge(val1, val2)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dft_with_sort</span></span>([], res, _time_sorted_locs, _indexes), <span class="symbol">do:</span> res</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dft_with_sort</span></span>(stack, res, time_sorted_locs, indexes) <span class="keyword">do</span></span><br><span class="line">    &#123;curr, remain&#125; = List.pop_at(stack, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    &#123;key, values&#125; = List.first(Map.to_list(curr))</span><br><span class="line"></span><br><span class="line">    sorter = </span><br><span class="line">    [Map.get(indexes, key, []) | time_sorted_locs] </span><br><span class="line">    |&gt; List.flatten()</span><br><span class="line"></span><br><span class="line">    new = values</span><br><span class="line">    |&gt; Map.to_list()</span><br><span class="line">    |&gt; Enum.sort_by(&amp;&#123;Enum.find_index(sorter, <span class="keyword">fn</span> x -&gt; </span><br><span class="line">      x ==  List.first(Tuple.to_list(&amp;<span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">end</span>)&#125;)</span><br><span class="line">    |&gt; Enum.map(<span class="keyword">fn</span> &#123;key, value&#125; -&gt; %&#123;key =&gt; value&#125; <span class="keyword">end</span>)</span><br><span class="line">    |&gt; Enum.reverse()</span><br><span class="line"></span><br><span class="line">    res = [key | res]</span><br><span class="line"></span><br><span class="line">    [remain | new] </span><br><span class="line">    |&gt; List.flatten() </span><br><span class="line">    |&gt; dft_with_sort(res, time_sorted_locs, indexes)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(item_list, index_dict) <span class="keyword">do</span></span><br><span class="line">    sorted_locs = item_list</span><br><span class="line">    |&gt; Enum.sort_by(&amp;Map.get(&amp;<span class="number">1</span>, <span class="string">"create_time"</span>))</span><br><span class="line">    |&gt; Enum.map(<span class="keyword">fn</span> x -&gt; Map.get(x, <span class="string">"location"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    tree = build_tree(sorted_locs)</span><br><span class="line">    dft_with_sort([tree], [], sorted_locs, index_dict) |&gt; Enum.reverse()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>This code is much harder than the former one. Here we will explain the key functions.</p><p><code>path_to_tree</code> is to make a string path to a tree, for example:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">"/a/b/c/d"</span></span><br><span class="line">path_to_tree(path) == %&#123;<span class="string">"/"</span> =&gt; %&#123;<span class="string">"/a"</span> =&gt; %&#123;<span class="string">"/a/b"</span> =&gt; %&#123;<span class="string">"/a/b/c"</span> =&gt; %&#123;<span class="string">"/a/b/c/d"</span> =&gt; %&#123;&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>deep_merge</code> is to merge two maps, for example:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map1 = %&#123;<span class="string">"/"</span> =&gt; %&#123;<span class="string">"/a"</span> =&gt; %&#123;<span class="string">"/a/b"</span> =&gt; %&#123;<span class="string">"/a/b/c"</span> =&gt; %&#123;<span class="string">"/a/b/c/d"</span> =&gt; %&#123;&#125;&#125;&#125;&#125;&#125;&#125;</span><br><span class="line">map2 = %&#123;<span class="string">"/"</span> =&gt; %&#123;<span class="string">"/1"</span> =&gt; %&#123;<span class="string">"/1/2"</span> =&gt; %&#123;&#125;&#125;&#125;&#125;</span><br><span class="line">deep_merge(map1, map2) == %&#123;</span><br><span class="line">  <span class="string">"/"</span> =&gt; %&#123;</span><br><span class="line">    <span class="string">"/1"</span> =&gt; %&#123;<span class="string">"/1/2"</span> =&gt; %&#123;&#125;&#125;,</span><br><span class="line">    <span class="string">"/a"</span> =&gt; %&#123;<span class="string">"/a/b"</span> =&gt; %&#123;<span class="string">"/a/b/c"</span> =&gt; %&#123;<span class="string">"/a/b/c/d"</span> =&gt; %&#123;&#125;&#125;&#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then is the most import function <code>dft_with_sort</code>, we need to sort our items when traversing depth-first.</p><p>We need a stack to store tree nodes, at the very first, there is only one node: the root node. With the popped node, we get a current subtree and a list of remained subtrees. The key of the current subtree is then added to the result list. This is our first item. Then the values need to be sorted by our given index. So we build a sorter, which is just the standard with index items ahead of create_time sorted items.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">values</span><br><span class="line">|&gt; Map.to_list()</span><br><span class="line">|&gt; Enum.sort_by(&amp;&#123;Enum.find_index(sorter, <span class="keyword">fn</span> x -&gt; </span><br><span class="line">  x ==  List.first(Tuple.to_list(&amp;<span class="number">1</span>)) </span><br><span class="line">  <span class="keyword">end</span>)&#125;)</span><br><span class="line">|&gt; Enum.map(<span class="keyword">fn</span> &#123;key, value&#125; -&gt; %&#123;key =&gt; value&#125; <span class="keyword">end</span>)</span><br><span class="line">|&gt; Enum.reverse()</span><br></pre></td></tr></table></figure><p><code>Map.to_list()</code> changes the key=&gt;value to a tuple (key, value), for example: </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">map = %&#123;</span><br><span class="line">  <span class="string">"/folder2/folder2-folder1"</span> =&gt; %&#123;</span><br><span class="line">    <span class="string">"/folder2/folder2-folder1/file1"</span> =&gt; %&#123;&#125;,</span><br><span class="line">    <span class="string">"/folder2/folder2-folder1/file2"</span> =&gt; %&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"/folder2/folder2-folder2"</span> =&gt; %&#123;</span><br><span class="line">    <span class="string">"/folder2/folder2-folder2/file1"</span> =&gt; %&#123;&#125;,</span><br><span class="line">    <span class="string">"/folder2/folder2-folder2/file2"</span> =&gt; %&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Map.to_list(map) = [</span><br><span class="line">  &#123;<span class="string">"/folder2/folder2-folder1"</span>,</span><br><span class="line">   %&#123;</span><br><span class="line">     <span class="string">"/folder2/folder2-folder1/file1"</span> =&gt; %&#123;&#125;,</span><br><span class="line">     <span class="string">"/folder2/folder2-folder1/file2"</span> =&gt; %&#123;&#125;</span><br><span class="line">   &#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"/folder2/folder2-folder2"</span>,</span><br><span class="line">   %&#123;</span><br><span class="line">     <span class="string">"/folder2/folder2-folder2/file1"</span> =&gt; %&#123;&#125;,</span><br><span class="line">     <span class="string">"/folder2/folder2-folder2/file2"</span> =&gt; %&#123;&#125;</span><br><span class="line">   &#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>List.first(Tuple.to_list(&amp;1))</code> gets the key (location) and values then sort by sorter (standard). Finally we change the tuple back to dict and reverse the order. </p><p>Why we need to reverse the order here? Because we will pop from the last one next time. <code>[remain | new]</code> is the new stack, we are traversing depth-first.</p><p>Another key point is <code>dft_with_sort([], res, _time_sorted_locs, _indexes)</code>, this is used to return our final result when stack is empty.</p><p>For the whole code, please go <a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/blob/master/Tree/MultiwayTree/sort_by_tree.ex" target="_blank" rel="noopener">here</a>.</p><h2 id="The-Ultimate-Weapon"><a href="#The-Ultimate-Weapon" class="headerlink" title="The Ultimate Weapon"></a>The Ultimate Weapon</h2><p>When we used the former solutions to our production, we were not satisfied with the performance. Because this module is used very frequently, so we need a much quicker one. With some more research, we found it — add a parent for each location, and let the tree contain the needed order. Here is our reference: <a href="https://stackoverflow.com/questions/42577866/create-a-hierarchical-data-structure-from-a-flat-list-with-parent-id" target="_blank" rel="noopener">elixir - Create a hierarchical data structure from a flat list with parent_id - Stack Overflow</a>.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Sorter</span></span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span></span>(list, index_dict) <span class="keyword">do</span></span><br><span class="line">    tree = list</span><br><span class="line">    |&gt; Enum.reduce(%&#123;&#125;, <span class="keyword">fn</span> foo, map -&gt;</span><br><span class="line">      foo = %&#123;foo | <span class="symbol">children:</span> Map.get(map, foo.location, [])&#125;</span><br><span class="line"></span><br><span class="line">      Map.update(map, foo.parent, [foo], <span class="keyword">fn</span> foos -&gt;</span><br><span class="line">        children = [foo | foos]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> Map.get(index_dict, foo.parent) <span class="keyword">do</span></span><br><span class="line">          <span class="keyword">nil</span> -&gt;</span><br><span class="line">            children</span><br><span class="line"></span><br><span class="line">          index_list -&gt;</span><br><span class="line">            children</span><br><span class="line">            |&gt; Enum.sort_by(&amp;(Enum.find_index(index_list, <span class="keyword">fn</span> item -&gt;</span><br><span class="line">              item == &amp;<span class="number">1</span>.location</span><br><span class="line">            <span class="keyword">end</span>)))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    |&gt; Map.get(<span class="keyword">nil</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dft</span></span>([], res), <span class="symbol">do:</span> res</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dft</span></span>(stack, res) <span class="keyword">do</span></span><br><span class="line">    &#123;curr, remain&#125; = List.pop_at(stack, -<span class="number">1</span>)</span><br><span class="line">    res = [curr.location | res]</span><br><span class="line">    [remain | Enum.reverse(curr.children)] </span><br><span class="line">    |&gt; List.flatten()</span><br><span class="line">    |&gt; dft(res)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(item_list, index_dict) <span class="keyword">do</span></span><br><span class="line">    item_list</span><br><span class="line">    |&gt; Enum.sort_by(&amp; &amp;<span class="number">1</span>.create_time)</span><br><span class="line">    |&gt; add_parent()</span><br><span class="line">    |&gt; build_tree(index_dict)</span><br><span class="line">    |&gt; dft([])</span><br><span class="line">    |&gt; Enum.reverse()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_parent</span></span>(item_list) <span class="keyword">do</span></span><br><span class="line">    init = %&#123;<span class="symbol">location:</span> <span class="string">"/"</span>, <span class="symbol">parent:</span> <span class="keyword">nil</span>, <span class="symbol">children:</span> []&#125;</span><br><span class="line">    item_list</span><br><span class="line">    |&gt; Enum.reduce([init], <span class="keyword">fn</span> item, new_list -&gt;</span><br><span class="line">      parent = get_parent(item.location)</span><br><span class="line">      new_item = %&#123;<span class="symbol">location:</span> item.location, <span class="symbol">parent:</span> parent, <span class="symbol">children:</span> []&#125;</span><br><span class="line">      [new_item | new_list]</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Pay attention, here we change our item structure to the following to get more convenient processing. </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123; <span class="symbol">location:</span> <span class="string">"/folder1"</span>, <span class="symbol">create_time:</span> <span class="string">"2019-03-01"</span> &#125;</span><br></pre></td></tr></table></figure><p>Look at this smart thought, we have used less code, but more clearer and faster. The <code>dft</code> function is just like what we’ve seen before, but we do not need to sort. The core function here is the <code>build_tree</code> function. It does two main things: build a tree and sort when building. We must be very familiar with the sort part, it’s almost the same as above, but much easier and clearer. Now let’s focus on the build tree part. </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Tree</span></span> <span class="keyword">do</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span></span>(list) <span class="keyword">do</span></span><br><span class="line">    list</span><br><span class="line">    |&gt; Enum.reduce(%&#123;&#125;, <span class="keyword">fn</span> foo, map -&gt;</span><br><span class="line">      foo = %&#123;foo | <span class="symbol">children:</span> Map.get(map, foo.location, [])&#125;</span><br><span class="line">      Map.update(map, foo.parent, [foo], <span class="keyword">fn</span> foos -&gt;</span><br><span class="line">        [foo | foos]</span><br><span class="line">      <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    |&gt; Map.get(<span class="keyword">nil</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>What does this do? Let’s show you a simple example.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list = [</span><br><span class="line">  %&#123; <span class="symbol">location:</span> <span class="string">"/"</span>, <span class="symbol">parent:</span> <span class="keyword">nil</span>, <span class="symbol">children:</span> [] &#125;,</span><br><span class="line">  %&#123; <span class="symbol">location:</span> <span class="string">"/folder1"</span>, <span class="symbol">parent:</span> <span class="string">"/"</span>, <span class="symbol">children:</span> [] &#125;,</span><br><span class="line">  %&#123; <span class="symbol">location:</span> <span class="string">"/folder1/folder1-folder1"</span>, <span class="symbol">parent:</span> <span class="string">"/folder1"</span>, <span class="symbol">children:</span> [] &#125;,</span><br><span class="line">  %&#123; <span class="symbol">location:</span> <span class="string">"/folder2"</span>, <span class="symbol">parent:</span> <span class="string">"/"</span>, <span class="symbol">children:</span> [] &#125;,</span><br><span class="line">  %&#123; <span class="symbol">location:</span> <span class="string">"/folder2/folder2-folder1"</span>, <span class="symbol">parent:</span> <span class="string">"/folder2"</span>, <span class="symbol">children:</span> [] &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># tree</span></span><br><span class="line">Sorter.build_tree(list) |&gt; IO.inspect()</span><br><span class="line">[%&#123;<span class="symbol">children:</span> [], <span class="symbol">location:</span> <span class="string">"/"</span>, <span class="symbol">parent:</span> <span class="keyword">nil</span>&#125;]</span><br></pre></td></tr></table></figure><p>What happened here? Maybe we should remove the <code>Map.get(nil)</code> to see more.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">  <span class="keyword">nil</span> =&gt; [%&#123;<span class="symbol">children:</span> [], <span class="symbol">location:</span> <span class="string">"/"</span>, <span class="symbol">parent:</span> <span class="keyword">nil</span>&#125;],</span><br><span class="line">  <span class="string">"/"</span> =&gt; [</span><br><span class="line">    %&#123;<span class="symbol">children:</span> [], <span class="symbol">location:</span> <span class="string">"/folder2"</span>, <span class="symbol">parent:</span> <span class="string">"/"</span>&#125;,</span><br><span class="line">    %&#123;<span class="symbol">children:</span> [], <span class="symbol">location:</span> <span class="string">"/folder1"</span>, <span class="symbol">parent:</span> <span class="string">"/"</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"/folder1"</span> =&gt; [</span><br><span class="line">    %&#123;<span class="symbol">children:</span> [], <span class="symbol">location:</span> <span class="string">"/folder1/folder1-folder1"</span>, <span class="symbol">parent:</span> <span class="string">"/folder1"</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"/folder2"</span> =&gt; [</span><br><span class="line">    %&#123;<span class="symbol">children:</span> [], <span class="symbol">location:</span> <span class="string">"/folder2/folder2-folder1"</span>, <span class="symbol">parent:</span> <span class="string">"/folder2"</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now it’s clear, let’s explain some code in the function.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = %&#123;foo | <span class="symbol">children:</span> Map.get(map, foo.location, [])&#125;</span><br></pre></td></tr></table></figure><p>This is used to update a key (here is the children key) of a map (here is foo). For a simple example:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iex&gt; map = %&#123;<span class="symbol">one:</span> <span class="number">1</span>, <span class="symbol">two:</span> <span class="number">2</span>&#125;</span><br><span class="line">iex&gt; %&#123;map | <span class="symbol">one:</span> <span class="string">"one"</span>&#125;</span><br><span class="line">%&#123;<span class="symbol">one:</span> <span class="string">"one"</span>, <span class="symbol">two:</span> <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>Then the map update:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Map.update(map, key, initial, fun)</span></span><br><span class="line">Map.update(map, foo.parent, [foo], <span class="keyword">fn</span> foos -&gt; [foo | foos] <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>The meaning is to update the value of the <code>foo.parent</code> key from <code>foos</code> to <code>[foo | foos]</code>. For a simple instance:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iex &gt;Map.update(%&#123;<span class="symbol">a:</span> <span class="number">1</span>&#125;, <span class="symbol">:a</span>, <span class="number">13</span>, <span class="keyword">fn</span> x -&gt; x * <span class="number">2</span> <span class="keyword">end</span>)</span><br><span class="line">%&#123;<span class="symbol">a:</span> <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>Now we know exactly what the function do. It first updates children, then update this update to its parent. So we should use bottom-up approach to get the full tree. We just need to reverse the given list.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Sorter.build_tree(list |&gt; Enum.reverse())</span><br><span class="line">tree = [</span><br><span class="line">    %&#123;</span><br><span class="line">      <span class="symbol">children:</span> [</span><br><span class="line">        %&#123;</span><br><span class="line">          <span class="symbol">children:</span> [</span><br><span class="line">            %&#123;</span><br><span class="line">              <span class="symbol">children:</span> [],</span><br><span class="line">              <span class="symbol">location:</span> <span class="string">"/folder1/folder1-folder1"</span>,</span><br><span class="line">              <span class="symbol">parent:</span> <span class="string">"/folder1"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="symbol">location:</span> <span class="string">"/folder1"</span>,</span><br><span class="line">          <span class="symbol">parent:</span> <span class="string">"/"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        %&#123;</span><br><span class="line">          <span class="symbol">children:</span> [</span><br><span class="line">            %&#123;</span><br><span class="line">              <span class="symbol">children:</span> [],</span><br><span class="line">              <span class="symbol">location:</span> <span class="string">"/folder2/folder2-folder1"</span>,</span><br><span class="line">              <span class="symbol">parent:</span> <span class="string">"/folder2"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="symbol">location:</span> <span class="string">"/folder2"</span>,</span><br><span class="line">          <span class="symbol">parent:</span> <span class="string">"/"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="symbol">location:</span> <span class="string">"/"</span>,</span><br><span class="line">      <span class="symbol">parent:</span> <span class="keyword">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>You could play with the code <a href="https://github.com/hscspring/The-DataStructure-and-Algorithms/blob/master/Tree/MultiwayTree/build.ex" target="_blank" rel="noopener">here</a>. Believe me, it’s very interesting.</p><p>Actually, this method can be used in many fields, especially in the tree data structure. Additionally, use id instead of the real value will always process much faster.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this article, we have introduced a typical case of multiway tree. We have shown how to build it based on item values and their parents. We have also shown how to sort the tree by some external conditions. In fact, we believe this case could be used in many fields in your routine work.</p><p>By the way, what we have mentioned above is just a simplified sample. Actually we did many optimization in the real world. For example, we sorted the items when querying from database; we cached the result in Redis, and so on.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Several weeks ago, we met a sort problem in our program of web app. We tried kinds of methods and finally have gotten a nearly 10 times performance improvement. The problem is very interesting and worth recording.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
      <category term="Elixir" scheme="https://www.yam.gift/tags/Elixir/"/>
    
      <category term="Sort" scheme="https://www.yam.gift/tags/Sort/"/>
    
      <category term="Tree" scheme="https://www.yam.gift/tags/Tree/"/>
    
      <category term="Multiway Tree" scheme="https://www.yam.gift/tags/Multiway-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Python 小白快速从入门到放弃</title>
    <link href="https://www.yam.gift/2019/10/10/Py4F/2019-10-10-Python-for-Freshman/"/>
    <id>https://www.yam.gift/2019/10/10/Py4F/2019-10-10-Python-for-Freshman/</id>
    <published>2019-10-10T15:00:00.000Z</published>
    <updated>2019-12-03T04:25:03.902Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://yam.gift/2019/04/10/Py4F/2019-04-10-Python-for-Freshman-Ch00/" target="_blank" rel="noopener">Ch00：在开始前 | Yam</a></li><li><a href="https://yam.gift/2019/10/02/Py4F/2019-10-02-Python-for-Freshman-Ch01/" target="_blank" rel="noopener">Ch01：基础知识 | Yam</a></li><li><a href="https://yam.gift/2019/10/03/Py4F/2019-10-03-Python-for-Freshman-Ch02/" target="_blank" rel="noopener">Ch02：使用模块 | Yam</a></li><li><a href="https://yam.gift/2019/10/10/Py4F/2019-10-10-Python-for-Freshman-Ch03/" target="_blank" rel="noopener">Ch03：使用框架 | Yam</a></li><li><a href="https://yam.gift/2019/10/06/Py4F/2019-10-06-Python-for-Freshman-Ch04/" target="_blank" rel="noopener">Ch04：阅读源码 | Yam</a></li><li><a href="https://yam.gift/2019/10/07/Py4F/2019-10-07-Python-for-Freshman-Ch05/" target="_blank" rel="noopener">Ch05：在结束后 | Yam</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://yam.gift/2019/04/10/Py4F/2019-04-10-Python-for-Freshman-Ch00/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ch00：在开始前 | Yam&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 小白快速从入门到放弃：使用框架</title>
    <link href="https://www.yam.gift/2019/10/10/Py4F/2019-10-10-Python-for-Freshman-Ch03/"/>
    <id>https://www.yam.gift/2019/10/10/Py4F/2019-10-10-Python-for-Freshman-Ch03/</id>
    <published>2019-10-10T15:00:00.000Z</published>
    <updated>2019-10-11T03:14:49.194Z</updated>
    
    <content type="html"><![CDATA[<p>随着学习的不断深入，我们肯定会越来越不满足只在 Jupyter Notebook 中写一些小任务。我们可能会希望做一个 Web 应用，或者一个小程序，甚至是一个 APP。对于这种系统性的工程项目，框架就必不可少了，它可以极大地提高我们的效率。这节课我们就以 Python 的 Django 框架为例来开发一个小的 Web 应用程序。</p><a id="more"></a><h2 id="Django-简介"><a href="#Django-简介" class="headerlink" title="Django 简介"></a>Django 简介</h2><p>Python 的 Web 框架有很多个，各有特色，很难说哪个比其他的有绝对压倒性优势，之所以用 Django 是因为它相对比较系统，能自动帮我们做不少工作，也是为了省点事；而且怎么说毕竟也是用户最多的框架之一了，用来入门还是可以的。</p><p>在 Django 框架下，可以完成后端和前端，不过前端我们一般会采用其他框架（比如 React，Vue）。Django 自己声称它是一个模型 - 模板 - 视图（model-template-view）框架。项目围绕 App 组织，每一个 App 都有其自己的模型、视图以及测试设置，像一个小项目。Django 项目基本上就是一个小 App 的集合，每一个 App 都负责一个特定的子系统。整个项目就像搭积木一样就这样堆起来了。</p><p><strong>快速感受</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ pip install Django</span><br><span class="line"><span class="comment"># 创建一个项目根目录</span></span><br><span class="line">$ mkdir webapp &amp;&amp; <span class="built_in">cd</span> <span class="string">"<span class="variable">$_</span>"</span></span><br><span class="line"><span class="comment"># 创建一个 project</span></span><br><span class="line">$ django-admin startproject order_server</span><br><span class="line"><span class="comment"># 迁移数据</span></span><br><span class="line">$ python manage.py migrate</span><br></pre></td></tr></table></figure><p>此时，我们已经用下面的命令可以启动项目了（是不是感觉很简单）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py runserver</span><br></pre></td></tr></table></figure><p>它甚至还自带了一个管理后台：<a href="http://127.0.0.1:8000/admin/" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/</a></p><p><strong>项目概览</strong></p><p>上面的三步完成后，如果我们去查看它的目录，应该是这样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── db.sqlite3</span><br><span class="line">├── manage.py</span><br><span class="line">└── order_server</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── settings</span><br><span class="line">    ├── urls.py</span><br><span class="line">    └── wsgi.py</span><br></pre></td></tr></table></figure><p>它们分别代表什么呢？</p><ul><li><code>db.sqlite3</code> 是数据库文件，默认使用 <a href="https://www.sqlite.org/index.html" target="_blank" rel="noopener">SQLite</a>，这是一个轻巧的、零配置、无服务器的数据库。</li><li><code>manage.py</code> 是管理命令行启动任务的，在执行命令之前会先从 settings 那里读取配置。</li><li><code>order_server</code> 是本项目配置、url 和 wsgi 入口，该文件夹本身也是一个包</li></ul><p>这里我们把 <code>settings.py</code> 分拆成按开发和产品，这样在配置开发环境（比如 Database）时比较方便。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>其实这里才是真正项目的起点，我们需要根据业务场景对工程进行设计。此处，我们依然延续之前的内容，做一个订单服务系统。简单起见，我们只做一个给用户展示菜单（就之前的 <code>print_order</code>）、用户点菜提交、将用户订单返回的功能。</p><p><strong>App</strong></p><p>前面提到 Django 是围绕着 App 来搞得，我们首先来设计 App。对于我们这个非常简单的小任务来说，只需要两个 App 就足够了，分别是：针对用户的和针对订单的。需要注意的是，我们尽量根据功能拆分 App 而不要根据场景（比如 Web，App，小程序这样），就像函数一样，一个 App 就做一件事。用  <a href="https://www.youtube.com/watch?v=A-S0tqpPga4&amp;feature=youtu.be" target="_blank" rel="noopener">DjangoCon 2008: James Bennett-Reusable Apps</a> 的观点就是：App = some bit of funtionality，Site = several apps。这也是我喜欢 Django 的最重要的原因。所以，这里我们两个 App 就有了，分别是：auth 和 order。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 App</span></span><br><span class="line">$ python manage.py startapp authenticate</span><br><span class="line">$ python manage.py startapp order</span><br><span class="line"><span class="comment"># 每一个 App 的目录</span></span><br><span class="line">.</span><br><span class="line">├── __init__.py</span><br><span class="line">├── admin.py</span><br><span class="line">├── apps.py</span><br><span class="line">├── migrations</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── models.py</span><br><span class="line">├── tests.py</span><br><span class="line">└── views.py</span><br></pre></td></tr></table></figure><ul><li><code>admin.py</code>：管理后台相关的</li><li><code>apps.py</code>：自动生成的配置文件，不要管</li><li><code>migrations</code>：数据库更新的</li><li><code>models.py</code>：数据库模型</li><li><code>views.py</code>：实现接口功能</li></ul><p><strong>API</strong></p><p>App 确定后，我们先设计对外的 API，也就是前端将来要请求的地址。简单起见，authenticate 模块我们只设计注册和登陆接口；order 模块只设计菜单展示、点菜接口。分别如下：</p><ul><li>auth: <ul><li><code>/auth/sign_up/</code></li><li><code>/auth/login/</code></li></ul></li><li>order:<ul><li><code>/order/show_menu/</code></li><li><code>/order/submit_order/</code></li></ul></li></ul><p><strong>DataBase</strong></p><p>接下来就是数据库的表了，auth 这里有点特殊，因为 Django 已经为我们创建好了用户表，所以我们得重新起个名字，比如叫 UserProfile；order 涉及到两张表，一张是 food，一张是 order，分别对应菜品和订单。menu 是 food 的组合。</p><ul><li>auth_user_profile 表：<ul><li>phone：手机号，也将作为 auth_user 表的用户名</li><li>nickname：昵称</li><li>identity：身份（VIP，VVIP，NORMAL）</li></ul></li><li>order_menu 表：<ul><li>name：菜名</li><li>price：价格</li><li>sold_out: 是否售罄</li></ul></li><li>order_order 表：<ul><li>order_number: 订单编号</li><li>user_id：用户 id，用户登陆后自动返给前端的，之后的请求都会带上</li><li>food_id：菜品 id</li><li>amount：份数</li></ul></li></ul><p>另外，所有表都要有 id，创建时间和更新时间。</p><h2 id="理想流程"><a href="#理想流程" class="headerlink" title="理想流程"></a>理想流程</h2><p>API 有常用的 <a href="https://www.restapitutorial.com/" target="_blank" rel="noopener">REST API</a>，或比较新的 <a href="https://graphql.org/" target="_blank" rel="noopener">GraphQL</a>，我们这里以 REST 为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip install djangorestframework</span><br><span class="line">$ pip install djangorestframework_simplejwt</span><br><span class="line">$ pip install django-cors-headers</span><br></pre></td></tr></table></figure><p>首先需要安装 <a href="https://www.django-rest-framework.org/" target="_blank" rel="noopener">restframework</a>，<a href="https://github.com/davesque/django-rest-framework-simplejwt" target="_blank" rel="noopener">simplejwt</a> 和 <a href="https://github.com/adamchainz/django-cors-headers" target="_blank" rel="noopener">cors-headers</a>。第一个是专门为 rest 接口服务的；第二个是用户鉴权用的，这块已经非常成熟了，我们拿现成的过来用就行；第三个是解决跨域问题的（否则前端没办法访问），端口不同属于不同域，其他不同域的情况还包括协议不同如 http 和 https，域名不同。Django 的全局配置一般都在 settings 文件夹下面的配置文件中，我们根据文档和自己的需要配置即可，具体的大家可以看代码，这里不涉及细节了。</p><p>然后准备开始具体业务逻辑的实现，可以分别实现每个 App，每个 App 除了上面提到已有的这些内容外，还需要添加一个 <code>urls.py</code> 和 <code>serializers.py</code>，前者是把本模块的接口放在一起作为整体提供给配置文件同目录的 <code>urls.py</code>，后者是 REST 接口序列化的，可以自定义字段。</p><p><strong><code>urls.py</code></strong></p><p>主要定义 API 的各种接口 URL。这里有两个地方要注意的：</p><ul><li>每个模块下面的 URLs 都要汇总到 <code>order_server</code> 这个模块下面，具体的地址是二者的 join</li><li>模块下的 URLs 在 POST 请求时注意跨域问题</li></ul><p><strong><code>models.py</code></strong></p><p>主要定义数据结构（也就是数据库的表），这里可以通过官方文档进一步了解（比如不同类型的字段、ForeignKey 等）。有两点需要注意：</p><ul><li>一个 model 中也可以引用其他 App 的 model，比如 Order 中引用 User</li><li><code>models.py</code> 中做了调整，记得要 makemigrations 和 migrate，无论是马上做还是事后一起做</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py makemigrations <span class="comment"># 后面可以跟某个 App 的名字，也可以不跟（就是所有 App）</span></span><br><span class="line">$ python manage.py migrate</span><br></pre></td></tr></table></figure><p>前者创建迁移代码（在每个 App 下面的 migrations 文件夹下面），后者将数据变化更新到数据库。</p><p><strong><code>views.py</code></strong></p><p>包括 <code>serializers.py</code>，主要处理业务逻辑。需要注意的是，它也像 model 一样可以相互组合灵活使用。比如我们的 <code>/api/auth/login/</code> 接口其实就直接用了 <a href="https://github.com/davesque/django-rest-framework-simplejwt" target="_blank" rel="noopener">simplejwt</a> 的 view，并没有（也不需要）自己实现。我们每做完一个接口后，可以通过 <a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a> 看一下调用情况。</p><p><strong><code>tests</code></strong></p><p>正常情况下在开发的同时还需要在 <code>tests</code> 下面添加每个函数和类对应的测试，测试的好处不需要多说，大家切记，只要你开始做项目（包括公开发布包或模块）了，测试时刻跟上。</p><p>测试一般包括各种正常、异常的情况：正常请求返回结果是否符合预期、异常请求能否被预期捕获。异常请求通常使用一些边界条件。测试在项目小的时候很不明显（甚至有些麻烦），但随着项目的不断扩充，如果没有测试简直就是噩梦：意味着每改动一个地方，所有的接口可能得全部人工测试一遍（包括那些边界请求）。除此之外，写测试还有个几个好处：第一，一次写好，之后几乎不用再更改，但一直能发挥作用；第二，为不熟悉项目的同事提供了一个非常好的教程，通过阅读测试代码可以快速知道模块的功能；第三，方便排查错误——测试通过的地方一般不会有问题。在本例中，我也简单地写了一些测试供大家参考。</p><p>以上涉及的代码及接口调用文档在这里：<a href="https://github.com/hscspring/Python-for-Freshman/tree/master/webapp" target="_blank" rel="noopener">Python-for-Freshman</a>，额外提一句，如果能给到前端一个完善的 API 文档（无论何种形式），会节约彼此很多时间。有很多文档生成工具，比如 <a href="http://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener">Sphinx</a>。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>启动</strong></p><p>因为我们只是简单演示了一个基本功能，所以要想完成演示，还需要完善几个地方：</p><ul><li><p>创建用户：这个可以通过注册的 API 完成</p></li><li><p>创建菜品：这个可以直接通过对应的（简单）接口完成</p></li></ul><p>当然，现在这样还远远谈不上完善，比如更新打折比例需现在是用字典配置的，在业务比较简单时没啥问题，当业务变复杂、感觉不太方便时可以独立成一个 App（比如 Marketing 或 Produce）。</p><p><strong>Bug</strong></p><p>我们每个人几乎可以肯定会碰到 Bug，我自己当然也不例外。比如这次就碰到了两个：第一个来自 <code>simplejwt</code>，主要是和 restframework 本身的验证冲突了；第二个来自 serializers 的 <code>HyperlinkedModelSerializer</code>，具体的问题和 <a href="https://stackoverflow.com/questions/20550598/django-rest-framework-could-not-resolve-url-for-hyperlinked-relationship-using" target="_blank" rel="noopener">这个</a> 有点类似。还有其他一些小的 Bug，比如忘记在 <code>settings.py</code> 中添加 App，变量名写错之类。</p><p>而且，使用框架还有个和前面讲的写代码不一样的问题，就是很多 Bug 是对框架不熟悉导致的。越是操作简单方便的，出现 Bug 后可能越难定位。</p><p><strong>其他</strong></p><p>本例中的所有做法只是很多种可能的一种，当然会有其他方法能达到同样的目的，如果大家看了 restframework 的文档就会发现，光是<a href="https://www.django-rest-framework.org/api-guide/authentication/" target="_blank" rel="noopener">验证</a>就有好多种方法。这种不同不仅体现在代码层面，也体现在设计层面和具体实现过程，不同人可能各方面思路都不相同，所以推荐大家多阅读大神的或优秀的开源项目，看看他们是怎么做的。</p><p>由于作者本人经验尚浅，其中可能有一些不太合理的地方，比如 food_id 返回是不是合理？再比如错误处理，最好能统一设计好，我们这里就比较随意了。再比如点菜后订单的更新是否要根据菜品循环呢，是不是可以把点的菜作为一个 dict（需要 postgresSQL 或 MySQL 支持）存起来？总之，一个项目（或工程）要考虑的绝不仅仅是写代码的问题，还有诸多如设计、安全、性能、与前端配合等等都不能忽略。大家感兴趣的话可以看些软件设计类的书，当然最重要的是——多做项目。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节我们以 Django 为例简要概述了如何从零开发一个后端服务，这并不是一个 Django 教程，所以我们重点讲了下设计和基本流程，其中的细节大家可以在网上搜索，下面也列出来一些。其他框架其实多少也有些类似，如果有机会也可以多尝试一下。我的观点还是和开篇的那些观点类似：不要讨论哪个框架好，或者某个比另一个好，根据业务的需要选择适合自己的就是最好的。</p><p>由于是拿 Django 举例的，最后再简单放几个相关教程，大家也可以上网自己搜喜欢的。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django" target="_blank" rel="noopener">Django Web Framework (Python) - Learn web development | MDN</a></li><li><p><a href="https://www.youtube.com/channel/UCRM1gWNTDx0SHIqUJygD-kQ" target="_blank" rel="noopener">JustDjango - YouTube</a></p></li><li><p><a href="https://www.youtube.com/channel/UCWEHue8kksIaktO8KTTN_zg" target="_blank" rel="noopener">CodingEntrepreneurs - YouTube</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着学习的不断深入，我们肯定会越来越不满足只在 Jupyter Notebook 中写一些小任务。我们可能会希望做一个 Web 应用，或者一个小程序，甚至是一个 APP。对于这种系统性的工程项目，框架就必不可少了，它可以极大地提高我们的效率。这节课我们就以 Python 的 Django 框架为例来开发一个小的 Web 应用程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
      <category term="Django" scheme="https://www.yam.gift/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Python 小白快速从入门到放弃：在结束后</title>
    <link href="https://www.yam.gift/2019/10/07/Py4F/2019-10-07-Python-for-Freshman-Ch05/"/>
    <id>https://www.yam.gift/2019/10/07/Py4F/2019-10-07-Python-for-Freshman-Ch05/</id>
    <published>2019-10-07T12:00:00.000Z</published>
    <updated>2019-11-03T03:15:55.236Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列的课程的目标在《在开始前》已经说得很清楚了：解决重复劳动或自己做好玩儿的小项目；尝试新的思维方式。这短短的几节课要想把 Python 的相关知识面面俱到是不可能的，但我觉得已经给出了一个全图景，大家只要围绕这个做，达到目标应该是不成问题的。我想说的还是一直提倡的：Just do it，在实践中不断成长。</p><a id="more"></a><p>此外，有几点需要特别提醒一下：</p><ul><li>如果学编程平时不用（无论什么原因，表现出来就是经常不用），或者想通过不具体使用而只学习其中的思想，我建议还是不要学得好。因为我很担心那样学到的全是 “司机的知识”：停留在表面，说起来侃侃而谈，以为自己懂了。当然，如果你的目的就是如此，那没问题了。</li><li><p>计算机领域知识是非常庞杂的，一个完整的系统即使每个地方只涉及一点点，总共加起来的知识量也不小。所以如果不是以此为业的话，建议时刻以 “完成任务” 为指导方针，缺哪块就补哪块，开始时会用就行，不要陷到某个小点上太久出不来。</p></li><li><p>正是因为上一点，刚开始的新人必定会遇到各种各样的 bug，这也是我们建议使用 Jupyter Notebook 作为第一步入门的原因。但后面的复杂任务或者项目再用这个肯定就不合适了，遇到 bug 要始终保持一个信念：“只要是 bug 就一定能 de 掉”。你只有信念不倒，才会有很强的动力分析问题、寻找解决策略，否则很快就烦了。而且更让你闹心的是，很多 bug 完全不是 Python 相关的，可能是数据库、缓存、接口通信、甚至操作系统等等方面的问题。</p></li></ul><p>最后，推荐一些资源，前三个现在看应该没啥问题，后三个可能会有些难度，可以作为进阶资料。资料这个东西不一定非要一次从头到尾看完（那样肯定会累死，而且累死也看不完），挑自己感兴趣或者有问题的地方看就可以了。希望每个人都能得偿所愿。</p><ul><li><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">jackfrued/Python-100-Days: Python - 100 天从新手到大师</a></li><li><a href="https://realpython.com/start-here/" target="_blank" rel="noopener">Learn Python Programming Online – Real Python</a></li><li><a href="https://pymotw.com/3/index.html" target="_blank" rel="noopener">Python 3 Module of the Week — PyMOTW 3</a></li><li><a href="https://book.pythontips.com/en/latest/index.html" target="_blank" rel="noopener">Intermediate Python — Python Tips 0.1 documentation</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Python Cookbook 3rd Edition Documentation — python3-cookbook 3.0.0 文档</a></li><li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">The Hitchhiker’s Guide to Python! — The Hitchhiker’s Guide to Python</a></li></ul><blockquote><p>作者本人经验尚浅，远谈不上精通。如果有不合理的地方还请多多指正，我们互相学习。</p></blockquote><h2 id="附录：作业"><a href="#附录：作业" class="headerlink" title="附录：作业"></a>附录：作业</h2><p><strong>第一章</strong>：请配置好环境自由探索。难度 ☆</p><p><strong>第二章</strong>：请用几种不同的编程方式实现一个独立完整的小功能。难度 ☆☆</p><p><strong>第三章</strong>：请在 PyPI test 上提交一个自己的包并能在本地安装。难度 ☆☆☆</p><p><strong>第四章</strong>：请在已提供的代码基础上实现一个其他功能或重新改写成一个自己的业务需求。难度 ☆☆☆☆</p><p><strong>第五章</strong>：请阅读一份自己感兴趣的项目源代码并通过讲解或笔记输出。难度 ☆☆☆☆☆</p><p><strong>第六章</strong>：请整理总结自己所学并切实做好未来规划。难度 ☆☆</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列的课程的目标在《在开始前》已经说得很清楚了：解决重复劳动或自己做好玩儿的小项目；尝试新的思维方式。这短短的几节课要想把 Python 的相关知识面面俱到是不可能的，但我觉得已经给出了一个全图景，大家只要围绕这个做，达到目标应该是不成问题的。我想说的还是一直提倡的：Just do it，在实践中不断成长。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 小白快速从入门到放弃：阅读源码</title>
    <link href="https://www.yam.gift/2019/10/06/Py4F/2019-10-06-Python-for-Freshman-Ch04/"/>
    <id>https://www.yam.gift/2019/10/06/Py4F/2019-10-06-Python-for-Freshman-Ch04/</id>
    <published>2019-10-06T15:00:00.000Z</published>
    <updated>2019-10-11T03:16:16.465Z</updated>
    
    <content type="html"><![CDATA[<p>学编程最重要的就是写代码、读代码。上节提到了要阅读大神的或优秀的代码，之前也一直在强调要动手实践，这节咱们关注下如何阅读源代码。好的源代码不仅能让我们学到关于编程的知识，而且还有如何思考问题、抽象业务、设计架构等等方面知识。</p><a id="more"></a><h2 id="读什么"><a href="#读什么" class="headerlink" title="读什么"></a>读什么</h2><p>很多人应该都有这样的经历：任何你想了解的领域或学习的知识，只要随便一搜都有海量的资源。我们的问题是如何找到最适合自己当前情况的资源。如果有同学对这个问题感兴趣，可以关注<a href="https://m.openmindclub.com/mkt" target="_blank" rel="noopener">开智学堂</a>的《信息分析》课程，这里我就直接给出来了。其实关键点就三个：</p><ul><li><p>大神的</p></li><li><p>优秀的</p></li><li>简单的</li></ul><p>我们接下来就分别说一说，说完之后，我们要读的东西自然就出来了。</p><p>首先，要看大神的作品，理由就不必多说了。我推荐两个公认代码写的好的（而且人也很帅）：</p><ul><li><a href="https://github.com/kennethreitz" target="_blank" rel="noopener">kennethreitz (☿ Kenneth Reitz)</a></li><li><a href="https://github.com/mitsuhiko" target="_blank" rel="noopener">mitsuhiko (Armin Ronacher)</a></li></ul><p>第一个是 <code>requests</code>, <code>python-guide</code> 和 <code>pipenv</code> 的作者，以后大家多半会用到，现在不管就是了；第二个是 Flask 和 Jinja 的作者，以后也多半会用到。从他们的 GitHub Repository 开始就是个非常棒的开始。</p><p>其次，选择优秀的项目。大神的一般就很优秀，咱就不多说了。除了大神的作品外，各个领域往往也有很多优秀的项目，比如你是搞机器学习的，那么 <code>sklearn</code> 的源代码就非常的工业化，绝对值得学习；如果你是搞深度学习的，Google 和 Facebook 的代码就可以多看看。通过这两个例子大家应该看出来了：没错，就是选择知名的库和知名的公司出品的项目。另外，有本很多地方都推荐过的书：<a href="http://www.aosabook.org/en/index.html" target="_blank" rel="noopener">The Architecture of Open Source Applications</a>。</p><p>最后，选个简单的，尤其是刚开始的时候；或者选择优秀项目中的一部分功能。什么是简单的呢？第一，代码文件比较少，最好选择一两个的；第二，领域熟悉的，你不应该在不知道 SQL 的情况下选择一个数据库相关的项目。如果在 GitHub 上找，可以点击到 Repositories 列表，然后 filter language 选择 Python 后挨个浏览查找适合自己阅读的。</p><p>如果你实在难以选出适合自己的项目，<a href="https://github.com/geekcomputers/Python" target="_blank" rel="noopener">geekcomputers/Python: My Python Examples</a> 有一些非常非常简单的脚本可以拿来搞一搞。也可以自己搜索一些资源，但需要注意的是，尽量选择英文的资源，一方面是搞这个看英文资料是常态；另一方面是中文的不靠谱比例很高。不管咋样，还是建议同学能克服下，尽量按咱们之前提到的的方法找。</p><h2 id="怎么读"><a href="#怎么读" class="headerlink" title="怎么读"></a>怎么读</h2><p>当我们选择到合适的项目后就要开始阅读学习了。在正式开始之前，我们需要简单理一下流程和注意事项，无论你是系统读还是带着问题读，一般都可以归纳为以下几个步骤：</p><ul><li>通过文档了解项目实现的功能。一般项目都有 README 或文档，其中一般都会包括项目的主要功能和具体使用案例。</li><li>如果是你怎么做。在第一步及具体的阅读过程中，时刻反问自己：“如果我来实现会怎么做”？尝试去理解作者的思维方式。</li><li>从程序主入口到核心代码。从入口文件快速定位到要读的核心代码，在需要确定某个问题时一般都会这样做。当然，正常阅读时也建议直接找到主程序，然后按模块阅读。不要挨个文件或文件夹看，或者随机乱看。</li><li>忽略掉不必要的细节，关注输入输出。有时候我们可能需要快速了解某个功能，或者解决某个问题，这时候就需要过滤掉无关细节，重点阅读相关代码。对于我们新人来说，肯定还会经常遇到一些自己不懂的，这时候有两种解决策略：如果已经知道某个函数的功能和输入输出，细节不懂的可以先跳过；或者就不懂的地方开始查资料，然后尽量掌握它。</li><li>记录总结。这应该是最重要的，我们可以记录项目的相关情况，比如架构图、功能啊之类的，可以记录自己新掌握的知识，也可以记录学习的心得体会。总之，记录下来好处多多，比如便于我们日后随时复习翻阅（一般情况下，学一遍几乎肯定会忘的），节省时间；便于我们形成自己的知识图谱和体系，而且也是自己进一步学习的素材。</li></ul><h2 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h2><p>接下来，我们就找一个案例来实践一下，我从 500lines 里面找了一个数据存储相关的：<a href="https://github.com/aosabook/500lines/tree/master/data-store/code" target="_blank" rel="noopener">500lines/data-store/code at master · aosabook/500lines</a>，作者的描述是：</p><blockquote><p>A key/value store that you’d use like BDB or SQLite. It’s built like a couch, but not as nice.</p></blockquote><p>之所以用这个，一方面是因为它涉及了不少 Python 相关的基本操作；另一方面是它还涉及到一个二叉树的数据结构；还有就是它涉及到不少关于类的复杂操作。我们可以在阅读的过程中学习如何跳过这些复杂的模块。</p><p>在正式按步骤开始阅读之前，我们得首先把它安装在本地，让它能够正常运行。需要说明的是，我们在本地测试（或者创建）某个项目时，一般都会单独给该项目配置一个环境，可以用 <a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">virtualenv</a>，<a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">pyenv</a> 或者 <a href="https://github.com/pypa/pipenv" target="_blank" rel="noopener">pipenv</a>，无论哪个工具最后都是隔离出一个相对独立的环境。咱们这里就不做这个了，直接将项目安装到系统环境下，这样也方便在 Jupyter Notebook 中进行交互操作（否则还需要给虚拟环境安装 Jupyter Notebook）。</p><ul><li>进入 <code>500lines/data-store/code</code> 目录，执行：<code>pip install -r requirements.txt</code> 安装项目依赖，然后执行：<code>nosetests -v</code> 保证测试全部通过。</li><li>在该目录下创建一个 notebook，打开后应该可以执行：<code>import dbdb</code>；把 <code>tool.py</code> 也移动到这个目录，就可以通过 <code>python tool.py args</code> 这样使用了。</li></ul><p>接下来我们就可以随意玩转儿项目了。</p><p><strong>通过文档了解项目的功能</strong></p><p>文档里只提到这是一个基于树的 key-value 简易数据库，数据更新从叶子结点开始，共享共同的结点。并没有使用例子，不过这个也没关系，我们可以通过 <code>tool.py</code> 或者 tests 来了解如何使用。而且 500lines 的项目都提供了作者写的相应的文章（就在第一部分很多地方推荐过的那本书里），比如这个项目：<a href="http://www.aosabook.org/en/500L/dbdb-dog-bed-database.html" target="_blank" rel="noopener">500 Lines or Less | DBDB: Dog Bed Database</a>，我们也可以先读一遍这篇文章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BASIC USAGE</span></span><br><span class="line"><span class="keyword">import</span> dbdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并连接一个 db 实例</span></span><br><span class="line">dbname = <span class="string">"play1.db"</span></span><br><span class="line">db = dbdb.connect(dbname)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个 key value 存储</span></span><br><span class="line">key = <span class="string">"name"</span></span><br><span class="line">db[key] = <span class="string">"Your Name"</span></span><br><span class="line">db.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取存储的 key value</span></span><br><span class="line">db[<span class="string">"name"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除存储的 key value</span></span><br><span class="line"><span class="keyword">del</span> db[key]</span><br><span class="line">db.commit()</span><br></pre></td></tr></table></figure><p><strong>如果是你怎么做</strong></p><p>这个问题在开始的时候可能连自己都会觉得幼稚，不过没关系，哪个大神不是从幼稚开始的呢？我们保持这个思考问题的习惯就好。你一开始可能想用一个字典存，或者把 key value 写在一个 json 文件里，这都是可以的。毕竟如果从单用户开机状态来说，基本功能确实也能满足。</p><p>现在我们考虑这么几个问题：如果多个用户同时更改 db 怎么办，甚至他们在修改同一个 key？如果某个用户在读一个 key，另一个用户同时在更改怎么办？很多个 value 都有重复的字段，只有少量字段不同，能不能共享这些相同的字段以节省空间？存储的过程中突然中断（系统故障、断电、手贱取消等）怎么办，怎么处理已经存进去的，如果很多个用户同时这么做呢？</p><p>这些其实都是一个 db 非常有可能面临的问题，其实真实的场景可能面临的问题更多。我们可以在这里停下来好好想一想，其实与其说这些是代码问题，还不如说是设计问题，即使你完全没有代码经验也完全可以思考这些问题。比如对多个用户同时更改 db，我们是不是可以设计一个机制，让一次只能有一个用户更改 db。但你马上一想就会觉得这肯定不现实，如果有个用户一直在更改，那其他用户难道就一直要等他一个人吗？于是我们可能又会想，那就把这个限制放在更新同一个 key 时，也就是说如果多个人要更新同一个 key，就让他们排队。暂时看起来貌似还能 work，我们可以继续思考其他问题，当把自己能想到的所有问题都想清楚后，就可以去看作者是怎么考虑这些问题并实现它们了。</p><p><strong>从程序主入口到核心代码</strong></p><p>主入口文件是 <code>interface.py</code>，非常直观，不过我们可以从 <code>tool.py</code> 看起，这个是命令行工具，展示了如何使用的一个实例。我估计不少人看到这个文件时就懵逼了，好像突然进入了另一个世界，明明还是 Python 代码，咋和之前几节的感觉完全不一样呢。其实这中间最大的区别是：之前的是能执行一定功能的代码片段，现在的是真正的工程项目。</p><p>那咋办呢？看看标题，咱们直接到核心的，其他的忽略。这个思路我一般叫它 “抽象”，简单来说就是不同情况下我们需要不同层次的抽象。比如你可以弄清楚每一行代码，甚至它底层的原理，但你也可以只关注主要功能。这个文件主要做了两件事：</p><ul><li>从命令行并识别读取参数</li><li>根据参数执行相应结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbname, verb, key, value = (argv[<span class="number">1</span>:] + [<span class="keyword">None</span>])[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>分别对应传入的四个参数，最后一个 value 可能是 None （get 和 delete 时就没有），你可以在 main 函数下面加一行：<code>pring(argv)</code> 然后在命令行执行 <code>python tool.py arg1 arg2</code> 试试，屏幕上会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'tool.py'</span>, <span class="string">'arg1'</span>, <span class="string">'arg2'</span>]</span><br><span class="line">Usage:</span><br><span class="line">python -m dbdb.tool DBNAME get KEY</span><br><span class="line">python -m dbdb.tool DBNAME <span class="built_in">set</span> KEY VALUE</span><br><span class="line">python -m dbdb.tool DBNAME delete KEY</span><br></pre></td></tr></table></figure><p>也可以在 Jupyter Notebook 中执行：<code>!python tool.py arg1 arg2</code>。如果你发现改了文件的某个地方结果没有变化，有时候需要 Restart 一下你的 Notebook，重新 <code>import dbdb</code>。</p><p>下面的就很容易理解了：创建一个 db 实例 <code>db = dbdb.connect(dbname)</code>，然后像字典一样 get set 和 delete。</p><p>接下来看一下 <code>__init__.py</code>，<code>tool.py</code> 中 import 实际就是这个文件，这个文件的 <code>connect</code> 函数其实就是创建了一个 <code>interface.py</code> 里面的 DBDB 实例，它接受一个 open 的 file 作为参数。</p><p>然后我们就到了 <code>interface.py</code> 这个文件了，这里就实现了所有的功能（接口）。<code>BinaryTree</code> 和 <code>Storage</code> 是两个独立的实现，我们可以暂时不关注它们的细节（这次阅读不关注都可以），这里有几个新东西是我们之前没见过的：</p><ul><li>前面有一个下划线的是保护成员，只有类实例和子类实例能够访问</li><li>前面有两个下划线的是私有成员，只有类对象自己能访问</li><li><code>getitem</code> 等方法</li></ul><p>需要注意的是，Python 中的私有或保护都是伪的，并不是真的不能访问到（实例+类名+方法可以访问）。我们了解下就好，感兴趣的可以在 Notebook 中自己尝试一下。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"public"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_protected</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"protected"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"private"</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.public())      <span class="comment"># =&gt; public</span></span><br><span class="line">print(a._protected())  <span class="comment"># =&gt; protected</span></span><br><span class="line">print(a._A__private()) <span class="comment"># =&gt; private</span></span><br><span class="line">print(a.__private())   <span class="comment"># =&gt; AttributeError: 'A' object has no attribute '__private'</span></span><br></pre></td></tr></table></figure><p>关于 <code>getitem, setitem, delitem, contains, len</code> 几个方法，可以阅读 <a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types" target="_blank" rel="noopener">3. Data model — Python 3.7.5rc1 documentation</a> 或者这个中文的：<a href="https://wiki.jikexueyuan.com/project/explore-python/Class/magic_method.html" target="_blank" rel="noopener">定制类和魔法方法 - Python 之旅 - 极客学院 Wiki</a>，它们的主要功能是让我们像可以操作字典那样操作对象。这在有些时候很有用（比如我们现在的这种场景）。这里我们就不继续深入了，大家根据个人情况斟酌。</p><p>你可能会觉得怎么到处都是不懂的，有这样的想法很正常，刚开始都一样，下次再碰到这个不就懂了么，多看几个项目，一些项目中常用的东西就都知道了。坚持住，看的慢没关系，让自己时刻在进步就好了。</p><p><strong>忽略掉不必要的细节，关注输入输出</strong></p><p>如果刚入门，或者时间紧张，或者不想看了等等，到上一步停下也没关系。而且我们有时候在快速了解某个功能或者解决某个问题时，往往在上一步完成后直接跳到相应的代码。当然啦，我们这里还是要继续的。</p><p>整体来看，<code>physical.py</code> 中的 <code>Storage</code> 实现的是物理层面的存储，然后 <code>binary_tree</code> 中的 <code>BinaryTree</code>，它通过继承 <code>logical.py</code> 中的 <code>LogicalBase</code>（关于存储逻辑的），实现了数据基于 BinaryTree 的存储。回看下刚刚的 <code>interface.py</code>，几个重要的功能都与 <code>BinaryTree</code> 有关，我们就重点介绍下 set 这个接口，其他的大家用类似的方法就可以了。</p><p>首先是保证数据库没有被关闭，因为它本质是一个文件（还记得 <code>__init__.py</code> 中的 <code>connect</code> 函数吧），所以这里的判断也很简单，直接调用 <code>Storage</code> 的 <code>closed</code> 方法，该方法是个 property，这是将方法的返回值作为对象的一个属性，不需要加括号调用，方法名就是属性名。</p><p>然后就是 <code>BinaryTree</code> 的 <code>_set</code> 方法，我们并没有在类下看到这个方法，所以其实是来自父类，也就是 <code>LogicalBase</code> 的方法。</p><ul><li>判断文件是否锁定，调用了 <code>Storage</code> 的 <code>lock</code> 方法，因为这里 <code>Storage</code> 实例是作为一个参数传递给了 <code>BinaryTree</code> 类，这个方法很简单，使用了 <a href="https://pypi.org/project/portalocker/" target="_blank" rel="noopener">portalocker · PyPI</a> ，其实只通过代码我们也能看出来它们的功能，同时将 <code>Storage</code> 实例的 <code>locked</code> 属性设为 <code>True</code>。</li><li>如果 <code>lock</code> 方法返回 <code>True</code>，执行 <code>_refresh_tree_ref</code> 方法；<code>lock</code> 方法只有在文件没有锁定时会返回 <code>True</code>，如果文件已经锁定就返回 <code>False</code>，此时也意味着不需要执行 <code>_refresh_tree_ref</code> 方法。</li><li><code>_refresh_tree_ref</code> 方法用来获取最新根结点的引用，因为是 <code>locked</code> 状态，所以其他进程可能已经做了一些更新；否则说明此时的结点本来就是最新的。我们需要注意的是，这个方法返回的其实是继承自 <code>ValueRef</code> 的 <code>BinaryNodeRef</code> 实例。</li><li>接下来调用 <code>BinaryTree</code> 的 <code>_insert</code> 方法，传递了三个参数：第一个是调用了 <code>BinaryNodeRef</code> 继承自 <code>ValueRef</code> 的 <code>get</code> 方法返回的 <code>_referent</code>，其实是一个 <code>BinaryNode</code>。有个地方需要特别注意，<code>ValueRef</code> 和 <code>BinaryNodeRef</code> 都有一个 <code>string_to_referent</code> 方法，这里调用的是子类也就是后者的。第二个是 key，第三个是 <code>ValueRef</code> 实例。最终返回一个新的树（一个新的 <code>BinaryNodeRef</code> 实例），它共享了没有变化的子树，这时候数据并没有真正写入硬盘。</li></ul><p>上面的 set 之后还需要执行 <code>commit</code> 命令才能将数据真正写入硬盘。我们已经明显忽略了非常多的细节，仅仅只是大致知道了这个接口内部是怎么运作的，距离完全理解还远远不够。当然，这个项目其实有点复杂的，我们可以逐步阅读学习。即便如此，我们现在已经可以在其上做一些简单的修改了，比如针对其接口做一些调整。</p><p>由于篇幅有限，无法对项目进一步详细介绍，就简单说下作者的设计理念和逻辑：</p><ul><li>借鉴了 <a href="https://www.erlang.org/" target="_blank" rel="noopener">Erlang</a> 的数据不可变性，也就是说数据从开始到结束是不可更改的，不需要担心数据在执行过程中发生变化。在本项目中，整个 <code>BinaryTree</code> 的数据改变只有在 root 被替换时才可见，所以我们不用担心查找时数据会发生变化。之前在《基础知识》中提过的 Elixir 就是基于 Erlang 的编程语言。</li><li>逻辑与存储分离，逻辑的树只有 referent 和 address，referent 通过 <code>referent_to_string</code> 和 <code>string_to_referent</code> 方法存储和读取真正的 Node 结点。这样就不需要把整个树的所有结点读入内存，每次通过结点的 address 调用 get（调用了 <code>string_to_referent</code>） 或 store（调用了 <code>referent_to_string</code>） 方法就可以沿着树操作真正的结点。</li></ul><p><strong>记录总结</strong></p><p>无论代码看了多少，只要有新的收获，这部分就必不可少。虽然我们迄今为止连最核心的逻辑（其实这是本项目的核心）都没看，但依然有不少可以记录下来的，比如：</p><ul><li>参数</li><li><code>__init__.py</code></li><li>保护成员、私有成员</li><li>类和实例</li><li>魔法方法</li><li>property</li><li>继承</li><li>文件读写</li></ul><p>每一个地方都可以至少写出一篇笔记来，如果日后遇到相关的部分，不仅可以阅读自己的笔记温习，还可以在此基础上进一步扩充完善。而且在具体应用（写代码）时，也肯定需要不时查阅笔记回顾相关知识点的。除此之外，还可以记录作者解决问题的思路、某个算法的执行过程等等，这些都是宝贵的经验。</p><p>至此，我们一个项目的阅读就这么简单地告一段落了，虽然没能一一展示，但基本方法就是这样，我们需要做的就是不断执行。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>由于这个例子正好是数据库相关的，所以这里给大家补充一点数据库的基础但非常重要的设计思想。可以跳过。</p><p>数据库在互联网领域的重要性往往不被人重视，但其实所有的电子交易都离不开数据库提供的高效和可靠的存储服务。想象一个转账的例子，你的账号划出去 100 块，中间突然断网了，那这个交易怎么办？</p><p>数据库有很多张表，每张表的每一行都是一个单个事件的不同类别的信息，每一列就是这些不同的类别，俗称字段。数据库中有个非常重要的概念叫 “一致性”，就是其中的信息不能自相矛盾。比如考虑这样一个表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| name | age | married_with |</span><br><span class="line">| John | 28  | Mary |</span><br><span class="line">| Mary | 27  | John |</span><br></pre></td></tr></table></figure><p>John 与 Mary 是一对夫妻，现在假设更改 John 这条记录的 <code>married_with</code> 为 <code>Kate</code>，这就是一个不一致的例子，我们必须添加一条规则：“如果 A 和 B 结婚，那么 B 必须也和 A 结婚”，如果违反规则的更改就会提示失败。看起来好像比较容易解决。那我们再考虑另外一个表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| name | balance |</span><br><span class="line">| John | 800 |</span><br><span class="line">| Mary | 300 |</span><br><span class="line">| Kate | 150 |</span><br></pre></td></tr></table></figure><p>比如 John 给 Mary 转账 200，但中间突然由于某些原因意外崩溃了，John 的账户少了 200，但这 200 却没有能出现在 Mary 的账户上：数据库崩溃前后状态不一致，少了 200。这样的不一致没办法用结婚那样的规则去限制（余额必须是多少，余额之间的关系必须怎么样）。那怎么办呢？这时候我们就引出了可能是数据库最重要的一个概念：“事务”——如果要让数据库最后保持一致性，就必须在数据库上完成一系列更改，如果只执行了一部分更改，那所作的所有更改都会被撤消。</p><p>数据库的事务要使用一种特殊的待办事项列表（预写日志记录）来完成，它的基本思想是维护一个数据库计划采取的动作日志（被存储在硬盘或永久性存储介质中，保证信息免于崩溃），如果事务成功完成则删除日志中的待办列表，否则重新执行日志中的完整事务。日志中的每项活动都必须幂等（也就是无论执行多少次都一样）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 预写日志</span><br><span class="line">1. 开始转账事务</span><br><span class="line">2. 将 John 的余额从 800 变为 600 # 幂等的</span><br><span class="line">3. 将 Mary 的余额从 300 变为 500 # 幂等的</span><br><span class="line">4. 终止转账事务</span><br></pre></td></tr></table></figure><p>如果变更完成了，日志项就被删除，这是正常情况；如果中间崩溃了，重启后就能发现上面的日志记录，再重新执行一次完整的日志活动即可。这个也叫事务的原子性：不能分成更小的操作，要么正笔事务成功地完成，要么数据处于原始状态，就像从未开始一般。这样我们就保证了这种情况的一致性。</p><p>事务可能由于一些原因不能完成，比如磁盘空间用完了，或者另一个更常见的原因：“锁定”。我们在上一部分自己思考时已经考虑过一点这个了：冻结要更改的项目。乍一看似乎还不错，但这实际上却可能导致 “死锁”：当两次事务同时尝试锁定同一行但方向相反时就会出现死锁。比如事务 A 和 B 分别表示 John 向 Marry 转账和 Marry 向 John 转账，事务 A 锁住了 John 行，B 锁住了 Marry 行。然后执行转账开始时，A 发现需要锁住 Marry 行，B 发现需要锁住 John 行。A 只能等 B 结束时才能锁定，B 只有在 A 结束时才能锁定，A 和 B 就互为死锁，两个事务谁也不能完成。当出现这种情况时，必须让死锁的其中一项事务取消，以便让另一项事务先执行。此时，就需要具备撤销或回滚的能力。总之，只要事务没能正常完成就需要回滚。回滚一项事务可以通过预写日志记录逆向操作来完成。</p><p>数据库复制（备份）是抵御数据丢失的最好方法，但也有危险：它引入了另一种可能的不一致性——复制品彼此数据不一致。这时候我们就不知道哪个才是正确的备份了，所以其中的一些复制品可能需要回滚。一般来说，其中一个复制品是协同事务的 “主管”，比如有 A  B C 三个复制品，A 是 master。假设需要执行一项向表中插入一行新数据的事务。第一阶段，A 先锁定表，接着将新数据写入预写日志，同时 A 将新数据发给 B 和 C，B 和 C 也会锁定各自的表复制，并在日志中写入新数据。然后 B 和 C 向 A 返回报告它们是否成功地做了这一事务。第二阶段，如果 A B C 中任一项事务遇到了问题，A 就知道事务必须回滚，并通知所有复制品。如果所有复制品在第一阶段报告成功，A 就会向每份复制品发送消息确认事务，复制品接下来就会完成事务。这种办法叫 “两阶段提交协议”：第一阶段是 “预备” 阶段；第二阶段是 “提交” 阶段或 “撤销” 阶段，取决于最初的提议是否被所有人接受。</p><p>以上就是围绕数据库一致性的一些设计思想简介，虽然看起来有一点点复杂，但我们可以感觉到复杂的背后是因为业务本身的复杂，通过计算机科学家的设计反而让这种复杂看起来简单清晰了很多。</p><blockquote><p>本节内容参考自《改变未来的九大算法》。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节主要介绍了如何阅读优秀的源代码，当有了一些系统知识、能做一些基本的操作时，就可以开始通过阅读优秀的代码来进行学习了，然后在写代码时运用已经学到的。这种成长速度远远超过其他方式，就我自己的经验来看，每阅读一份优秀的代码，都能明显的感觉到代码实力有所提升，可惜自己还是看的太少。阅读过一些优秀的代码后，我们再系统阅读一些书籍时就会非常有感觉了。</p><p>最后，在找案例的过程中还发现两个不太复杂、html 解析相关的例子，如下：</p><ul><li><a href="https://github.com/psf/requests-html" target="_blank" rel="noopener">psf/requests-html: Pythonic HTML Parsing for Humans™</a></li><li><a href="https://github.com/aosabook/500lines/tree/master/template-engine" target="_blank" rel="noopener">500lines/template-engine at master · aosabook/500lines</a></li></ul><p>第一个刚出来时就看过了，非常值得一看。当然，还有很多其他的可选，看大家自己兴趣爱好和方向了。通过这节课的内容大家应该能感受到一点点计算机世界的魅力了吧？希望大家乐在其中，不断精进。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学编程最重要的就是写代码、读代码。上节提到了要阅读大神的或优秀的代码，之前也一直在强调要动手实践，这节咱们关注下如何阅读源代码。好的源代码不仅能让我们学到关于编程的知识，而且还有如何思考问题、抽象业务、设计架构等等方面知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
      <category term="Database" scheme="https://www.yam.gift/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Python 小白快速从入门到放弃：使用模块</title>
    <link href="https://www.yam.gift/2019/10/03/Py4F/2019-10-03-Python-for-Freshman-Ch02/"/>
    <id>https://www.yam.gift/2019/10/03/Py4F/2019-10-03-Python-for-Freshman-Ch02/</id>
    <published>2019-10-03T15:00:00.000Z</published>
    <updated>2019-10-11T03:15:07.609Z</updated>
    
    <content type="html"><![CDATA[<p>上节介绍了函数，简单理解就是实现特定功能的一组代码，方便复用。本节介绍的模块其实就是把函数组合起来作为模块，让更加便利地完成任务。使用模块我们可以非常迅速地实现很多任务，而不用自己动手实现。Python 中的模块分为内置的（Python 安装后就有的）和社区模块（需要通过 <code>pip install xxx</code> 安装的）。</p><a id="more"></a><h2 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h2><p>Python 的内置模块都在这里：<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">Built-in Functions — Python 3.7.5rc1 documentation</a>，大致浏览一下即可，具体到某个任务需要用到的时候我们再去仔细阅读文档。我们举几个例子。</p><p><strong>例子一：</strong>对一个 list 排序，list 的元素我们简单起见假设都为整数。</p><p>如果不使用内置模块，或者我们不知道有内置模块已经实现了这个功能，那就需要自己写代码实现了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(lst) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    pivot = lst.pop() <span class="comment"># 弹出最后一个元素，lst 少了最后一个元素</span></span><br><span class="line">    small = []</span><br><span class="line">    big = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="keyword">if</span> i &lt; piovt:</span><br><span class="line">            small.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            big.append(i)</span><br><span class="line">    <span class="keyword">return</span> quick_sort(small) + [piovt] + quick_sort(big)</span><br></pre></td></tr></table></figure><p>这是快排的实现，很容易理解：如果只有一个元素或者为空时，就返回这个元素；否则我们随机选择（这里选了最后一个）一个元素作为 pivot，然后将 lst 分为两部分（比 pivot 小的，比 pivot 大的），然后重复执行同样的操作就可以排好了。当然，你可能想到用其他方法，比如每次选择最小（或最大）的放到新的 list，直到原来的 list 为空为止：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> lst != []:</span><br><span class="line">        mini = min(lst)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">            <span class="keyword">if</span> i == mini:</span><br><span class="line">                res.append(i)</span><br><span class="line">                lst.remove(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个就很好理解了：只要 lst 不为空，我们就首先找出那个最小的值，然后遍历 lst，把与最小值相等的元素先全部拿出来放到新的列表里，同时记得从原来的列表里删除这些元素。</p><p>用自己的方法实现当然没有任何问题，但如果有内置模块时，一般推荐使用，除了简单省事外，它们一般都比我们自己写的性能要好。就拿排序来说，很简单的一个调用就可以了，就跟调用自己写的函数一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(lst)</span><br></pre></td></tr></table></figure><p>而且，内置函数一般都会有很多其他功能，就拿 <code>sorted</code> 来说，它支持正序、反序，也支持以任意的指定标准来排，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 按先奇数后偶数排序</span></span><br><span class="line">sorted(lst, key=<span class="keyword">lambda</span> x: x%<span class="number">2</span> == <span class="number">0</span>) <span class="comment"># =&gt; [3, 5, 1, 7, 9, 2, 4, 8, 6]</span></span><br><span class="line"><span class="comment"># x%2 是取余数操作，余数为 0 是偶数，为 1 是奇数；</span></span><br><span class="line"><span class="comment"># 为 0 是偶数，== 0，就是 True，等于 1；反之等于 0；0 &lt; 1，所以奇数就在前面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按先奇数后偶数同时奇数和偶数内部从大到小排序</span></span><br><span class="line">new = sorted(lst, reverse=<span class="keyword">True</span>)</span><br><span class="line">sorted(new, key=<span class="keyword">lambda</span> x: x%<span class="number">2</span> == <span class="number">0</span>) <span class="comment"># =&gt; [9, 7, 5, 3, 1, 8, 6, 4, 2]</span></span><br></pre></td></tr></table></figure><p>如果列表的元素是稍微复杂的数据结构，那使用内置模块就更加便利了，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [&#123;<span class="string">"name"</span>: <span class="string">"张xx"</span>, <span class="string">"age"</span>: <span class="number">10</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"李x"</span>, <span class="string">"age"</span>: <span class="number">30</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"王xxx"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;]</span><br><span class="line"><span class="comment"># 按年龄排序</span></span><br><span class="line">sorted(lst, key=<span class="keyword">lambda</span> x: x[<span class="string">"age"</span>]) <span class="comment"># 结果就是张、王、李</span></span><br><span class="line"><span class="comment"># 按名字长度排序</span></span><br><span class="line">sorted(lst, key=<span class="keyword">lambda</span> x: len(x[<span class="string">"name"</span>])) <span class="comment"># 结果就是李、张、王</span></span><br></pre></td></tr></table></figure><p>Python 中还有一部分内置的模块叫标准库：<a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">The Python Standard Library — Python 3.7.5rc1 documentation</a>，这部分需要 import 进来使用，不需要安装。标准库也是非常有质量保证的，能用到的推荐使用。</p><p><strong>例子二：</strong>统计一段文本的词频。</p><p>我们首先自己实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"""</span></span><br><span class="line"><span class="string">The Zen of Python, by Tim Peters</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.</span></span><br><span class="line"><span class="string">Sparse is better than dense.</span></span><br><span class="line"><span class="string">Readability counts.</span></span><br><span class="line"><span class="string">Special cases aren't special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you're Dutch.</span></span><br><span class="line"><span class="string">Now is better than never.</span></span><br><span class="line"><span class="string">Although never is often better than *right* now.</span></span><br><span class="line"><span class="string">If the implementation is hard to explain, it's a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let's do more of those!</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words_freq</span><span class="params">(text)</span>:</span></span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    words_list = text.split() <span class="comment"># 使用 \n 或空格分隔</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> words_list:</span><br><span class="line">        <span class="keyword">if</span> w <span class="keyword">in</span> res:</span><br><span class="line">            res[w] = res[w] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[w] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>给出的文本是 The Zen of Python，只要在 Jupyter Notebook 中输入 <code>import this</code> 就可以看到了。这段代码非常简单：首先获取词列表，然后遍历，如果词没在字典里，就让它的值等于 1，否则就让它的值加 1。</p><p>我们使用内置的标准库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">words_list = text.split()</span><br><span class="line">words_freq = collections.Counter(words_list)</span><br></pre></td></tr></table></figure><p>结果是一样的，看起来好像没有啥特别方便的，但我们刚刚已经提到了，这些模块一般还有很多其他功能，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计出现频率最高的 k 个词</span></span><br><span class="line">words_freq.most_common(k)</span><br><span class="line"><span class="comment"># 统计出现频率最低的 k 个词</span></span><br><span class="line">words_freq.most_common()[-k:]</span><br></pre></td></tr></table></figure><p>无论是内置模块还是内置标准库，一般情况下直接拿来使用都是没有问题的，比较有质量保证。这相当于有人已经帮你把一部分功能实现好了，你只要直接调用他写好的函数就行了。需要说明的是，刚开始我们可能并不知道有哪些可以用到自己的任务中，遇到这种情况不要着急，上网搜搜和你类似的任务，看看别人是怎么实现的，别人用了你看到后自然就知道了。这样时间久了，自然就知道很多了，不需要专门刻意去学一遍这个。</p><h2 id="PyPI-包"><a href="#PyPI-包" class="headerlink" title="PyPI 包"></a>PyPI 包</h2><p>既然官方能够提供内置模块和标准库，那自然也会有其他各种各样的模块可以提供出来供大家使用。这就是 <a href="https://pypi.org/" target="_blank" rel="noopener">PyPI · The Python Package Index</a> 了，在这里可以找到大量的全球各地程序猿实现的各种功能模块。安装一般都很简单，使用 pip 命令：<code>pip install package_name</code> 即可安装到本地的 Python 环境中，使用方法一般都会有相应的介绍文档。</p><p>这里我们也举一个例子，使用一个叫 pnlp 的包，这个包是我当时写的一个非常简单的预处理工具。为什么会写这么个工具呢？理由很简单：因为这些功能在我平时工作中会大量用到，每次都要把代码复制过来，或者把包含该代码的文件 import 到需要的地方，感觉特别麻烦。那现在就很方便了，我只需要 <code>import pnlp</code> 就可以使用里面内置的那些我需要的功能了。在 PyPI 里面直接搜索 pnlp 或者直接访问：<a href="https://pypi.org/project/pnlp/" target="_blank" rel="noopener">pnlp · PyPI</a> 就可以看到相关的介绍，Homepage 一般都链接到 GitHub 源代码仓库。简单介绍下其中一个功能吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pnlp <span class="keyword">import</span> ptxt</span><br><span class="line"></span><br><span class="line">pt = ptxt.Text(text, <span class="string">"eng"</span>)</span><br><span class="line">pt.extract.mats <span class="comment"># 所有的英文单词 list，剔除了标点、特殊符号等</span></span><br><span class="line">pt.clean <span class="comment"># 所有的非英文</span></span><br></pre></td></tr></table></figure><p>这个包写的非常简单，仅有少量功能，而且后来发现用处貌似并没有我设想的那么大，主要因为不同任务的预处理一般都是不一样的，每次都需要针对性地做一些修改。不过既然已经发布了，也就那样了，如果以后有其他不错的补充时再 update 吧。</p><h2 id="你的模块"><a href="#你的模块" class="headerlink" title="你的模块"></a>你的模块</h2><p>刚刚提到我们可以把自己常用的或者实现了某个特定功能的模块传到 PyPI 方便自己日后使用，这里就来简单介绍下这个流程。官方这里也有个对应的文档：<a href="https://docs.python.org/3/distributing/index.html" target="_blank" rel="noopener">Distributing Python Modules — Python 3.7.5rc1 documentation</a> 可以参考。</p><ul><li><p>首先安装需要的工具：<code>pip install setuptools wheel twine</code></p></li><li><p>调整结构：一般是把你的所有源代码都放到一个目录下，然后和 LICENSE, README 一起放到项目的根目录下</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── your_pkg_name</span><br><span class="line">│   ├── __init__.py <span class="comment"># 添加 name = "your_pkg_name"</span></span><br><span class="line">│   ├── <span class="built_in">source</span>1.py</span><br><span class="line">│   ├── <span class="built_in">source</span>2.py</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── tests <span class="comment"># 测试</span></span><br></pre></td></tr></table></figure></li><li><p>添加 <code>setup.py</code>：关于包设置的脚本，是关于你模块的 meta 信息，字段可以看<a href="https://packaging.python.org/tutorials/packaging-projects/" target="_blank" rel="noopener">这里</a></p></li><li><p>创建 package：<code>python setup.py sdist bdist_wheel</code> 生成的 dist 文件夹就是你要上传到 PyPI 的文件</p></li><li><p>上传 package：<code>python3 -m twine upload --repository-url https://test.pypi.org/legacy/ dist/*</code></p><ul><li><p>这里用的 repository url 是一个测试地址，正式地址是：<code>https://upload.pypi.org/legacy/</code>，建议先使用测试地址测试无误后再替换为正式地址正式发布</p></li><li><p>这一步需要输入你在 PyPI 的用户名和密码，所以还需要先注册个账号</p></li><li><p>上传后可以在 <a href="https://test.pypi.org/project/your_pkg_name" target="_blank" rel="noopener">https://test.pypi.org/project/your_pkg_name</a> 访问到你的包</p></li></ul></li><li><p>安装 package：</p><ul><li>测试的通过 <code>pip install --index-url https://test.pypi.org/simple/ --no-deps your_pkg_name</code> 命令安装</li><li>正式的通过 <code>pip install your_pkg_name</code> 安装，建议指定国内源：<code>pip install -i https://pypi.douban.com/simple your_pkg_name</code></li></ul></li></ul><p>这样便成功创建了自己的包，为社区做出了一份贡献。需要说明的是，不太建议重复造轮子，如果网上能找到类似的功能，看了源代码觉得能满足自己需要的时候，直接拿来用即可；也不太建议造太专用的轮子，就是那些只能实现特定任务的功能，这样的话其他人很难复用。如果你的模块确实解决了某一类问题，且网上还没找到很好的实现，这时候发布成模块是非常不错的选择。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节主要介绍了模块（包）的使用以及如何创建发布自己的模块。使用模块是很自然的一件事，因为我们的目标就是完成任务，既然已经有相应的模块实现了我们需要的功能，自然拿来直接用了。这在复杂任务和大型项目中就更加如此了。而且如果我们稍微留意点的的话，就会发现绝大多数包本身也依赖其他的包。你可以灵活使用内置模块、标准库和 PyPI 上的包，就像搭积木一样。借助这些各式各样的模块就可以更加高效地完成任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节介绍了函数，简单理解就是实现特定功能的一组代码，方便复用。本节介绍的模块其实就是把函数组合起来作为模块，让更加便利地完成任务。使用模块我们可以非常迅速地实现很多任务，而不用自己动手实现。Python 中的模块分为内置的（Python 安装后就有的）和社区模块（需要通过 &lt;code&gt;pip install xxx&lt;/code&gt; 安装的）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
      <category term="Module" scheme="https://www.yam.gift/tags/Module/"/>
    
      <category term="PyPI" scheme="https://www.yam.gift/tags/PyPI/"/>
    
  </entry>
  
  <entry>
    <title>Python 小白快速从入门到放弃：基础知识</title>
    <link href="https://www.yam.gift/2019/10/02/Py4F/2019-10-02-Python-for-Freshman-Ch01/"/>
    <id>https://www.yam.gift/2019/10/02/Py4F/2019-10-02-Python-for-Freshman-Ch01/</id>
    <published>2019-10-02T15:00:00.000Z</published>
    <updated>2019-10-11T03:15:22.385Z</updated>
    
    <content type="html"><![CDATA[<p>当一句或一段代码运行时，Python 解释器将源代码转为字节码，然后进行词法、语法分析，检查是否有错，如果没有错误就编译并执行，然后将结果返回给。这个流程都由 Jupyter Notebook 自动完成。</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># 整数</span></span><br><span class="line">a = <span class="number">1.1</span> <span class="comment"># 小数 or 11/10</span></span><br><span class="line">a = <span class="string">"1.1"</span> <span class="comment"># 字符串</span></span><br><span class="line">a = <span class="keyword">True</span> <span class="comment"># 真假</span></span><br><span class="line">print(<span class="string">"hello"</span>, a) <span class="comment"># 打印</span></span><br><span class="line"></span><br><span class="line">a &gt; b <span class="comment"># &lt;, &gt;=, &lt;= 也可以</span></span><br><span class="line">a + b <span class="comment"># -, *, /, //（整除）, **（开方）</span></span><br><span class="line">a &gt; b <span class="keyword">and</span> a &lt; c <span class="comment"># or</span></span><br></pre></td></tr></table></figure><p>可以看到非常直观。在 Python 中，只有一行 <code>print(&quot;something.&quot;)</code> 也可以看作是一个简单的程序。理论上你的任务都可以由这样一行一行的代码一步步执行下来的，实际上如果是简单任务你也可以这样做。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [] <span class="comment"># list</span></span><br><span class="line">a = set() <span class="comment"># set</span></span><br><span class="line">a = () <span class="comment"># tuple</span></span><br><span class="line">a = &#123;&#125; <span class="comment"># dict</span></span><br></pre></td></tr></table></figure><ul><li>list 里面可以放任意的变量，可以重复：<code>a = [&#39;1&#39;, 1, x, 1]</code></li><li>set 里面的元素会自动去重：<code>a = set(&#39;1&#39;, 1, x, 1)</code> 实际上只有三个元素</li><li><p>tuple 就是把几个元素放一起</p></li><li><p>dict 是 key-value 对，value 可以为空：<code>a = {&#39;x&#39;:1, &#39;y&#39;:2}</code>，key 不重复（重复会被覆盖），<code>a[&#39;x&#39;] =1</code></p></li></ul><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><strong>循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For 循环</span></span><br><span class="line"><span class="comment"># 循环一遍 a 中的各个元素</span></span><br><span class="line">a = [<span class="string">'1'</span>, <span class="number">1</span>, a, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">    print(item) <span class="comment"># '1', a, a, 1</span></span><br><span class="line">a = &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> a.items():</span><br><span class="line">    print(key, value) <span class="comment"># x 1, y 2</span></span><br><span class="line"><span class="comment"># 从 0-100</span></span><br><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    x.append(i) <span class="comment"># 将元素挨个放到列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环</span></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> y &lt; <span class="number">10</span>:</span><br><span class="line">    y = y+<span class="number">1</span> <span class="comment"># y += 1</span></span><br></pre></td></tr></table></figure><p><strong>条件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    <span class="comment"># 如果 i 除以 2 余数是 0，也就是偶数</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        x.append(i)</span><br><span class="line">    <span class="comment"># 另一个条件</span></span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print(i)</span><br><span class="line">    <span class="comment"># else 这两行可以不写</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># continue 意思是继续下一个 i</span></span><br><span class="line">        <span class="comment"># 如果换成 break，就表示跳出循环，程序执行结束</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> y &lt; <span class="number">10</span>:</span><br><span class="line">    y += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 此时 y 就是 5</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>简单理解，函数就是实现特定（一般是一个）功能的一组代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个求和的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line">my_sum(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 执行这个函数，传入 1 和 2，返回 1+2，也就是 3</span></span><br></pre></td></tr></table></figure><p>前面说一行一行代码语句按步骤执行下来也可以完成任务，但那样就非常不方便，很难复用而且别人看也很不清晰，有了函数就好很多。比如上面的例子，我们可以定义一个加法函数，这样在任何时候直接调用函数就可以了。当我们的任务变得复杂时，这样做的好处就更加明显。</p><p>如果涉及到更复杂的任务，比如我们设计一个用户点菜的场景（其实依然非常简单）：某用户打开菜单挑选菜品，如果是 VIP 价格显示 8 折；如果菜没了显示售罄，然后提交保存。最 Naive 的实现方式就是完全按业务流程一步步实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">IDENTITY = &#123;</span><br><span class="line">    <span class="string">"用户1"</span>: <span class="string">"VIP"</span>,</span><br><span class="line">    <span class="string">"用户2"</span>: <span class="string">"VIP"</span>,</span><br><span class="line">    <span class="string">"用户3"</span>: <span class="string">"VIP"</span>,</span><br><span class="line">    <span class="string">"我"</span>: <span class="string">"NORMAL"</span></span><br><span class="line">&#125;</span><br><span class="line">MENU = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"回锅肉"</span>, <span class="string">"price"</span>: <span class="number">32</span>, <span class="string">"sold_out"</span>: <span class="keyword">False</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"红烧肉"</span>, <span class="string">"price"</span>: <span class="number">35</span>, <span class="string">"sold_out"</span>: <span class="keyword">True</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"土豆丝"</span>, <span class="string">"price"</span>: <span class="number">10</span>, <span class="string">"sold_out"</span>: <span class="keyword">False</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"水煮肉片"</span>, <span class="string">"price"</span>: <span class="number">30</span>, <span class="string">"sold_out"</span>: <span class="keyword">False</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"鱼香肉丝"</span>, <span class="string">"price"</span>: <span class="number">20</span>, <span class="string">"sold_out"</span>: <span class="keyword">False</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(user)</span>:</span></span><br><span class="line">    <span class="comment"># 获取用户身份，如果是新用户默认 NORMAL</span></span><br><span class="line">    identity = IDENTITY.get(user, <span class="string">"NORMAL"</span>)</span><br><span class="line">    <span class="keyword">if</span> identity == <span class="string">"VIP"</span>:</span><br><span class="line">        <span class="keyword">for</span> food <span class="keyword">in</span> MENU:</span><br><span class="line">            price = food[<span class="string">'price'</span>] * <span class="number">0.8</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> food[<span class="string">'sold_out'</span>]:</span><br><span class="line">                flag = <span class="string">'购买'</span> <span class="comment"># 空</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="string">'售罄'</span></span><br><span class="line">            print(food[<span class="string">'name'</span>], price, flag)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> food <span class="keyword">in</span> MENU:</span><br><span class="line">            price = food[<span class="string">'price'</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> food[<span class="string">'sold_out'</span>]:</span><br><span class="line">                flag = <span class="string">'购买'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="string">'售罄'</span></span><br><span class="line">            print(food[<span class="string">'name'</span>], price, flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按正常的价格打印            </span></span><br><span class="line">order(<span class="string">"我"</span>)</span><br><span class="line"><span class="comment"># 按 vip 的价格打印</span></span><br><span class="line">order(<span class="string">"用户1"</span>)</span><br></pre></td></tr></table></figure><p>这样的程序可以执行，但很不灵活，比如增加了一个 VVIP 打 7 折，就需要修改方法；而且打折的比例也是写死在函数里面，很不方便更改，比如今天一个 69 折，明天一个 79 折，这就很麻烦。一般在面对需要判断，有重复代码时，可以考虑下是不是可以抽象。比如我们可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(user, discount=<span class="number">1.0</span>)</span>:</span></span><br><span class="line">    identity = IDENTITY.get(user, <span class="string">"NORMAL"</span>)</span><br><span class="line">    <span class="keyword">if</span> identity == <span class="string">"VIP"</span>:</span><br><span class="line">        print_order(discount)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print_order(discount)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_order</span><span class="params">(discount)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> food <span class="keyword">in</span> MENU:</span><br><span class="line">        price = food[<span class="string">'price'</span>] * discount</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> food[<span class="string">'sold_out'</span>]:</span><br><span class="line">            flag = <span class="string">'购买'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="string">'售罄'</span></span><br><span class="line">        print(food[<span class="string">'name'</span>], price, flag)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 按正常的价格打印</span></span><br><span class="line">order(<span class="string">"我"</span>)</span><br><span class="line"><span class="comment"># VIP 八折</span></span><br><span class="line">order(<span class="string">"用户1"</span>, <span class="number">0.8</span>)</span><br></pre></td></tr></table></figure><p>这就是函数的最基本功能了，作为新手，我们不需要考虑太多设计模式相关的内容，只需要根据自己的直觉，将一些公共代码抽象出来即可。不过有两点需要强调：</p><ul><li>函数尽量小一点，只做一件事</li><li>从业务角度思考代码实现</li></ul><p>上面的实现虽然做了一些抽象，但从业务角度看其实还有问题，比如我事先并不知道某个用户是什么身份，那我怎么知道 discount 的比例；还有，如果多了个 VVIP，或者其他什么特殊的身份，又要修改代码，添加对应的身份判断。接下来，我们就从这些角度看看怎么优化。</p><p>根据身份判断 discount 的问题，我们可以通过维护一个 <code>{身份: discount}</code> 的字典就可以很好地完成了，此时我们判断的条件就不是用户的身份，而是不需要判断，直接拿到了 discount；如果多了个特殊身份，也只需要维护下这个字典即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">IDENTITY_DISCOUNT = &#123;</span><br><span class="line">    <span class="string">"VIP"</span>: <span class="number">0.8</span>,</span><br><span class="line">    <span class="string">"VVIP"</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">"NORMAL"</span>: <span class="number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(user)</span>:</span></span><br><span class="line">    identity = IDENTITY.get(user, <span class="string">"NORMAL"</span>)</span><br><span class="line">    discount = IDENTITY_DISCOUNT.get(identity)</span><br><span class="line">    print_order(discount)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_order</span><span class="params">(discount)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> food <span class="keyword">in</span> MENU:</span><br><span class="line">        price = food[<span class="string">'price'</span>] * discount</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> food[<span class="string">'sold_out'</span>]:</span><br><span class="line">            flag = <span class="string">'购买'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="string">'售罄'</span></span><br><span class="line">        print(food[<span class="string">'name'</span>], price, flag)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 按正常的价格打印</span></span><br><span class="line">order(<span class="string">"我"</span>)</span><br><span class="line"><span class="comment"># VIP 八折</span></span><br><span class="line">order(<span class="string">"用户1"</span>)</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>对于绝大多数任务，用函数就足够了（可以创建任意个数量的函数），准确来说，只用函数完全可以实现所有的功能，但有时候为了更好地代码维护和可扩展性，我们会使用类。提到类就不得不提面向对象编程了，它的基本思想是将业务抽象成一个一个对象，每个对象有属性和方法，属性一般是静态的，方法则是可执行的动作。对象是相比函数包含更加丰富的抽象。我们还用上面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="comment"># 静态属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.identity = IDENTITY.get(name, <span class="string">"NORMAL"</span>)</span><br><span class="line">    <span class="comment"># 方法 =&gt; 用户可以下订单</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(self)</span>:</span></span><br><span class="line">        discount = IDENTITY_DISCOUNT.get(self.identity)</span><br><span class="line">        print_order(discount)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_order</span><span class="params">(discount)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> food <span class="keyword">in</span> MENU:</span><br><span class="line">        price = food[<span class="string">'price'</span>] * discount</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> food[<span class="string">'sold_out'</span>]:</span><br><span class="line">            flag = <span class="string">'购买'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="string">'售罄'</span></span><br><span class="line">        print(food[<span class="string">'name'</span>], price, flag)</span><br><span class="line">        </span><br><span class="line">User(<span class="string">"我"</span>).order()</span><br><span class="line">User(<span class="string">"用户1"</span>).order()</span><br></pre></td></tr></table></figure><p><code>self</code> 是类的一个实例，每当我们执行 <code>me = User(&quot;我&quot;)</code> 时，就相当于创建了一个类的实例 <code>me</code>，就是这个类的一个具体的例子。<code>me</code> 有两个属性：<code>name, identity</code> 和一个方法 <code>order()</code>。</p><p>除了面向对象的编程外，还有一种非常流行的方式：函数式编程。它提供了另外一种解决问题的思路，我们简单地了解下。在这个世界里，没有类，函数是第一等公民。它们大量采用模式匹配、管道和递归，数据在整个过程中保持不可变性（只能创建新的值）。Python 也支持一些函数式操作，接下来我们就看看用这种方式怎么处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(user)</span>:</span></span><br><span class="line">    identity = IDENTITY.get(user, <span class="string">"NORMAL"</span>)</span><br><span class="line">    discount = IDENTITY_DISCOUNT.get(identity)</span><br><span class="line">    print_order(discount)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_order</span><span class="params">(discount)</span>:</span></span><br><span class="line">    print(list(map(<span class="keyword">lambda</span> food: (food[<span class="string">'name'</span>], food[<span class="string">'price'</span>] * discount, </span><br><span class="line">                                 <span class="string">"购买"</span> <span class="keyword">if</span> <span class="keyword">not</span> food[<span class="string">'sold_out'</span>] <span class="keyword">else</span> <span class="string">"售罄"</span>), MENU)))</span><br><span class="line"></span><br><span class="line">order(<span class="string">"我"</span>)</span><br><span class="line">order(<span class="string">"用户1"</span>)</span><br></pre></td></tr></table></figure><p>Python 支持的函数式方法比较少，如果使用通道结果看起来会更加直观，比如我们用 <code>elixir</code> 实现：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">UserOrder</span></span> <span class="keyword">do</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">order</span></span>(user) <span class="keyword">do</span></span><br><span class="line">    identity = %&#123;<span class="string">"用户1"</span>=&gt; <span class="string">"VIP"</span>, <span class="string">"用户2"</span>=&gt; <span class="string">"VIP"</span>, <span class="string">"用户3"</span>=&gt; <span class="string">"VIP"</span>, <span class="string">"我"</span>=&gt; <span class="string">"NORMAL"</span>&#125;</span><br><span class="line">    </span><br><span class="line">    identity_discount = %&#123;<span class="string">"VIP"</span> =&gt; <span class="number">0</span>.<span class="number">8</span>, <span class="string">"VVIP"</span> =&gt; <span class="number">0</span>.<span class="number">7</span>, <span class="string">"NORMAL"</span> =&gt; <span class="number">1.0</span>&#125;</span><br><span class="line"></span><br><span class="line">    menu = [</span><br><span class="line">      %&#123;<span class="symbol">:name</span> =&gt; <span class="string">"回锅肉"</span>, <span class="symbol">:price</span> =&gt; <span class="number">32</span>, <span class="symbol">:sold_out</span> =&gt; <span class="keyword">false</span>&#125;,</span><br><span class="line">      %&#123;<span class="symbol">:name=&gt;</span> <span class="string">"红烧肉"</span>, <span class="symbol">:price</span> =&gt; <span class="number">35</span>, <span class="symbol">:sold_out</span> =&gt; <span class="keyword">true</span>&#125;,</span><br><span class="line">      %&#123;<span class="symbol">:name=&gt;</span> <span class="string">"土豆丝"</span>, <span class="symbol">:price</span> =&gt; <span class="number">10</span>, <span class="symbol">:sold_out</span> =&gt; <span class="keyword">false</span>&#125;,</span><br><span class="line">      %&#123;<span class="symbol">:name=&gt;</span> <span class="string">"水煮肉片"</span>, <span class="symbol">:price</span> =&gt; <span class="number">30</span>, <span class="symbol">:sold_out</span> =&gt; <span class="keyword">false</span>&#125;,</span><br><span class="line">      %&#123;<span class="symbol">:name=&gt;</span> <span class="string">"鱼香肉丝"</span>, <span class="symbol">:price</span> =&gt; <span class="number">20</span>, <span class="symbol">:sold_out</span> =&gt; <span class="keyword">false</span>&#125;]</span><br><span class="line"></span><br><span class="line">    identity_discount</span><br><span class="line">    |&gt; Map.get(identity |&gt; Map.get(user, <span class="string">"NORMAL"</span>))</span><br><span class="line">    |&gt; print_order(menu)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_order</span></span>(discount, menu) <span class="keyword">do</span></span><br><span class="line">    menu</span><br><span class="line">    |&gt; Enum.reduce([], <span class="keyword">fn</span> food, res -&gt;</span><br><span class="line">      item = &#123;food.name, food.price * discount, get_flag(food.sold_out)&#125;</span><br><span class="line">      [item | res]</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    |&gt; IO.inspect()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># private function</span></span><br><span class="line">  <span class="function"><span class="keyword">defp</span> <span class="title">get_flag</span></span>(sold_out) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> sold_out <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">true</span> -&gt; <span class="string">"售罄"</span></span><br><span class="line">      <span class="keyword">false</span> -&gt; <span class="string">"购买"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">UserOrder.order(<span class="string">"我"</span>)</span><br><span class="line">UserOrder.order(<span class="string">"用户1"</span>)</span><br></pre></td></tr></table></figure><p>代码看起来非常清爽直观。值得说明的是，代码并非越短越好，清晰性和可读性要重要的多。上面的 Elixir 代码和 Python 的函数式方法不需要彻底搞懂，只要大概知道意思即可。最后这里简单对 Python 的几个函数式方法举几个例子介绍下，毕竟属于 Python 的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">tuplst = [(<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"c"</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">############ 列表推导式 #############</span></span><br><span class="line">[i*i <span class="keyword">for</span> i <span class="keyword">in</span> lst <span class="keyword">if</span> i &gt; <span class="number">1</span>] <span class="comment"># =&gt; [4,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############ lambda #############</span></span><br><span class="line">fun = <span class="keyword">lambda</span> x: str(x) </span><br><span class="line">fun(<span class="number">1</span>) <span class="comment"># =&gt; "1"</span></span><br><span class="line">sorted(tuplst, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># =&gt; [('a', 1), ('b', 2), ('c', 3)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############ map #############</span></span><br><span class="line">list(map(str, lst)) <span class="comment"># =&gt; ["1", "2", "3"]</span></span><br><span class="line">list(map(<span class="keyword">lambda</span> x: str(x), lst)) <span class="comment"># =&gt; ["1", "2", "3"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############ reduce #############</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">reduce((<span class="keyword">lambda</span> x, y: x * y), lst) <span class="comment"># =&gt; ((1*2)*3) = 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############ filter #############</span></span><br><span class="line">list(filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment"># =&gt; [2,3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># map 等价于下面的函数，其他的也类似。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(lst)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">        res.append(str(i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>同样的功能，不同人的观点不同，写出来的代码也不同；即使是同一个人，采用不同的思考方式写出来的代码也不一样。有的代码不仅冗长而且鲁棒性还差，很容易出错；而有的代码不仅简洁优雅鲁棒性好，而且还有很强的可扩展性。我想这可能就是编程的魅力所在吧。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>Python 可以以脚本的形式运行，简单来说就是创建好一个 <code>py</code> 程序，将代码写进去然后在命令行通过 <code>python file_name.py</code> 来执行。比如我们创建一个 <code>order.py</code> 的文件，然后把刚刚的任意一段 Python 代码粘贴进去，在该文件的当前目录执行 <code>python order.py</code> 即可打印出想要的结果。需要注意的是，Python 没有 main 函数，所以单个文件运行时，文件名（<code>__name__</code>）就是 main，具体使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    something</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_order</span><span class="params">(discount)</span>:</span></span><br><span class="line">    something</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    User(<span class="string">"我"</span>).order()</span><br><span class="line">    User(<span class="string">"用户1"</span>).order()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节主要介绍了 Python 的基本概念和基本使用，现在是自己动手的时候了。刚开始不需要追求一定要写得多好，先把你想要做的事情实现再说。只要长期坚持写，代码肯定会越写越好的；当有了一定基础后再去看各类书籍才会有茅塞顿开之感。记住，编程首先是个手艺活儿，然后才是个脑力活儿。Talk is cheap, show me the code. Just coding and have fun.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当一句或一段代码运行时，Python 解释器将源代码转为字节码，然后进行词法、语法分析，检查是否有错，如果没有错误就编译并执行，然后将结果返回给。这个流程都由 Jupyter Notebook 自动完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CTRL 论文 + 实践  + 源码</title>
    <link href="https://www.yam.gift/2019/09/28/Paper/2019-09-28-CTRL/"/>
    <id>https://www.yam.gift/2019/09/28/Paper/2019-09-28-CTRL/</id>
    <published>2019-09-28T12:00:00.000Z</published>
    <updated>2019-09-28T12:11:14.748Z</updated>
    
    <content type="html"><![CDATA[<p>paper: <a href="https://einstein.ai/presentations/ctrl.pdf" target="_blank" rel="noopener">ctrl.pdf</a></p><p>code: <a href="https://github.com/salesforce/ctrl" target="_blank" rel="noopener">salesforce/ctrl: Conditional Transformer Language Model for Controllable Generation</a></p><p>核心思想：借鉴多任务，将文本标签作为输入的一部分（放在开头）控制文本生成。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>文本生成最大的问题是难以对其进行控制，本文发布了一个 1.6 billion 参数的条件 transformer language model，训练能够 govern 风格、内容、特定任务行为等的控制代码。控制代码来自与原始文本共现的结构，保留了无监督学习的优点，同时提供对文本生成更明确的控制。这些控制代码还允许 CTRL 预测训练数据的哪些部分最有可能给出序列。</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在足够大的模型和足够多的数据下，生成模型能够学到足够强大的分布生成高质量的 sample。在图像领域，2014 年 Goodfellow 的 Gan 大放异彩。在自然语言领域，语言模型经常被训练成特定任务的条件模型；也被用来学习词向量、文档向量、上下文向量等进而在迁移学习中使用；语言模型本身也会迁移到新任务上精调。但生成并没有在这些任务中被限制，典型的文本生成过程也仅仅被粗糙地引导或者直接指定开头。这自然就有个问题：怎样才能对生成过程进行更明确的控制？</p><p>本文受图像生成和近期的文本生成及多任务学习启发，训练了一个多控制代码的条件模型。该模型能够给在控制代码（指定 <strong>domain, style, topics, dates, entities, relationships between entities, plot points, task-related behavior</strong>）条件下生成文本。控制代码来自与原始文本共现的结构，比如 Wiki、评论这种可以指定一个 domain-related 控制代码，小语料还会有一个 subdomain 的信息。文本能够通过控制内容或改变 domain 进而以更加可预测的方式生成。</p><p>因为所有控制代码都可以追溯到训练数据的特定子集，所以还可以用来预测最有可能给出序列的训练数据的子集。这些控制代码还允许直接包含特定任务的数据，进而在生成中使特定任务的行为控制代码能够与内容相关的控制代码结合。</p><h2 id="Language-Model"><a href="#Language-Model" class="headerlink" title="Language Model"></a>Language Model</h2><script type="math/tex; mode=display">p(x)=\prod_{i=1}^{n} p\left(x_{i} | x_{<i}\right)</script><script type="math/tex; mode=display">\mathcal{L}(D)=-\sum_{k=1}^{|D|} \log p_{\theta}\left(x_{i}^{k} | x_{<i}^{k}\right)</script><p>x 是一个序列，训练后的模型自然可以生成特定长度的序列。</p><h2 id="Language-Modeling-With-CTRL"><a href="#Language-Modeling-With-CTRL" class="headerlink" title="Language Modeling With CTRL"></a>Language Modeling With CTRL</h2><p>本文的模型在控制代码下学习分布。</p><script type="math/tex; mode=display">p(x | c)=\prod_{i=1}^{n} p\left(x_{i} | x_{<i}, c\right) \quad \mathcal{L}(D)=-\sum_{k=1}^{|D|} \log p_{\theta}\left(x_{i}^{k} | x_{<i}^{k}, c^{k}\right)</script><p>其实就是在预先考虑控制代码的基础上进行训练。</p><p>一个单独的序列包括 n 个 token（n 个 d 维向量），每个 token 的向量是 embedding 和 sinusoidal positional embedding 二者之和。序列的向量矩阵为 n×d，可以进一步连 attention。</p><p>每一层包括两个 block，第一个 block 是一个 k heads 的 multi-head attention，使用 mask：</p><script type="math/tex; mode=display">\begin{aligned} \text { Attention }(X, Y, Z) &=\operatorname{softmax}\left(\frac{\operatorname{mask}\left(X Y^{\top}\right)}{\sqrt{d}}\right) Z \\ \text { MultiHead }(X, k) &=\left[h_{1} ; \cdots ; h_{k}\right] W_{o} \\ \text { where } h_{j} &=\text { Attention }\left(X W_{j}^{1}, X W_{j}^{2}, X W_{j}^{3}\right) \end{aligned}</script><p>第二个 block 是一个 ReLU 激活的前馈网络：</p><script type="math/tex; mode=display">F F(X)=\max (0, X U) V</script><p>每个 block 执行 normalization 然后是一个 residual 连接：</p><p>Block1：</p><script type="math/tex; mode=display">\begin{aligned} \overline{X}_{i} &=\text { LayerNorm }\left(X_{i}\right) \\ H_{i} &=\text { MultiHead }\left(\overline{X}_{i}\right)+\overline{X}_{i} \end{aligned}</script><p>Block2：</p><script type="math/tex; mode=display">\begin{aligned} \overline{H}_{i} &=\text { LayerNorm }\left(H_{i}\right) \\ X_{i+1} &=\operatorname{FF}\left(\overline{H}_{i}\right)+\overline{H}_{i} \end{aligned}</script><p>每个 token 的 score：</p><script type="math/tex; mode=display">\text { Scores }\left(X_{0}\right)=\text { LayerNorm }\left(X_{l}\right) W_{\text {vocab}}</script><p>训练时，scores 作为 cross-entropy loss function 的输入；生成时，scores 与最终的 token（softmax 后的）相关，然后产生用于采用新 token 的分布。</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>140G</p><ul><li>Wiki: En, De, Es, Fr</li><li>Project Gutenberg: <a href="https://github.com/chiphuyen/lazynlp" target="_blank" rel="noopener">https://github.com/chiphuyen/lazynlp</a></li><li>Submissions from 45 subreddits</li><li>OpenWebText: <a href="https://github.com/jcpeterson/openwebtext" target="_blank" rel="noopener">https://github.com/jcpeterson/openwebtext</a></li><li>News</li><li>Amazon Reviews</li><li>WMT (En-De, En-Es, En-Fr)</li><li>question-answer pairs from ELI5 and MRQA task (<a href="https://github.com/mrqa/MRQA-Shared-Task-2019" target="_blank" rel="noopener">https://github.com/mrqa/MRQA-Shared-Task-2019</a>)</li></ul><p><img src="http://qnimg.lovevivian.cn/paper-ctrl-1.jpeg" alt=""></p><h3 id="Experimental-Settings"><a href="#Experimental-Settings" class="headerlink" title="Experimental Settings"></a>Experimental Settings</h3><ul><li>Use <a href="https://github.com/glample/fastBPE" target="_blank" rel="noopener">fastBPE</a> tokenize</li><li>Vocabulary: 250K tokens, includes sub-word tokens</li><li>the first token of each sequence is the domain</li><li>model dimension d = 1280</li><li>inner dimension f = 8192, 48 layers and 16 heads per layer</li><li>dropout: 0.1</li><li>token embeddings tied with the final output embedding layer</li><li>batch size: 1024</li><li>800k iterations</li><li>Adagrad with a linear warmup from 0 to 0.05 over 25k steps</li><li>norm of gradients clipped to 0.25</li></ul><h2 id="Controllable-Generation"><a href="#Controllable-Generation" class="headerlink" title="Controllable Generation"></a>Controllable Generation</h2><h3 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h3><p>从语言模型生成文本时一般会用到 temperature-controlled stochastic sampling 方法，同时，每次生成 token 时在 top-k（而不是所有词表）中取。</p><script type="math/tex; mode=display">p_{i}=\frac{\exp \left(x_{i} / T\right)}{\sum_{j} \exp \left(x_{j} / T\right)}</script><ul><li><p>T -&gt; 0 近似贪婪分布，放大了峰值</p></li><li><p>T -&gt; ∞ 使得分布更加平坦</p></li></ul><p>k 是启发式的（自适应），xi 是每个 token 的 score；如果下个词的 confidence 比较高，k 就小一些。</p><p>在有多个非零的高概率候选 token 时，不采用模型，而是 “贪婪” 地选择下一个 token。对可能会产生的重复 token，文章提出一种新的 sample 方法，既能够近似贪婪 sampling，又能够对重复进行惩罚。惩罚的方法是对已产生的 tokens 进行打折（不在训练中使用），给定一列生成的 tokens g:</p><script type="math/tex; mode=display">p_{i}=\frac{\exp \left(x_{i} /(T \cdot I(i \in g))\right.}{\sum_{j} \exp \left(x_{j} /(T \cdot I(j \in g))\right.} \quad I(c)=\theta \text { if } c \text { is True else } 1</script><p>θ≈1.2 能够取得不错的平衡。</p><h3 id="Control-Codes"><a href="#Control-Codes" class="headerlink" title="Control Codes"></a>Control Codes</h3><ul><li>Style by domain: Wiki，Books，Reviews，Horror，Relationships，Legal</li><li>More complex control codes:<ul><li>Science Title, Politics Title, Running Text, Horror Text, Reviews Rating</li><li>不同的 Link 代表不同的特征（domain, subdomain, entities, entity relations, and even dates）</li></ul></li><li>Triggering specific tasks：问答、翻译</li><li>Zero-shot code-mixing</li></ul><p>详细可参考文中的 sample。</p><h2 id="Source-Attribution"><a href="#Source-Attribution" class="headerlink" title="Source Attribution"></a>Source Attribution</h2><p>根据之前的定义，给定 domain control code 的先验 p(c)，有：</p><script type="math/tex; mode=display">p_{\theta}(c | x) \propto p_{\theta}(x | c) p(c)</script><p>为了避免带来的不良影响，文中采用统一的先验。</p><p>模型固有地依赖于原始的关联进行预测， 它并不关心关联是否正确或好坏（事实表明，相互矛盾的主张经常出现在相同的上下文中）。CTRL 证明了特定的领域更可能包含与给定陈述相似的语言。</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ul><li>Related Work<ul><li>语言模型：词向量、上下文词向量、注意力机制</li><li>多任务学习</li><li>Sampling 方法和覆盖机制：聚焦在减少重复（替换为连贯的文本）</li></ul></li><li>Future directions<ul><li>更多和更细粒度的控制</li><li>扩展到 NLP 的其他领域</li><li>分析语言模型和语料的关系</li><li>使人与语言模型的接口更加明确和直观</li></ul></li></ul><h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><ul><li>安装依赖：Tensorflow1.14 或 PyTorch，<a href="https://github.com/glample/fastBPE" target="_blank" rel="noopener">glample/fastBPE: Fast BPE</a></li><li>使用 Tensorflow 需要修复 <code>keras.py</code>：<code>patch -b &lt;path_to_tensorflow_estimator_package&gt;/python/estimator/keras.py estimator.patch</code></li><li><p>获取模型：<code>gs://sf-ctrl/seqlen256_v1.ckpt/</code> or <code>gs://sf-ctrl/seqlen512_v1.ckpt/</code> or <code>gs://sf-ctrl/seqlen256_36layers_v0.ckpt/</code>.</p><ul><li>有 <a href="https://cloud.google.com/storage/docs/gsutil_install" target="_blank" rel="noopener">gsutil</a>：<code>gsutil -m cp -r gs://sf-ctrl/seqlen256_v1.ckpt/ .</code></li><li>没有：根据这个<a href="https://github.com/salesforce/ctrl/issues/7#issuecomment-531303214" target="_blank" rel="noopener">链接</a>，要翻墙，且记得创建一个文件夹，比如：<code>mkdir -p seqlen256_v1.ckpt</code>。用 <code>wget</code> 貌似不用翻墙也可以直接下载。注意：模型有十几个 G。</li></ul></li><li><p>运行：<code>generation.py</code> 或 <code>source_attribution.py</code></p><ul><li><code>generation.py</code> 提示用户输入文本，然后生成接下来的部分</li><li><code>source_attribution.py</code> 提示用户输入文本，然后列出排序的 domain 和文本基于 domain 的 ppl</li></ul></li><li><p>精调：</p><ul><li>修复 <code>keras.py</code></li><li>获取数据并转为 TFRecords：<code>python make_tf_records.py --text_file YOUR_FILE --control_code YOUR_CTRL_CODE --sequence_len 256</code>，<code>CTRL_CODE</code> 是一个词表中的 token，会被添加到每条数据中；<code>sequence_len</code> 需要和训练时的一样。</li><li>训练：<code>python training.py --model_dir &lt;path_to_model&gt;.ckpt/ --iterations &lt;number_of_iterations&gt;</code>，如果数据很少，可以调低 <code>iterations</code>。</li><li>生成：<code>python training.py --model_dir seqlen256_v1.ckpt/ --iterations 250</code></li></ul></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><code>source_attribution.py</code> 比较简单，导进来模型后，根据输入的文本循环计算不同 domain 的 ppl，然后从大到小排序输出。代码是这样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ppls = &#123;&#125;</span><br><span class="line">xent = <span class="number">0</span></span><br><span class="line"><span class="comment"># 计算其中一个 domain 的 ppl</span></span><br><span class="line"><span class="comment"># text[1:] 把 domain 去掉</span></span><br><span class="line"><span class="keyword">for</span> sequence_idx, token_idx <span class="keyword">in</span> enumerate(text[<span class="number">1</span>:]):</span><br><span class="line">    token = idx2word[token_idx]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># compute the probability of this token</span></span><br><span class="line">    Z = np.exp(token_scores[sequence_idx]).sum()</span><br><span class="line">    token_prob = np.exp(token_scores[sequence_idx, token_idx]) / Z </span><br><span class="line">    xent -= np.log(token_prob) / len(text[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">ppls[domain] = round(np.exp(xent), <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>ppl 用了下面这个公式（这里底数用了自然对数）：</p><script type="math/tex; mode=display">P P(S)=2^{-\frac{1}{N} \sum \log \left(P\left(w_{i}\right)\right)}</script><p><code>generation.py</code> 是生成的代码，有几个需要注意的：</p><ul><li><p>如果输入的 token 超过了 <code>seq_length</code>（如上面的 256），则划过前面若干个 token 让剩下的在范围内：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># text 为输入的文本 ids</span></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> range(len(text)<span class="number">-1</span>, args.generate_num<span class="number">-1</span>):</span><br><span class="line">    <span class="comment"># get the logits from the prediction function</span></span><br><span class="line">    <span class="comment"># the logic here is a bit convoluted because we are allowing generation past 512 tokens</span></span><br><span class="line">    <span class="comment"># this is done by sliding the window over (past 512 tokens) and continuing prediction</span></span><br><span class="line">    <span class="keyword">if</span> token &lt;= seq_length:</span><br><span class="line">        prompt_logits = predict_fn(&#123;<span class="string">'input_1'</span>:tokens_generated[:, :seq_length]&#125;)[<span class="string">'tied_embedding_softmax'</span>].squeeze() / (temperature <span class="keyword">if</span> temperature&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">1.</span>)</span><br><span class="line">        _token = token <span class="keyword">if</span> token &lt; seq_length <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        _token = <span class="number">-1</span></span><br><span class="line">        <span class="comment"># slide 在这里</span></span><br><span class="line">        end = token + <span class="number">1</span></span><br><span class="line">        start = token - seq_length + <span class="number">2</span></span><br><span class="line">        prompt_logits = predict_fn(&#123;<span class="string">'input_1'</span>:np.hstack((tokens_generated[:,<span class="number">0</span>:<span class="number">1</span>], tokens_generated[:,start:end]))&#125;)[<span class="string">'tied_embedding_softmax'</span>].squeeze() / (temperature <span class="keyword">if</span> temperature&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">1.</span>)</span><br></pre></td></tr></table></figure></li><li><p>计算 <code>logits</code> 使用了 temperature-controlled stochastic sampling 方法</p></li><li><p>使用了惩罚：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if penalty (for repetition) is non-zero,</span></span><br><span class="line"><span class="comment"># discount the logits from already generated tokens</span></span><br><span class="line"><span class="keyword">if</span> penalty&gt;<span class="number">0</span>:</span><br><span class="line">    penalized_so_far = set()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(token+<span class="number">1</span>):</span><br><span class="line">        generated_token = tokens_generated[<span class="number">0</span>][_]</span><br><span class="line">        <span class="comment"># don't penalize newlines</span></span><br><span class="line">        <span class="comment"># you could also choose not to penalize frequent words</span></span><br><span class="line">        <span class="comment"># (which incidentally are sorted in the vocab file)</span></span><br><span class="line">        <span class="comment"># but I don't do that</span></span><br><span class="line">        <span class="comment"># if it prints too many new lines instead of continuing generating text,</span></span><br><span class="line">        <span class="comment"># you might want to comment this out</span></span><br><span class="line">        <span class="keyword">if</span> idx2word[generated_token] == <span class="string">'\n'</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> generated_token <span class="keyword">in</span> penalized_so_far:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        penalized_so_far.add(generated_token)</span><br><span class="line">        prompt_logits[_token][generated_token] /= penalty</span><br></pre></td></tr></table></figure></li><li><p>选择 next token 时有三种方法：top-k，启发式 k，所有的 token</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># compute probabilities from logits</span></span><br><span class="line">prompt_probs = np.exp(prompt_logits[_token])</span><br><span class="line">prompt_probs = prompt_probs / sum(prompt_probs)</span><br><span class="line"><span class="comment"># 从小到大排列再反转</span></span><br><span class="line">pruned_list = np.argsort(prompt_probs)[::<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># if you are using nucleus prob, then compute the nucleus probability size</span></span><br><span class="line"><span class="keyword">if</span> nucleusprob &gt; <span class="number">0.</span>:</span><br><span class="line">    minimum_topk = <span class="number">1</span></span><br><span class="line">    nucleus = max(np.where(np.cumsum(np.sort(prompt_probs)[::<span class="number">-1</span>])&gt;nucleusprob)[<span class="number">0</span>][<span class="number">0</span>], minimum_topk)</span><br><span class="line"><span class="keyword">elif</span> topk &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># we are over-loading notation here</span></span><br><span class="line">    <span class="comment"># if you choose to specify a topk instead of a nucleus,</span></span><br><span class="line">    <span class="comment"># we will hardcode the nucleus to be just that</span></span><br><span class="line">    nucleus = topk</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># if you specify neither nucleus or topk,</span></span><br><span class="line">    <span class="comment"># then we will use the whole list</span></span><br><span class="line">    nucleus = len(pruned_list)</span><br><span class="line">            </span><br><span class="line">pruned_list = pruned_list[:nucleus]</span><br></pre></td></tr></table></figure></li></ul><p>最后也是最重要的——模型： <code>transformer.py</code></p><ul><li><p>Encoder: lookup -&gt; sqrt -&gt; add position -&gt; Dropout -&gt; EncoderLayer -&gt; LayerNormalization</p></li><li><p>EncoderLayer: </p><ul><li>Block1: LayerNormalization -&gt; MultiHeadAttention -&gt; Dropout -&gt; +x = out1</li><li>Block2:  out1 -&gt; LayerNormalization -&gt; FFN -&gt; Dropout -&gt; +out1 = out2</li></ul></li><li><p>MultiHeadAttention: v,k,q = LayerNormalization(x) -&gt; scaled_dot_product_attention</p></li></ul><p>精调的 <code>train.py</code> 是在已有的模型基础上 train 的，不是特别复杂，在 <code>training_utils</code> 下面，这里略过了。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>相信通过以上内容能够对论文和代码有个基本的了解，论文其实还好，代码的细节还是不少的（比如上面提到的），相比而言 model 本身倒是没有什么特别的。如果要迁移到中文，Input 需要做一些调整，再就是需要从头到尾训模型。作者已经发布的 256 seqlen 的有十几个 G，有 GPU 或 TPU 的可以尝试跑一个。</p><p>本文最大的特色体现在 “CTRL”，使用 control code 控制文本生成，控制代码可以是主题、实体、关系、特定任务等等。其实它的本质与之前的 Bert 类似：多任务 + 语言模型；这里的多任务可以看作是一个多分类任务。不过本文的切入角度是 “控制文本生成”，虽然是以类别标签的方式，但不得不说这是一个不错的创新点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;paper: &lt;a href=&quot;https://einstein.ai/presentations/ctrl.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ctrl.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;code: &lt;a href=&quot;https://github.com/salesforce/ctrl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;salesforce/ctrl: Conditional Transformer Language Model for Controllable Generation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心思想：借鉴多任务，将文本标签作为输入的一部分（放在开头）控制文本生成。&lt;/p&gt;
&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;文本生成最大的问题是难以对其进行控制，本文发布了一个 1.6 billion 参数的条件 transformer language model，训练能够 govern 风格、内容、特定任务行为等的控制代码。控制代码来自与原始文本共现的结构，保留了无监督学习的优点，同时提供对文本生成更明确的控制。这些控制代码还允许 CTRL 预测训练数据的哪些部分最有可能给出序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Feeling" scheme="https://www.yam.gift/categories/Feeling/"/>
    
    
      <category term="NLP" scheme="https://www.yam.gift/tags/NLP/"/>
    
      <category term="Transformer" scheme="https://www.yam.gift/tags/Transformer/"/>
    
      <category term="Ctrl" scheme="https://www.yam.gift/tags/Ctrl/"/>
    
      <category term="Text Generation" scheme="https://www.yam.gift/tags/Text-Generation/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL Glance</title>
    <link href="https://www.yam.gift/2019/08/24/GraphQL/2019-08-24-GraphQL/"/>
    <id>https://www.yam.gift/2019/08/24/GraphQL/2019-08-24-GraphQL/</id>
    <published>2019-08-24T10:00:00.000Z</published>
    <updated>2019-08-24T10:52:29.403Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This is a quick and simple glance to the raw document (in the references), maybe you could treat it as a brief note. Hope it’s helpful to u.</p></blockquote><div class="toc"><ul class="toc-item"><li><span><a href="#Core-Concepts" data-toc-modified-id="Core-Concepts-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Core Concepts</a></span><ul class="toc-item"><li><span><a href="#The-Schema-Definition-Language-(SDL)" data-toc-modified-id="The-Schema-Definition-Language-(SDL)-1.1"><span class="toc-item-num">1.1&nbsp;&nbsp;</span>The Schema Definition Language (SDL)</a></span></li><li><span><a href="#Fetching-Data-with-Queries" data-toc-modified-id="Fetching-Data-with-Queries-1.2"><span class="toc-item-num">1.2&nbsp;&nbsp;</span>Fetching Data with Queries</a></span></li><li><span><a href="#Writing-Data-with-Mutations" data-toc-modified-id="Writing-Data-with-Mutations-1.3"><span class="toc-item-num">1.3&nbsp;&nbsp;</span>Writing Data with Mutations</a></span></li><li><span><a href="#Realtime-Updates-with-Subscriptions" data-toc-modified-id="Realtime-Updates-with-Subscriptions-1.4"><span class="toc-item-num">1.4&nbsp;&nbsp;</span>Realtime Updates with Subscriptions</a></span></li><li><span><a href="#Defining-a-Schema" data-toc-modified-id="Defining-a-Schema-1.5"><span class="toc-item-num">1.5&nbsp;&nbsp;</span>Defining a Schema</a></span></li></ul></li><li><span><a href="#Architecture" data-toc-modified-id="Architecture-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Architecture</a></span></li><li><span><a href="#Clients" data-toc-modified-id="Clients-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Clients</a></span></li><li><span><a href="#Server" data-toc-modified-id="Server-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>Server</a></span><ul class="toc-item"><li><span><a href="#GraphQL-execution" data-toc-modified-id="GraphQL-execution-4.1"><span class="toc-item-num">4.1&nbsp;&nbsp;</span>GraphQL execution</a></span></li><li><span><a href="#Batched-Resolving" data-toc-modified-id="Batched-Resolving-4.2"><span class="toc-item-num">4.2&nbsp;&nbsp;</span>Batched Resolving</a></span></li></ul></li><li><span><a href="#More-Concepts" data-toc-modified-id="More-Concepts-5"><span class="toc-item-num">5&nbsp;&nbsp;</span>More Concepts</a></span><ul class="toc-item"><li><span><a href="#Enhancing-Reusability-with-Fragments" data-toc-modified-id="Enhancing-Reusability-with-Fragments-5.1"><span class="toc-item-num">5.1&nbsp;&nbsp;</span>Enhancing Reusability with Fragments</a></span></li><li><span><a href="#Parameterizing-Fields-with-Arguments" data-toc-modified-id="Parameterizing-Fields-with-Arguments-5.2"><span class="toc-item-num">5.2&nbsp;&nbsp;</span>Parameterizing Fields with Arguments</a></span></li><li><span><a href="#Named-Query-Results-with-Aliases" data-toc-modified-id="Named-Query-Results-with-Aliases-5.3"><span class="toc-item-num">5.3&nbsp;&nbsp;</span>Named Query Results with Aliases</a></span></li><li><span><a href="#Advanced-SDL" data-toc-modified-id="Advanced-SDL-5.4"><span class="toc-item-num">5.4&nbsp;&nbsp;</span>Advanced SDL</a></span></li></ul></li><li><span><a href="#Tooling-and-Ecosystem" data-toc-modified-id="Tooling-and-Ecosystem-6"><span class="toc-item-num">6&nbsp;&nbsp;</span>Tooling and Ecosystem</a></span></li><li><span><a href="#Security" data-toc-modified-id="Security-7"><span class="toc-item-num">7&nbsp;&nbsp;</span>Security</a></span><ul class="toc-item"><li><span><a href="#Timeout" data-toc-modified-id="Timeout-7.1"><span class="toc-item-num">7.1&nbsp;&nbsp;</span>Timeout</a></span></li><li><span><a href="#Maximum-Query-Depth" data-toc-modified-id="Maximum-Query-Depth-7.2"><span class="toc-item-num">7.2&nbsp;&nbsp;</span>Maximum Query Depth</a></span></li><li><span><a href="#Query-Complexity" data-toc-modified-id="Query-Complexity-7.3"><span class="toc-item-num">7.3&nbsp;&nbsp;</span>Query Complexity</a></span></li><li><span><a href="#Throttling" data-toc-modified-id="Throttling-7.4"><span class="toc-item-num">7.4&nbsp;&nbsp;</span>Throttling</a></span></li></ul></li><li><span><a href="#References" data-toc-modified-id="References-8"><span class="toc-item-num">8&nbsp;&nbsp;</span>References</a></span></li></ul></div><p>At its core, GraphQL enables <em>declarative data fetching</em> where a client can specify exactly what data it needs from an API. GraphQL is a <em>query language</em> for APIs - not databases. </p><p><strong>REST vs GraphQL</strong></p><ul><li>Data Fetching: multiple endpoints VS single query</li><li>Over-fetching and Under-fetching (n+1) : fixed data structure VS given exact data</li><li>Rapid Product Iterations on the Frontend: adjust with data change VS flexible</li><li>Insightful Analytics on the Backend: fine-grained insights about the data</li><li>Benefits of a Schema &amp; Type System: type system =&gt; schema, frontend and backends can do their work without further communication</li></ul><a id="more"></a><h3 id="Core-Concepts"><a href="#Core-Concepts" class="headerlink" title="Core Concepts"></a>Core Concepts</h3><h4 id="The-Schema-Definition-Language-SDL"><a href="#The-Schema-Definition-Language-SDL" class="headerlink" title="The Schema Definition Language (SDL)"></a>The Schema Definition Language (SDL)</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Person &#123;</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">age:</span> Int! <span class="comment"># ! means required</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># associate</span></span><br><span class="line">type Post &#123;</span><br><span class="line">  <span class="symbol">title:</span> String!</span><br><span class="line">  <span class="symbol">author:</span> Person!</span><br><span class="line">&#125;</span><br><span class="line">type Person &#123;</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">age:</span> Int!</span><br><span class="line">  <span class="symbol">posts:</span> [Post!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fetching-Data-with-Queries"><a href="#Fetching-Data-with-Queries" class="headerlink" title="Fetching Data with Queries"></a>Fetching Data with Queries</h4><p>GraphQL APIs typically only expose <em>a single endpoint</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##### Basic query #####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Query with fields: name and age</span></span><br><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Query nested</span></span><br><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    posts &#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ==&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"allPersons"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Johnny"</span>,</span><br><span class="line">        <span class="string">"age"</span>: 23,</span><br><span class="line">        <span class="string">"posts"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"GraphQL is awesome"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"Relay is a powerful GraphQL Client"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query with arguements</span></span><br><span class="line">&#123;</span><br><span class="line">  allPersons(last: 2) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ==&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"allPersons"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Sarah"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Alice"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Writing-Data-with-Mutations"><a href="#Writing-Data-with-Mutations" class="headerlink" title="Writing Data with Mutations"></a>Writing Data with Mutations</h4><p>Three kinds of mutations:</p><ul><li>creating new data</li><li>updating existing data</li><li>deleting existing data</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># when sending mutation, new information will return at the same time (in a single roundtrip).</span></span><br><span class="line">mutation &#123;</span><br><span class="line">  createPerson(<span class="symbol">name:</span> <span class="string">"Bob"</span>, <span class="symbol">age:</span> <span class="number">36</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Expanding type</span></span><br><span class="line">type Person &#123;</span><br><span class="line">  <span class="symbol">id:</span> ID!</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">age:</span> Int!</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Then can query id</span></span><br><span class="line">mutation &#123;</span><br><span class="line">  createPerson(<span class="symbol">name:</span> <span class="string">"Alice"</span>, <span class="symbol">age:</span> <span class="number">36</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Realtime-Updates-with-Subscriptions"><a href="#Realtime-Updates-with-Subscriptions" class="headerlink" title="Realtime Updates with Subscriptions"></a>Realtime Updates with Subscriptions</h4><p>When a client <em>subscribes</em> to an event, it will initiate and hold a steady connection to the server. Whenever that particular event then actually happens, the server pushes the corresponding data to the client. </p><p>Unlike queries and mutations that follow a typical “<em>request-response</em>-cycle”, subscriptions represent a <em>stream</em> of data sent over to the client.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  newPerson &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Defining-a-Schema"><a href="#Defining-a-Schema" class="headerlink" title="Defining a Schema"></a>Defining a Schema</h4><p>Schema is often seen as a <em>contract</em> between the server and client.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  allPersons(last: Int): [Person!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createPerson(name: String!, age: Int!): Person!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Subscription &#123;</span><br><span class="line">  newPerson: Person!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Person &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int!</span><br><span class="line">  posts: [Post!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Post &#123;</span><br><span class="line">  title: String!</span><br><span class="line">  author: Person!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><ul><li><em>ransport-layer agnostic</em>: TCP, WebSockets, etc.</li><li>doesn’t care database</li><li>doesn’t care data source</li></ul><p>The sole purpose of a resolver function is to fetch the data for its field.</p><p>When fetching data from a REST API:</p><ul><li>construct and send HTTP request (e.g. with <code>fetch</code> in Javascript)</li><li>receive and parse server response</li><li>store data locally (either simply in memory or persistent)</li><li>display data in the UI</li></ul><p>With the ideal <em>declarative data fetching</em> approach:</p><ul><li>describe data requirements</li><li>display data in UI</li></ul><p>All the lower-level networking tasks as well as storing the data should be abstracted away and the declaration of data dependencies should be the dominant part.</p><h3 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a>Clients</h3><ul><li>Directly Sending Queries and Mutations: let the system take care of sending the request and handling the response</li><li>View Layer Integrations &amp; UI updates</li><li>Caching Query Results: Concepts and Strategies<ul><li>naive approach: put the results of GraphQL queries into the store</li><li><em>normalize</em> the data beforehand: query result gets flattened and the store will only contain individual records that can be referenced with a globally unique ID</li></ul></li><li>Build-time Schema Validation &amp; Optimizations</li><li>Colocating Views and Data Dependencies: allows you to have UI code and data requirements side-by-side</li></ul><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><h4 id="GraphQL-execution"><a href="#GraphQL-execution" class="headerlink" title="GraphQL execution"></a>GraphQL execution</h4><p>The query is traversed field by field, executing “resolvers” for each field:</p><ul><li>First, every field in the query can be associated with a type</li><li>Then, run for every field. The execution starts at the query type and goes <strong>breadth-first</strong>.</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># schema</span></span><br><span class="line">type Query &#123;</span><br><span class="line">  author(<span class="symbol">id:</span> ID!): Author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Author &#123;</span><br><span class="line">  <span class="symbol">posts:</span> [Post]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Post &#123;</span><br><span class="line">  <span class="symbol">title:</span> String</span><br><span class="line">  <span class="symbol">content:</span> String</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># query</span></span><br><span class="line">query &#123;</span><br><span class="line">  author(<span class="symbol">id:</span> <span class="string">"abc"</span>) &#123;</span><br><span class="line">    posts &#123;</span><br><span class="line">      title</span><br><span class="line">      content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ==&gt;</span></span><br><span class="line">Query.author(root, &#123; <span class="symbol">id:</span> <span class="string">'abc'</span> &#125;, context) -&gt; author</span><br><span class="line">Author.posts(author, null, context) -&gt; posts</span><br><span class="line"><span class="keyword">for</span> each post <span class="keyword">in</span> posts</span><br><span class="line">  Post.title(post, null, context) -&gt; title</span><br><span class="line">  Post.content(post, null, context) -&gt; content</span><br></pre></td></tr></table></figure><h4 id="Batched-Resolving"><a href="#Batched-Resolving" class="headerlink" title="Batched Resolving"></a>Batched Resolving</h4><p>If a resolver fetches from a backend API or database, that backend might get called many times during the execution of one query. We can wrap our fetching function in a utility that will wait for all of the resolvers to run, then make sure to only fetch each item once.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># query</span><br><span class="line">query &#123;</span><br><span class="line">  posts &#123;</span><br><span class="line">    title</span><br><span class="line">    author &#123;</span><br><span class="line">      name</span><br><span class="line">      avatar</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># many times query, maybe like:</span><br><span class="line">fetch(<span class="string">'/authors/1'</span>)</span><br><span class="line">fetch(<span class="string">'/authors/2'</span>)</span><br><span class="line">fetch(<span class="string">'/authors/1'</span>)</span><br><span class="line">fetch(<span class="string">'/authors/2'</span>)</span><br><span class="line">fetch(<span class="string">'/authors/1'</span>)</span><br><span class="line">fetch(<span class="string">'/authors/2'</span>)</span><br><span class="line"># wrap our fetching</span><br><span class="line">authorLoader = <span class="keyword">new</span> AuthorLoader()</span><br><span class="line"># Queue up a bunch of fetches</span><br><span class="line">authorLoader.load(<span class="number">1</span>);</span><br><span class="line">authorLoader.load(<span class="number">2</span>);</span><br><span class="line">authorLoader.load(<span class="number">1</span>);</span><br><span class="line">authorLoader.load(<span class="number">2</span>);</span><br><span class="line"># Then, the loader only does the minimal amount of work</span><br><span class="line">fetch(<span class="string">'/authors/1'</span>);</span><br><span class="line">fetch(<span class="string">'/authors/2'</span>);</span><br><span class="line"># even better</span><br><span class="line">fetch(<span class="string">'/authors?ids=1,2'</span>)</span><br></pre></td></tr></table></figure><h3 id="More-Concepts"><a href="#More-Concepts" class="headerlink" title="More Concepts"></a>More Concepts</h3><h4 id="Enhancing-Reusability-with-Fragments"><a href="#Enhancing-Reusability-with-Fragments" class="headerlink" title="Enhancing Reusability with Fragments"></a>Enhancing Reusability with Fragments</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">age:</span> Int!</span><br><span class="line">  <span class="symbol">email:</span> String!</span><br><span class="line">  <span class="symbol">street:</span> String!</span><br><span class="line">  <span class="symbol">zipcode:</span> String!</span><br><span class="line">  <span class="symbol">city:</span> String!</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># information relate to address into a fragment</span></span><br><span class="line">fragment addressDetails on User &#123;</span><br><span class="line">  name</span><br><span class="line">  street</span><br><span class="line">  zipcode</span><br><span class="line">  city</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># query</span></span><br><span class="line">&#123;</span><br><span class="line">  allUsers &#123;</span><br><span class="line">    ... addressDetails</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># just like</span></span><br><span class="line">&#123;</span><br><span class="line">  allUsers &#123;</span><br><span class="line">    name</span><br><span class="line">    street</span><br><span class="line">    zipcode</span><br><span class="line">    city</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Parameterizing-Fields-with-Arguments"><a href="#Parameterizing-Fields-with-Arguments" class="headerlink" title="Parameterizing Fields with Arguments"></a>Parameterizing Fields with Arguments</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  <span class="symbol">allUsers:</span> [User!]!</span><br><span class="line">&#125;</span><br><span class="line">type User &#123;</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">age:</span> Int!</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># query, default argument value</span></span><br><span class="line">type Query &#123;</span><br><span class="line">  allUsers(<span class="symbol">olderThan:</span> Int = -<span class="number">1</span>): [User!]!</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># user `olderThan` argument</span></span><br><span class="line">&#123;</span><br><span class="line">  allUsers(<span class="symbol">olderThan:</span> <span class="number">30</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Named-Query-Results-with-Aliases"><a href="#Named-Query-Results-with-Aliases" class="headerlink" title="Named Query Results with Aliases"></a>Named Query Results with Aliases</h4><p>send multiple queries in a single request</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># error, since it’s the same field but different arguments. </span></span><br><span class="line">&#123;</span><br><span class="line">  User(<span class="symbol">id:</span> <span class="string">"1"</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  User(<span class="symbol">id:</span> <span class="string">"2"</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># use alias</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="symbol">first:</span> User(<span class="symbol">id:</span> <span class="string">"1"</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="symbol">second:</span> User(<span class="symbol">id:</span> <span class="string">"2"</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Advanced-SDL"><a href="#Advanced-SDL" class="headerlink" title="Advanced SDL"></a>Advanced SDL</h4><ul><li>Object &amp; Scalar Types<ul><li><em>Scalar</em> types represent concrete units of data. The GraphQL spec has five predefined scalars: as <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Boolean</code>, and <code>ID</code>.</li><li><em>Object</em> types have <em>fields</em> that express the properties of that type and are composable. Examples of object types are the <code>User</code> or <code>Post</code> types we saw in the previous section.</li></ul></li><li>Enums<ul><li>express the semantics of a type that has a fixed set of values.</li><li>technically enums are special kinds of scalar types.</li></ul></li><li>Interface: used to describe a type in an abstract way</li><li>Union Types: express that a type should be <em>either</em> of a collection of other types.</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enum</span></span><br><span class="line">enum Weekday &#123;</span><br><span class="line">  MONDAY</span><br><span class="line">  TUESDAY</span><br><span class="line">  WEDNESDAY</span><br><span class="line">  THURSDAY</span><br><span class="line">  FRIDAY</span><br><span class="line">  SATURDAY</span><br><span class="line">  SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># interface</span></span><br><span class="line">interface Node &#123;</span><br><span class="line">  <span class="symbol">id:</span> ID!</span><br><span class="line">&#125;</span><br><span class="line">type User implements Node &#123;</span><br><span class="line">  <span class="symbol">id:</span> ID!</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">age:</span> Int!</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># union</span></span><br><span class="line">type Adult &#123;</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">work:</span> String!</span><br><span class="line">&#125;</span><br><span class="line">type Child &#123;</span><br><span class="line">  <span class="symbol">name:</span> String!</span><br><span class="line">  <span class="symbol">school:</span> String!</span><br><span class="line">&#125;</span><br><span class="line">union Person = Adult | Child</span><br><span class="line"><span class="comment"># retrieve information with *conditional fragments*:</span></span><br><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name <span class="comment"># works for `Adult` and `Child`</span></span><br><span class="line">    ... on Child &#123;</span><br><span class="line">      school</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Adult &#123;</span><br><span class="line">       work</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tooling-and-Ecosystem"><a href="#Tooling-and-Ecosystem" class="headerlink" title="Tooling and Ecosystem"></a>Tooling and Ecosystem</h3><p>GraphQL allows clients to ask a server for information about its schema. GraphQL calls this <strong>introspection</strong>.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># querying the __schema meta-field</span></span><br><span class="line">query &#123;</span><br><span class="line">  __schema &#123;</span><br><span class="line">    types &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># query a single type using the __type meta-field and ask for its name and description. </span></span><br><span class="line">&#123;</span><br><span class="line">  __type(<span class="symbol">name:</span> <span class="string">"Author"</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">    description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><h4 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h4><p>defend against large queries. </p><p>Pros:</p><ul><li>Simple to implement.</li><li>Most strategies will still use a timeout as a final protection.</li></ul><p>Cons:</p><ul><li>Damage can already be done even when the timeout kicks in.</li><li>Sometimes hard to implement. Cutting connections after a certain time may result in strange behaviours.</li></ul><h4 id="Maximum-Query-Depth"><a href="#Maximum-Query-Depth" class="headerlink" title="Maximum Query Depth"></a>Maximum Query Depth</h4><p>By analyzing the query document’s abstract syntax tree (AST), a GraphQL server is able to reject or accept a request based on its depth.</p><p>Pros: Since the AST of the document is analyzed statically, the query does not even execute, which adds no load on GraphQL server.</p><p>Cons: Depth alone is often not enough to cover all abusive queries. </p><h4 id="Query-Complexity"><a href="#Query-Complexity" class="headerlink" title="Query Complexity"></a>Query Complexity</h4><p>Define how complex these fields are, and to restrict queries with a maximum complexity. A common default is to give each field a complexity of <code>1</code>. </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  author(<span class="symbol">id:</span> <span class="string">"abc"</span>) &#123; <span class="comment"># complexity: 1</span></span><br><span class="line">    posts &#123;           <span class="comment"># complexity: 1</span></span><br><span class="line">      title           <span class="comment"># complexity: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Also can set a different complexity depending on arguments! </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  author(<span class="symbol">id:</span> <span class="string">"abc"</span>) &#123;    <span class="comment"># complexity: 1</span></span><br><span class="line">    posts(<span class="symbol">first:</span> <span class="number">5</span>) &#123;    <span class="comment"># complexity: 5</span></span><br><span class="line">      title              <span class="comment"># complexity: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pros:</p><ul><li>Covers more cases than a simple query depth.</li><li>Reject queries before executing them by statically analyzing the complexity.</li></ul><p>Cons:</p><ul><li>Hard to implement perfectly.</li><li>If complexity is estimated by developers, how do we keep it up to date? How do we find the costs in the first place?</li><li>Mutations are hard to estimate. What if they have a side effect that is hard to measure, like queuing a background job?</li></ul><h4 id="Throttling"><a href="#Throttling" class="headerlink" title="Throttling"></a>Throttling</h4><p>In most APIs, a simple throttle is used to stop clients from requesting resources too often. </p><ul><li><p>Throttling Based on Server Time</p><ul><li>A good estimate of how expensive a query is the server time it needs to complete. We can use this heuristic to throttle queries. </li><li>Throttling based on time is a great way to throttle GraphQL queries since complex queries will end up consuming more time meaning you can call them less often, and smaller queries may be called more often since they will be very fast to compute.</li></ul></li><li><p>Throttling Based on Query Complexity</p><ul><li>We can come up with a maximum cost (Bucket Size) per time a client can use.</li><li>The GitHub public API actually uses this approach. </li></ul></li></ul><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://www.howtographql.com/" target="_blank" rel="noopener">How to GraphQL - The Fullstack Tutorial for GraphQL</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;This is a quick and simple glance to the raw document (in the references), maybe you could treat it as a brief note. Hope it’s helpful to u.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;toc&quot;&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Core-Concepts&quot; data-toc-modified-id=&quot;Core-Concepts-1&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;1&amp;nbsp;&amp;nbsp;&lt;/span&gt;Core Concepts&lt;/a&gt;&lt;/span&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#The-Schema-Definition-Language-(SDL)&quot; data-toc-modified-id=&quot;The-Schema-Definition-Language-(SDL)-1.1&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;1.1&amp;nbsp;&amp;nbsp;&lt;/span&gt;The Schema Definition Language (SDL)&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Fetching-Data-with-Queries&quot; data-toc-modified-id=&quot;Fetching-Data-with-Queries-1.2&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;1.2&amp;nbsp;&amp;nbsp;&lt;/span&gt;Fetching Data with Queries&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Writing-Data-with-Mutations&quot; data-toc-modified-id=&quot;Writing-Data-with-Mutations-1.3&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;1.3&amp;nbsp;&amp;nbsp;&lt;/span&gt;Writing Data with Mutations&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Realtime-Updates-with-Subscriptions&quot; data-toc-modified-id=&quot;Realtime-Updates-with-Subscriptions-1.4&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;1.4&amp;nbsp;&amp;nbsp;&lt;/span&gt;Realtime Updates with Subscriptions&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Defining-a-Schema&quot; data-toc-modified-id=&quot;Defining-a-Schema-1.5&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;1.5&amp;nbsp;&amp;nbsp;&lt;/span&gt;Defining a Schema&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Architecture&quot; data-toc-modified-id=&quot;Architecture-2&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;2&amp;nbsp;&amp;nbsp;&lt;/span&gt;Architecture&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Clients&quot; data-toc-modified-id=&quot;Clients-3&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;3&amp;nbsp;&amp;nbsp;&lt;/span&gt;Clients&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Server&quot; data-toc-modified-id=&quot;Server-4&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;4&amp;nbsp;&amp;nbsp;&lt;/span&gt;Server&lt;/a&gt;&lt;/span&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#GraphQL-execution&quot; data-toc-modified-id=&quot;GraphQL-execution-4.1&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;4.1&amp;nbsp;&amp;nbsp;&lt;/span&gt;GraphQL execution&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Batched-Resolving&quot; data-toc-modified-id=&quot;Batched-Resolving-4.2&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;4.2&amp;nbsp;&amp;nbsp;&lt;/span&gt;Batched Resolving&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#More-Concepts&quot; data-toc-modified-id=&quot;More-Concepts-5&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;5&amp;nbsp;&amp;nbsp;&lt;/span&gt;More Concepts&lt;/a&gt;&lt;/span&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Enhancing-Reusability-with-Fragments&quot; data-toc-modified-id=&quot;Enhancing-Reusability-with-Fragments-5.1&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;5.1&amp;nbsp;&amp;nbsp;&lt;/span&gt;Enhancing Reusability with Fragments&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Parameterizing-Fields-with-Arguments&quot; data-toc-modified-id=&quot;Parameterizing-Fields-with-Arguments-5.2&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;5.2&amp;nbsp;&amp;nbsp;&lt;/span&gt;Parameterizing Fields with Arguments&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Named-Query-Results-with-Aliases&quot; data-toc-modified-id=&quot;Named-Query-Results-with-Aliases-5.3&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;5.3&amp;nbsp;&amp;nbsp;&lt;/span&gt;Named Query Results with Aliases&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Advanced-SDL&quot; data-toc-modified-id=&quot;Advanced-SDL-5.4&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;5.4&amp;nbsp;&amp;nbsp;&lt;/span&gt;Advanced SDL&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Tooling-and-Ecosystem&quot; data-toc-modified-id=&quot;Tooling-and-Ecosystem-6&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;6&amp;nbsp;&amp;nbsp;&lt;/span&gt;Tooling and Ecosystem&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Security&quot; data-toc-modified-id=&quot;Security-7&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;7&amp;nbsp;&amp;nbsp;&lt;/span&gt;Security&lt;/a&gt;&lt;/span&gt;&lt;ul class=&quot;toc-item&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Timeout&quot; data-toc-modified-id=&quot;Timeout-7.1&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;7.1&amp;nbsp;&amp;nbsp;&lt;/span&gt;Timeout&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Maximum-Query-Depth&quot; data-toc-modified-id=&quot;Maximum-Query-Depth-7.2&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;7.2&amp;nbsp;&amp;nbsp;&lt;/span&gt;Maximum Query Depth&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Query-Complexity&quot; data-toc-modified-id=&quot;Query-Complexity-7.3&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;7.3&amp;nbsp;&amp;nbsp;&lt;/span&gt;Query Complexity&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#Throttling&quot; data-toc-modified-id=&quot;Throttling-7.4&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;7.4&amp;nbsp;&amp;nbsp;&lt;/span&gt;Throttling&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;#References&quot; data-toc-modified-id=&quot;References-8&quot;&gt;&lt;span class=&quot;toc-item-num&quot;&gt;8&amp;nbsp;&amp;nbsp;&lt;/span&gt;References&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;At its core, GraphQL enables &lt;em&gt;declarative data fetching&lt;/em&gt; where a client can specify exactly what data it needs from an API. GraphQL is a &lt;em&gt;query language&lt;/em&gt; for APIs - not databases. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REST vs GraphQL&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data Fetching: multiple endpoints VS single query&lt;/li&gt;
&lt;li&gt;Over-fetching and Under-fetching (n+1) : fixed data structure VS given exact data&lt;/li&gt;
&lt;li&gt;Rapid Product Iterations on the Frontend: adjust with data change VS flexible&lt;/li&gt;
&lt;li&gt;Insightful Analytics on the Backend: fine-grained insights about the data&lt;/li&gt;
&lt;li&gt;Benefits of a Schema &amp;amp; Type System: type system =&amp;gt; schema, frontend and backends can do their work without further communication&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="GraphQL" scheme="https://www.yam.gift/tags/GraphQL/"/>
    
      <category term="Query" scheme="https://www.yam.gift/tags/Query/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL Elixir Glance</title>
    <link href="https://www.yam.gift/2019/08/24/GraphQL/2019-08-24-GraphQL-Elixir/"/>
    <id>https://www.yam.gift/2019/08/24/GraphQL/2019-08-24-GraphQL-Elixir/</id>
    <published>2019-08-24T10:00:00.000Z</published>
    <updated>2019-08-24T10:41:47.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>There are several problems with the origin docs, so I reproduced this quick glance. It’s much simple and only contains the brief information. Hope this is helpful to u.</p></blockquote><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>Schema-Driven Development</p><ul><li>Define your types and the appropriate queries and mutations for them.</li><li>Implement functions called <strong>resolvers</strong> to handle these types and their fields.</li><li>As new requirements arrive, go back to step 1 to update the schema, and continue through the other steps.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step1: create</span></span><br><span class="line">$ mix phx.new community --no-html</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step2: add dependencies to `mix.exs`</span></span><br><span class="line">&#123;:dataloader, <span class="string">"~&gt; 1.0.0"</span>&#125;, <span class="comment"># absinthe_ecto was DEPRECATED</span></span><br><span class="line">&#123;:absinthe_plug, <span class="string">"~&gt; 1.4.0"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step3: modify database info in `config/dev.exs`</span></span><br><span class="line"><span class="comment"># maybe you should modify username or password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step4: install deps</span></span><br><span class="line">$ mix deps.get</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step5: generate tables and seed data</span></span><br><span class="line">$ mix phx.gen.context News Link links url:string description:text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step6: add seed data in `priv/repo/seeds.exs`</span></span><br><span class="line"><span class="built_in">alias</span> Community.News.Link</span><br><span class="line"><span class="built_in">alias</span> Community.Repo</span><br><span class="line">%Link&#123;url: <span class="string">"http://graphql.org/"</span>, description: <span class="string">"The Best Query Language"</span>&#125; |&gt; Repo.insert!</span><br><span class="line">%Link&#123;url: <span class="string">"http://dev.apollodata.com/"</span>, description: <span class="string">"Awesome GraphQL Client"</span>&#125; |&gt; Repo.insert!</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step7: setup ecto (create + migrate)</span></span><br><span class="line">$ mix ecto.setup</span><br></pre></td></tr></table></figure><p>You should see two pieces of items in the <code>links</code> table.</p><a id="more"></a><h2 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h2><p><strong>Step1: Defining the Schema</strong></p><p>Add a <code>:link</code> object to the schema, and an <code>:all_links</code> field to the root query object</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib/community_web/schema.ex</span></span><br><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">CommunityWeb</span></span>.Schema <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">use</span> Absinthe.Schema</span><br><span class="line"></span><br><span class="line">  <span class="keyword">alias</span> CommunityWeb.NewsResolver</span><br><span class="line"></span><br><span class="line">  object <span class="symbol">:link</span> <span class="keyword">do</span></span><br><span class="line">    field <span class="symbol">:id</span>, non_null(<span class="symbol">:id</span>)</span><br><span class="line">    field <span class="symbol">:url</span>, non_null(<span class="symbol">:string</span>)</span><br><span class="line">    field <span class="symbol">:description</span>, non_null(<span class="symbol">:string</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  query <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># allLinks is still ok, all_links is for elixir idiomatic</span></span><br><span class="line">    field <span class="symbol">:all_links</span>, non_null(list_of(non_null(<span class="symbol">:link</span>)))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Step2: Query Resolver</strong></p><p>Resolvers are just functions mapped to GraphQL fields, with their actual behavior.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib/community_web/schema.ex</span></span><br><span class="line">field <span class="symbol">:all_links</span>, non_null(list_of(non_null(<span class="symbol">:link</span>))) <span class="keyword">do</span></span><br><span class="line">  resolve &amp;NewsResolver.all_links/<span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># lib/community_web/resolvers/news_resolver.ex</span></span><br><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">CommunityWeb</span></span>.NewsResolver <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">alias</span> Community.News</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">all_links</span></span>(_root, _args, _info) <span class="keyword">do</span></span><br><span class="line">    links = News.list_links()</span><br><span class="line">    &#123;<span class="symbol">:ok</span>, links&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Step3: Router</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib/community_web/router.ex</span></span><br><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">CommunityWeb</span></span>.Router <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">use</span> CommunityWeb, <span class="symbol">:router</span></span><br><span class="line"></span><br><span class="line">  pipeline <span class="symbol">:api</span> <span class="keyword">do</span></span><br><span class="line">    plug <span class="symbol">:accepts</span>, [<span class="string">"json"</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  scope <span class="string">"/"</span> <span class="keyword">do</span></span><br><span class="line">    pipe_through <span class="symbol">:api</span></span><br><span class="line"></span><br><span class="line">    forward <span class="string">"/graphiql"</span>, Absinthe.Plug.GraphiQL,</span><br><span class="line">      <span class="symbol">schema:</span> CommunityWeb.Schema,</span><br><span class="line">      <span class="symbol">interface:</span> <span class="symbol">:simple</span>,</span><br><span class="line">      <span class="symbol">context:</span> %&#123;<span class="symbol">pubsub:</span> CommunityWeb.Endpoint&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Launch server：<code>iex -S mix phx.server</code>, open <a href="http://localhost:4000/graphiql" target="_blank" rel="noopener">localhost:4000/graphiql</a> to query:</p><p><img src="http://qnimg.lovevivian.cn/html-graphql-elixir-tutorial-1.jpeg" alt=""></p><h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h2><p><strong>Mutation for creating links</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib/community_web/schema.ex</span></span><br><span class="line">mutation <span class="keyword">do</span></span><br><span class="line">  field <span class="symbol">:create_link</span>, <span class="symbol">:link</span> <span class="keyword">do</span></span><br><span class="line">    arg <span class="symbol">:url</span>, non_null(<span class="symbol">:string</span>)</span><br><span class="line">    arg <span class="symbol">:description</span>, non_null(<span class="symbol">:string</span>)</span><br><span class="line"></span><br><span class="line">    resolve &amp;NewsResolver.create_link/<span class="number">3</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Resolvers with arguments</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib/community_web/resolvers/news_resolver.ex</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_link</span></span>(_root, args, _info) <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># <span class="doctag">TODO:</span> add detailed error message handling later</span></span><br><span class="line">  <span class="keyword">case</span> News.create_link(args) <span class="keyword">do</span></span><br><span class="line">    &#123;<span class="symbol">:ok</span>, link&#125; -&gt;</span><br><span class="line">      &#123;<span class="symbol">:ok</span>, link&#125;</span><br><span class="line">    _error -&gt;</span><br><span class="line">      &#123;<span class="symbol">:error</span>, <span class="string">"could not create link"</span>&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Query again:</p><p><img src="http://qnimg.lovevivian.cn/html-graphql-elixir-tutorial-2.jpeg" alt=""></p><p>We’ve done. It’s very easy so I didn’t push the code to GitHub</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.howtographql.com/graphql-elixir/0-introduction/" target="_blank" rel="noopener">Building a GraphQL Server with Elixir Backend Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;There are several problems with the origin docs, so I reproduced this quick glance. It’s much simple and only contains the brief information. Hope this is helpful to u.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Getting-Started&quot;&gt;&lt;a href=&quot;#Getting-Started&quot; class=&quot;headerlink&quot; title=&quot;Getting Started&quot;&gt;&lt;/a&gt;Getting Started&lt;/h2&gt;&lt;p&gt;Schema-Driven Development&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define your types and the appropriate queries and mutations for them.&lt;/li&gt;
&lt;li&gt;Implement functions called &lt;strong&gt;resolvers&lt;/strong&gt; to handle these types and their fields.&lt;/li&gt;
&lt;li&gt;As new requirements arrive, go back to step 1 to update the schema, and continue through the other steps.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Step1: create&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mix phx.new community --no-html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Step2: add dependencies to `mix.exs`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;:dataloader, &lt;span class=&quot;string&quot;&gt;&quot;~&amp;gt; 1.0.0&quot;&lt;/span&gt;&amp;#125;, &lt;span class=&quot;comment&quot;&gt;# absinthe_ecto was DEPRECATED&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;:absinthe_plug, &lt;span class=&quot;string&quot;&gt;&quot;~&amp;gt; 1.4.0&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Step3: modify database info in `config/dev.exs`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# maybe you should modify username or password&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Step4: install deps&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mix deps.get&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Step5: generate tables and seed data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mix phx.gen.context News Link links url:string description:text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Step6: add seed data in `priv/repo/seeds.exs`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;alias&lt;/span&gt; Community.News.Link&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;alias&lt;/span&gt; Community.Repo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%Link&amp;#123;url: &lt;span class=&quot;string&quot;&gt;&quot;http://graphql.org/&quot;&lt;/span&gt;, description: &lt;span class=&quot;string&quot;&gt;&quot;The Best Query Language&quot;&lt;/span&gt;&amp;#125; |&amp;gt; Repo.insert!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%Link&amp;#123;url: &lt;span class=&quot;string&quot;&gt;&quot;http://dev.apollodata.com/&quot;&lt;/span&gt;, description: &lt;span class=&quot;string&quot;&gt;&quot;Awesome GraphQL Client&quot;&lt;/span&gt;&amp;#125; |&amp;gt; Repo.insert!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Step7: setup ecto (create + migrate)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mix ecto.setup&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;You should see two pieces of items in the &lt;code&gt;links&lt;/code&gt; table.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="GraphQL" scheme="https://www.yam.gift/tags/GraphQL/"/>
    
      <category term="Elixir" scheme="https://www.yam.gift/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://www.yam.gift/2019/08/06/LeetCode/2019-08-06-LeetCode/"/>
    <id>https://www.yam.gift/2019/08/06/LeetCode/2019-08-06-LeetCode/</id>
    <published>2019-08-06T15:00:00.000Z</published>
    <updated>2019-08-06T14:56:09.111Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://yam.gift/2019/07/13/LeetCode/2019-07-13-Longest-Substring-Without-Repeating-Characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters (LeetCode 3) | Yam</a></li><li><a href="https://yam.gift/2019/07/18/LeetCode/2019-07-15-Median-of-Two-Sorted-Arrays/" target="_blank" rel="noopener">Median of Two Sorted Arrays (LeetCode 4) | Yam</a></li><li><a href="https://yam.gift/2019/08/03/LeetCode/2019-08-03-Longest-Palindromic-Substring/" target="_blank" rel="noopener">Longest Palindromic Substring (LeetCode 5) | Yam</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://yam.gift/2019/07/13/LeetCode/2019-07-13-Longest-Substring-Without-Repeating-Characters/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="Coding" scheme="https://www.yam.gift/categories/Coding/"/>
    
    
      <category term="Python" scheme="https://www.yam.gift/tags/Python/"/>
    
      <category term="Code" scheme="https://www.yam.gift/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>Paper Note</title>
    <link href="https://www.yam.gift/2019/08/06/Paper/2019-08-06-Paper/"/>
    <id>https://www.yam.gift/2019/08/06/Paper/2019-08-06-Paper/</id>
    <published>2019-08-06T15:00:00.000Z</published>
    <updated>2019-12-15T11:14:22.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DeepLearning"><a href="#DeepLearning" class="headerlink" title="DeepLearning"></a>DeepLearning</h2><ul><li><a href="https://yam.gift/2019/08/04/Paper/2019-08-04-Attention-Is-All-You-Need/" target="_blank" rel="noopener">Attention Is All You Need Note | Yam</a></li></ul><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><ul><li><a href="https://yam.gift/2019/08/05/Paper/2019-08-05-Bert-Paper/" target="_blank" rel="noopener">Bert, Pre-training of Deep Bidirectional Transformers for Language Understanding Note | Yam</a></li><li><a href="https://yam.gift/2019/07/14/Paper/2019-07-14-XLNet-Paper/" target="_blank" rel="noopener">XLNet, Generalized Autoregressive Pretraining for Language Understanding Note | Yam</a></li><li><a href="https://yam.gift/2019/08/02/Paper/2019-08-02-Baidu-ERNIE-Tutorial/" target="_blank" rel="noopener">ERNIE Tutorial（论文笔记 + 实践指南） | Yam</a></li><li><a href="https://yam.gift/2019/09/28/Paper/2019-09-28-CTRL/" target="_blank" rel="noopener">CTRL 论文 + 实践 + 源码 | Yam</a></li><li><a href="https://yam.gift/2019/12/08/Paper/2019-12-08-ELECTRA-Paper/" target="_blank" rel="noopener">ELECTRA, Pre-Training Text Encoders as Discriminators Rather Than Generators Note | Yam</a></li><li><a href="https://yam.gift/2019/12/15/Paper/2019-12-15-Few-Shot-Charge-Prediction-with-Discriminative-Legal-Attributes/" target="_blank" rel="noopener">Few-Shot Charge Prediction with Discriminative Legal Attributes Note | Yam</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DeepLearning&quot;&gt;&lt;a href=&quot;#DeepLearning&quot; class=&quot;headerlink&quot; title=&quot;DeepLearning&quot;&gt;&lt;/a&gt;DeepLearning&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://yam.gif
      
    
    </summary>
    
    
      <category term="Feeling" scheme="https://www.yam.gift/categories/Feeling/"/>
    
    
      <category term="NLP" scheme="https://www.yam.gift/tags/NLP/"/>
    
      <category term="DeepLearning" scheme="https://www.yam.gift/tags/DeepLearning/"/>
    
      <category term="Paper" scheme="https://www.yam.gift/tags/Paper/"/>
    
  </entry>
  
</feed>
